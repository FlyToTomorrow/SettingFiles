<?xml version="1.0" encoding="Windows-1252" ?>
    <!--
    @author Gregori Gerebtzoff
    @version 1.2
    -->
<NotepadPlus>
    <AutoComplete>
        <Environment ignoreCase="no" startFunc="(" stopFunc=")" paramSeparator="," additionalWordChar = "." />
		<KeyWord name="ABCMeta" func="yes">
			<Overload retVal="" descr="Function of abc.ABCMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="ARRAY" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="AddPackagePath" func="yes">
			<Overload retVal="" descr="Function of modulefinder">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgInfo" func="yes">
			<Overload retVal="" descr="Function of inspect.ArgInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgSpec" func="yes">
			<Overload retVal="" descr="Function of inspect.ArgSpec">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgumentDefaultsHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgumentParser" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="Arguments" func="yes">
			<Overload retVal="" descr="Function of inspect.Arguments">
			</Overload>
		</KeyWord>
		<KeyWord name="ArithmeticError" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Array" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="AssertionError" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="At" func="yes">
			<Overload retVal="" descr="Function of SimpleDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="AtEnd" func="yes">
			<Overload retVal="" descr="Function of FileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="AtInsert" func="yes">
			<Overload retVal="" descr="Function of Tix">
			</Overload>
		</KeyWord>
		<KeyWord name="AtSelFirst" func="yes">
			<Overload retVal="" descr="Function of Tix">
			</Overload>
		</KeyWord>
		<KeyWord name="AtSelLast" func="yes">
			<Overload retVal="" descr="Function of Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="Attribute" func="yes">
			<Overload retVal="" descr="Function of inspect.Attribute">
			</Overload>
		</KeyWord>
		<KeyWord name="AttributeError" func="yes">
			<Overload retVal="" descr="Attribute not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="AudioDev" func="yes">
			<Overload retVal="" descr="Function of audiodev">
			</Overload>
		</KeyWord>
		<KeyWord name="BZ2Compressor" func="yes">
			<Overload retVal="" descr="Function of bz2.BZ2Compressor">
			</Overload>
		</KeyWord>
		<KeyWord name="BZ2Decompressor" func="yes">
			<Overload retVal="" descr="Function of bz2.BZ2Decompressor">
			</Overload>
		</KeyWord>
		<KeyWord name="BZ2File" func="yes">
			<Overload retVal="" descr="Function of bz2.BZ2File">
			</Overload>
		</KeyWord>
		<KeyWord name="BackgroundBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.BackgroundBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.BaseBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseCookie" func="yes">
			<Overload retVal="" descr="Function of Cookie.BaseCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseException" func="yes">
			<Overload retVal="" descr="Common base class for all exceptions">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer" func="yes">
			<Overload retVal="" descr="HTTP server base class.&#10;&#10;Note: the class in this module doesn't implement any HTTP request; see&#10;SimpleHTTPServer for simple implementations of GET, HEAD and POST&#10;(including CGI scripts).  It does, however, optionally implement HTTP/1.1&#10;persistent connections, as of version 0.3.&#10;&#10;Contents:&#10;&#10;- BaseHTTPRequestHandler: HTTP request handler base class&#10;- test: test function&#10;&#10;XXX To do:&#10;&#10;- log requests even later (to capture byte count)&#10;- log user-agent header and other interesting goodies&#10;- send error log to separate file">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.BaseHTTPRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.DEFAULT_ERROR_CONTENT_TYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.DEFAULT_ERROR_MESSAGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.HTTPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.catch_warnings" func="yes">
			<Overload retVal="" descr="A context manager that copies and restores the warnings filter upon&#10;exiting the context.&#10;&#10;The 'record' argument specifies whether warnings should be captured by a&#10;custom implementation of warnings.showwarning() and be appended to a list&#10;returned by the context manager. Otherwise None is returned by the context&#10;manager. The objects appended to the list are arguments whose attributes&#10;mirror the arguments to showwarning().&#10;&#10;The 'module' argument is to specify an alternative module to the module&#10;named 'warnings' and imported under that name. This argument is only useful&#10;when testing the warnings module itself.">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.filterwarnings" func="yes">
			<Overload retVal="" descr="Insert an entry into the list of warnings filters (at the front).&#10;&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'message' -- a regex that the warning message must match&#10;'category' -- a class that the warning must be a subclass of&#10;'module' -- a regex that the module name must match&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[message" />
				<Param name="[category=<type 'exceptions.Warning'>" />
				<Param name="[module" />
				<Param name="[lineno=0" />
				<Param name="[append=0]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="BaseHTTPServer.test" func="yes">
			<Overload retVal="" descr="Test the HTTP request handler class.&#10;&#10;This runs an HTTP server on port 8000 (or the first command line&#10;argument).">
				<Param name="[HandlerClass=BaseHTTPServer.BaseHTTPRequestHandler" />
				<Param name="[ServerClass=BaseHTTPServer.HTTPServer" />
				<Param name="[protocol=HTTP/1.0]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="BaseSet" func="yes">
			<Overload retVal="" descr="Function of sets.BaseSet">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseTestSuite" func="yes">
			<Overload retVal="" descr="Function of unittest.BaseTestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion" func="yes">
			<Overload retVal="" descr="Bastionification utility.&#10;&#10;A bastion (for another object -- the 'original') is an object that has&#10;the same methods as the original but does not give access to its&#10;instance variables.  Bastions have a number of uses, but the most&#10;obvious one is to provide code executing in restricted mode with a&#10;safe interface to an object implemented in unrestricted mode.&#10;&#10;The bastionification routine has an optional second argument which is&#10;a filter function.  Only those methods for which the filter method&#10;(called with the method name as argument) returns true are accessible.&#10;The default filter method returns true unless the method name begins&#10;with an underscore.&#10;&#10;There are a number of possible implementations of bastions.  We use a&#10;'lazy' approach where the bastion's __getattr__() discipline does all&#10;the work for a particular method the first time it is used.  This is&#10;usually fastest, especially if the user doesn't call all available&#10;methods.  The retrieved methods are stored as instance variables of&#10;the bastion, so the overhead is only occurred on the first use of each&#10;method.&#10;&#10;Detail: the bastion class has a __repr__() discipline which includes&#10;the repr() of the original object.  This is precomputed when the&#10;bastion is created.">
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion.Bastion" func="yes">
			<Overload retVal="" descr="Create a bastion for an object, using an optional filter.&#10;&#10;See the Bastion module's documentation for background.&#10;&#10;Arguments:&#10;&#10;object - the original object&#10;filter - a predicate that decides whether a function name is OK;&#10;         by default all names are OK that don't start with '_'&#10;name - the name of the object; default repr(object)&#10;bastionclass - class used to create the bastion; default BastionClass">
				<Param name="object" />
				<Param name="[filter=<function <lambda> at 0x00000000033E45F8>" />
				<Param name="[name=None" />
				<Param name="[bastionclass=Bastion.BastionClass]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion.BastionClass" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Bastion.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Beep" func="yes">
			<Overload retVal="" descr="Function of winsound">
			</Overload>
		</KeyWord>
		<KeyWord name="Boolean" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.Boolean">
			</Overload>
		</KeyWord>
		<KeyWord name="BooleanType" func="yes">
			<Overload retVal="" descr="Function of Tkinter.BooleanType">
			</Overload>
		</KeyWord>
		<KeyWord name="BoundedSemaphore" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferError" func="yes">
			<Overload retVal="" descr="Buffer error.">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedIncrementalDecoder" func="yes">
			<Overload retVal="" descr="Function of codecs.BufferedIncrementalDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedIncrementalEncoder" func="yes">
			<Overload retVal="" descr="Function of codecs.BufferedIncrementalEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedRWPair" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRWPair">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedRandom" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRandom">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedReader" func="yes">
			<Overload retVal="" descr="Function of io.BufferedReader">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedWriter" func="yes">
			<Overload retVal="" descr="Function of io.BufferedWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferingFormatter" func="yes">
			<Overload retVal="" descr="Function of logging.BufferingFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="BytesIO" func="yes">
			<Overload retVal="" descr="Function of io.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="BytesWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about bytes and buffer related problems, mostly&#10;related to conversion from str or comparing to str.">
			</Overload>
		</KeyWord>
		<KeyWord name="CFUNCTYPE" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="CGIHTTPServer" func="yes">
			<Overload retVal="" descr="CGI-savvy HTTP Server.&#10;&#10;This module builds on SimpleHTTPServer by implementing GET and POST&#10;requests to cgi-bin scripts.&#10;&#10;If the os.fork() function is not present (e.g. on Windows),&#10;os.popen2() is used as a fallback, with slightly altered semantics; if&#10;that function is not present either (e.g. on Macintosh), only Python&#10;scripts are supported, and they are executed by the current process.&#10;&#10;In all cases, the implementation is intentionally naive -- all&#10;requests are executed sychronously.&#10;&#10;SECURITY WARNING: DON'T USE THIS CODE UNLESS YOU ARE INSIDE A FIREWALL&#10;-- it may execute arbitrary Python code or external programs.&#10;&#10;Note that status code 200 is sent prior to execution of a CGI script, so&#10;scripts cannot send other status codes such as 302 (redirect).">
			</Overload>
		</KeyWord>
		<KeyWord name="CGIHTTPServer.CGIHTTPRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="CGIHTTPServer.executable" func="yes">
			<Overload retVal="" descr="Test for executable file.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="CGIHTTPServer.nobody_uid" func="yes">
			<Overload retVal="" descr="Internal routine to get nobody's uid">
			</Overload>
		</KeyWord>
		<KeyWord name="CGIHTTPServer.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[HandlerClass=CGIHTTPServer.CGIHTTPRequestHandler" />
				<Param name="[ServerClass=BaseHTTPServer.HTTPServer]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cache" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cache">
			</Overload>
		</KeyWord>
		<KeyWord name="Calendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="CallableProxyType" func="yes">
			<Overload retVal="" descr="Function of weakref.CallableProxyType">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas" />
		<KeyWord name="Canvas.Arc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Bitmap" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.CanvasItem" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.CanvasText" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Group" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.ImageItem" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Line" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Oval" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Polygon" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Rectangle" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Canvas.Window" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Catalog" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="Chrome" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Chrome">
			</Overload>
		</KeyWord>
		<KeyWord name="Chromium" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Chromium">
			</Overload>
		</KeyWord>
		<KeyWord name="Clamped" func="yes">
			<Overload retVal="" descr="Function of decimal.Clamped">
			</Overload>
		</KeyWord>
		<KeyWord name="Class" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="CodecInfo" func="yes">
			<Overload retVal="" descr="Function of codecs.CodecInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="ComplexType" func="yes">
			<Overload retVal="" descr="Function of tkCommonDialog.ComplexType">
			</Overload>
		</KeyWord>
		<KeyWord name="Condition" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser" func="yes">
			<Overload retVal="" descr="Configuration file parser.&#10;&#10;A setup file consists of sections, lead by a &quot;[section]&quot; header,&#10;and followed by &quot;name: value&quot; entries, with continuations and such in&#10;the style of RFC 822.&#10;&#10;The option values can contain format strings which refer to other values in&#10;the same section, or values in a special [DEFAULT] section.&#10;&#10;For example:&#10;&#10;    something: %(dir)s/whatever&#10;&#10;would resolve the &quot;%(dir)s&quot; to the value of dir.  All reference&#10;expansions are done late, on demand.&#10;&#10;Intrinsic defaults can be specified by passing them into the&#10;ConfigParser constructor as a dictionary.&#10;&#10;class:&#10;&#10;ConfigParser -- responsible for parsing a list of&#10;                configuration files, and managing the parsed database.&#10;&#10;    methods:&#10;&#10;    __init__(defaults=None)&#10;        create the parser and specify a dictionary of intrinsic defaults.  The&#10;        keys must be strings, the values must be appropriate for %()s string&#10;        interpolation.  Note that `__name__' is always an intrinsic default;&#10;        its value is the section's name.&#10;&#10;    sections()&#10;        return all the configuration section names, sans DEFAULT&#10;&#10;    has_section(section)&#10;        return whether the given section exists&#10;&#10;    has_option(section, option)&#10;        return whether the given option exists in the given section&#10;&#10;    options(section)&#10;        return list of configuration options for the named section&#10;&#10;    read(filenames)&#10;        read and parse the list of named configuration files, given by&#10;        name.  A single filename is also allowed.  Non-existing files&#10;        are ignored.  Return list of successfully read files.&#10;&#10;    readfp(fp, filename=None)&#10;        read and parse one configuration file, given as a file object.&#10;        The filename defaults to fp.name; it is only used in error&#10;        messages (if fp has no `name' attribute, the string `&lt;???&gt;' is used).&#10;&#10;    get(section, option, raw=False, vars=None)&#10;        return a string value for the named option.  All % interpolations are&#10;        expanded in the return values, based on the defaults passed into the&#10;        constructor and the DEFAULT section.  Additional substitutions may be&#10;        provided using the `vars' argument, which must be a dictionary whose&#10;        contents override any pre-existing defaults.&#10;&#10;    getint(section, options)&#10;        like get(), but convert value to an integer&#10;&#10;    getfloat(section, options)&#10;        like get(), but convert value to a float&#10;&#10;    getboolean(section, options)&#10;        like get(), but convert value to a boolean (currently case&#10;        insensitively defined as 0, false, no, off for False, and 1, true,&#10;        yes, on for True).  Returns False or True.&#10;&#10;    items(section, raw=False, vars=None)&#10;        return a list of tuples with (name, value) for each option&#10;        in the section.&#10;&#10;    remove_section(section)&#10;        remove the given file section and all its options&#10;&#10;    remove_option(section, option)&#10;        remove the given option from the given section&#10;&#10;    set(section, option, value)&#10;        set the given option&#10;&#10;    write(fp)&#10;        write the configuration state in .ini format">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.ConfigParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.DEFAULTSECT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.DuplicateSectionError" func="yes">
			<Overload retVal="" descr="Raised when a section is multiply-created.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.DuplicateSectionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.DuplicateSectionError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.Error" func="yes">
			<Overload retVal="" descr="Base class for ConfigParser exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.Error.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationDepthError" func="yes">
			<Overload retVal="" descr="Raised when substitutions are nested too deeply.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationDepthError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationDepthError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationError" func="yes">
			<Overload retVal="" descr="Base class for interpolation-related exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationMissingOptionError" func="yes">
			<Overload retVal="" descr="A string substitution required a setting which was not available.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationMissingOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationMissingOptionError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationSyntaxError" func="yes">
			<Overload retVal="" descr="Raised when the source text into which substitutions are made&#10;does not conform to the required syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationSyntaxError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.InterpolationSyntaxError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.MAX_INTERPOLATION_DEPTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.MissingSectionHeaderError" func="yes">
			<Overload retVal="" descr="Raised when a key-value pair is found before any section header.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.MissingSectionHeaderError.append" />
		<KeyWord name="ConfigParser.MissingSectionHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.MissingSectionHeaderError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.NoOptionError" func="yes">
			<Overload retVal="" descr="A requested option was not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.NoOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.NoOptionError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.NoSectionError" func="yes">
			<Overload retVal="" descr="Raised when no section matches a requested option.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.NoSectionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.NoSectionError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.ParsingError" func="yes">
			<Overload retVal="" descr="Raised when a configuration file does not follow legal syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.ParsingError.append" />
		<KeyWord name="ConfigParser.ParsingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.ParsingError.message" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.RawConfigParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigParser.SafeConfigParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Connection" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="Context" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="ConversionSyntax" func="yes">
			<Overload retVal="" descr="Function of decimal.ConversionSyntax">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie" func="yes">
			<Overload retVal="" descr="Here's a sample session to show how to use this module.&#10;At the moment, this is the only documentation.&#10;&#10;The Basics&#10;----------&#10;&#10;Importing is easy..&#10;&#10;   &gt;&gt;&gt; import Cookie&#10;&#10;Most of the time you start by creating a cookie.  Cookies come in&#10;three flavors, each with slightly different encoding semantics, but&#10;more on that later.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SimpleCookie()&#10;   &gt;&gt;&gt; C = Cookie.SerialCookie()&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;&#10;[Note: Long-time users of Cookie.py will remember using&#10;Cookie.Cookie() to create a Cookie object.  Although deprecated, it&#10;is still supported by the code.  See the Backward Compatibility notes&#10;for more information.]&#10;&#10;Once you've created your Cookie, you can add values just as if it were&#10;a dictionary.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C[&quot;fig&quot;] = &quot;newton&quot;&#10;   &gt;&gt;&gt; C[&quot;sugar&quot;] = &quot;wafer&quot;&#10;   &gt;&gt;&gt; C.output()&#10;   'Set-Cookie: fig=newton\r\nSet-Cookie: sugar=wafer'&#10;&#10;Notice that the printable representation of a Cookie is the&#10;appropriate format for a Set-Cookie: header.  This is the&#10;default behavior.  You can change the header and printed&#10;attributes by using the .output() function&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C[&quot;rocky&quot;] = &quot;road&quot;&#10;   &gt;&gt;&gt; C[&quot;rocky&quot;][&quot;path&quot;] = &quot;/cookie&quot;&#10;   &gt;&gt;&gt; print C.output(header=&quot;Cookie:&quot;)&#10;   Cookie: rocky=road; Path=/cookie&#10;   &gt;&gt;&gt; print C.output(attrs=[], header=&quot;Cookie:&quot;)&#10;   Cookie: rocky=road&#10;&#10;The load() method of a Cookie extracts cookies from a string.  In a&#10;CGI script, you would use this method to extract the cookies from the&#10;HTTP_COOKIE environment variable.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C.load(&quot;chips=ahoy; vienna=finger&quot;)&#10;   &gt;&gt;&gt; C.output()&#10;   'Set-Cookie: chips=ahoy\r\nSet-Cookie: vienna=finger'&#10;&#10;The load() method is darn-tootin smart about identifying cookies&#10;within a string.  Escaped quotation marks, nested semicolons, and other&#10;such trickeries do not confuse it.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C.load('keebler=&quot;E=everybody; L=\\&quot;Loves\\&quot;; fudge=\\012;&quot;;')&#10;   &gt;&gt;&gt; print C&#10;   Set-Cookie: keebler=&quot;E=everybody; L=\&quot;Loves\&quot;; fudge=\012;&quot;&#10;&#10;Each element of the Cookie also supports all of the RFC 2109&#10;Cookie attributes.  Here's an example which sets the Path&#10;attribute.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C[&quot;oreo&quot;] = &quot;doublestuff&quot;&#10;   &gt;&gt;&gt; C[&quot;oreo&quot;][&quot;path&quot;] = &quot;/&quot;&#10;   &gt;&gt;&gt; print C&#10;   Set-Cookie: oreo=doublestuff; Path=/&#10;&#10;Each dictionary element has a 'value' attribute, which gives you&#10;back the value associated with the key.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C[&quot;twix&quot;] = &quot;none for you&quot;&#10;   &gt;&gt;&gt; C[&quot;twix&quot;].value&#10;   'none for you'&#10;&#10;&#10;A Bit More Advanced&#10;-------------------&#10;&#10;As mentioned before, there are three different flavors of Cookie&#10;objects, each with different encoding/decoding semantics.  This&#10;section briefly discusses the differences.&#10;&#10;SimpleCookie&#10;&#10;The SimpleCookie expects that all values should be standard strings.&#10;Just to be sure, SimpleCookie invokes the str() builtin to convert&#10;the value to a string, when the values are set dictionary-style.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SimpleCookie()&#10;   &gt;&gt;&gt; C[&quot;number&quot;] = 7&#10;   &gt;&gt;&gt; C[&quot;string&quot;] = &quot;seven&quot;&#10;   &gt;&gt;&gt; C[&quot;number&quot;].value&#10;   '7'&#10;   &gt;&gt;&gt; C[&quot;string&quot;].value&#10;   'seven'&#10;   &gt;&gt;&gt; C.output()&#10;   'Set-Cookie: number=7\r\nSet-Cookie: string=seven'&#10;&#10;&#10;SerialCookie&#10;&#10;The SerialCookie expects that all values should be serialized using&#10;cPickle (or pickle, if cPickle isn't available).  As a result of&#10;serializing, SerialCookie can save almost any Python object to a&#10;value, and recover the exact same object when the cookie has been&#10;returned.  (SerialCookie can yield some strange-looking cookie&#10;values, however.)&#10;&#10;   &gt;&gt;&gt; C = Cookie.SerialCookie()&#10;   &gt;&gt;&gt; C[&quot;number&quot;] = 7&#10;   &gt;&gt;&gt; C[&quot;string&quot;] = &quot;seven&quot;&#10;   &gt;&gt;&gt; C[&quot;number&quot;].value&#10;   7&#10;   &gt;&gt;&gt; C[&quot;string&quot;].value&#10;   'seven'&#10;   &gt;&gt;&gt; C.output()&#10;   'Set-Cookie: number=&quot;I7\\012.&quot;\r\nSet-Cookie: string=&quot;S\'seven\'\\012p1\\012.&quot;'&#10;&#10;Be warned, however, if SerialCookie cannot de-serialize a value (because&#10;it isn't a valid pickle'd object), IT WILL RAISE AN EXCEPTION.&#10;&#10;&#10;SmartCookie&#10;&#10;The SmartCookie combines aspects of each of the other two flavors.&#10;When setting a value in a dictionary-fashion, the SmartCookie will&#10;serialize (ala cPickle) the value *if and only if* it isn't a&#10;Python string.  String objects are *not* serialized.  Similarly,&#10;when the load() method parses out values, it attempts to de-serialize&#10;the value.  If it fails, then it fallsback to treating the value&#10;as a string.&#10;&#10;   &gt;&gt;&gt; C = Cookie.SmartCookie()&#10;   &gt;&gt;&gt; C[&quot;number&quot;] = 7&#10;   &gt;&gt;&gt; C[&quot;string&quot;] = &quot;seven&quot;&#10;   &gt;&gt;&gt; C[&quot;number&quot;].value&#10;   7&#10;   &gt;&gt;&gt; C[&quot;string&quot;].value&#10;   'seven'&#10;   &gt;&gt;&gt; C.output()&#10;   'Set-Cookie: number=&quot;I7\\012.&quot;\r\nSet-Cookie: string=seven'&#10;&#10;&#10;Backwards Compatibility&#10;-----------------------&#10;&#10;In order to keep compatibilty with earlier versions of Cookie.py,&#10;it is still possible to use Cookie.Cookie() to create a Cookie.  In&#10;fact, this simply returns a SmartCookie.&#10;&#10;   &gt;&gt;&gt; C = Cookie.Cookie()&#10;   &gt;&gt;&gt; print C.__class__.__name__&#10;   SmartCookie&#10;&#10;&#10;Finis.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie" />
		<KeyWord name="Cookie.BaseCookie.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.js_output" func="yes">
			<Overload retVal="" descr="Return a string suitable for JavaScript.">
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.load" func="yes">
			<Overload retVal="" descr="Load cookies from a string (presumably HTTP_COOKIE) or&#10;from a dictionary.  Loading cookies from a dictionary 'd'&#10;is equivalent to calling:&#10;    map(Cookie.__setitem__, d.keys(), d.values())">
				<Param name="self" />
				<Param name="rawdata" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.output" func="yes">
			<Overload retVal="" descr="Return a string suitable for HTTP.">
				<Param name="self" />
				<Param name="[attrs=None" />
				<Param name="[header=Set-Cookie:" />
				<Param name="[sep=
]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.value_decode" func="yes">
			<Overload retVal="" descr="real_value, coded_value = value_decode(STRING)&#10;Called prior to setting a cookie's value from the network&#10;representation.  The VALUE is the value read from HTTP&#10;header.&#10;Override this function to modify the behavior of cookies.">
				<Param name="self" />
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.value_encode" func="yes">
			<Overload retVal="" descr="real_value, coded_value = value_encode(VALUE)&#10;Called prior to setting a cookie's value from the dictionary&#10;representation.  The VALUE is the value being assigned.&#10;Override this function to modify the behavior of cookies.">
				<Param name="self" />
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.BaseCookie.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie" func="yes">
			<Overload retVal="" descr="SmartCookie&#10;SmartCookie supports arbitrary objects as cookie values.  If the&#10;object is a string, then it is quoted.  If the object is not a&#10;string, however, then SmartCookie will use cPickle to serialize&#10;the object into a string representation.&#10;&#10;Note: Large cookie values add overhead because they must be&#10;retransmitted on every HTTP transaction.&#10;&#10;Note: HTTP has a 2k limit on the size of a cookie.  This class&#10;does not check for this limit, so be careful!!!">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.js_output" func="yes">
			<Overload retVal="" descr="Return a string suitable for JavaScript.">
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.load" func="yes">
			<Overload retVal="" descr="Load cookies from a string (presumably HTTP_COOKIE) or&#10;from a dictionary.  Loading cookies from a dictionary 'd'&#10;is equivalent to calling:&#10;    map(Cookie.__setitem__, d.keys(), d.values())">
				<Param name="self" />
				<Param name="rawdata" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.output" func="yes">
			<Overload retVal="" descr="Return a string suitable for HTTP.">
				<Param name="self" />
				<Param name="[attrs=None" />
				<Param name="[header=Set-Cookie:" />
				<Param name="[sep=
]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.value_decode" />
		<KeyWord name="Cookie.Cookie.value_encode" />
		<KeyWord name="Cookie.Cookie.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Cookie.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.CookieError" />
		<KeyWord name="Cookie.CookieError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.CookieError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel" />
		<KeyWord name="Cookie.Morsel.OutputString" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.isReservedKey" />
		<KeyWord name="Cookie.Morsel.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.js_output" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.output" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[attrs=None" />
				<Param name="[header=Set-Cookie:]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.Morsel.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie" func="yes">
			<Overload retVal="" descr="SerialCookie&#10;SerialCookie supports arbitrary objects as cookie values. All&#10;values are serialized (using cPickle) before being sent to the&#10;client.  All incoming values are assumed to be valid Pickle&#10;representations.  IF AN INCOMING VALUE IS NOT IN A VALID PICKLE&#10;FORMAT, THEN AN EXCEPTION WILL BE RAISED.&#10;&#10;Note: Large cookie values add overhead because they must be&#10;retransmitted on every HTTP transaction.&#10;&#10;Note: HTTP has a 2k limit on the size of a cookie.  This class&#10;does not check for this limit, so be careful!!!">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.js_output" func="yes">
			<Overload retVal="" descr="Return a string suitable for JavaScript.">
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.load" func="yes">
			<Overload retVal="" descr="Load cookies from a string (presumably HTTP_COOKIE) or&#10;from a dictionary.  Loading cookies from a dictionary 'd'&#10;is equivalent to calling:&#10;    map(Cookie.__setitem__, d.keys(), d.values())">
				<Param name="self" />
				<Param name="rawdata" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.output" func="yes">
			<Overload retVal="" descr="Return a string suitable for HTTP.">
				<Param name="self" />
				<Param name="[attrs=None" />
				<Param name="[header=Set-Cookie:" />
				<Param name="[sep=
]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.value_decode" />
		<KeyWord name="Cookie.SerialCookie.value_encode" />
		<KeyWord name="Cookie.SerialCookie.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SerialCookie.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie" func="yes">
			<Overload retVal="" descr="SimpleCookie&#10;SimpleCookie supports strings as cookie values.  When setting&#10;the value using the dictionary assignment notation, SimpleCookie&#10;calls the builtin str() to convert the value to a string.  Values&#10;received from HTTP are kept as strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.js_output" func="yes">
			<Overload retVal="" descr="Return a string suitable for JavaScript.">
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.load" func="yes">
			<Overload retVal="" descr="Load cookies from a string (presumably HTTP_COOKIE) or&#10;from a dictionary.  Loading cookies from a dictionary 'd'&#10;is equivalent to calling:&#10;    map(Cookie.__setitem__, d.keys(), d.values())">
				<Param name="self" />
				<Param name="rawdata" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.output" func="yes">
			<Overload retVal="" descr="Return a string suitable for HTTP.">
				<Param name="self" />
				<Param name="[attrs=None" />
				<Param name="[header=Set-Cookie:" />
				<Param name="[sep=
]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.value_decode" />
		<KeyWord name="Cookie.SimpleCookie.value_encode" />
		<KeyWord name="Cookie.SimpleCookie.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SimpleCookie.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie" func="yes">
			<Overload retVal="" descr="SmartCookie&#10;SmartCookie supports arbitrary objects as cookie values.  If the&#10;object is a string, then it is quoted.  If the object is not a&#10;string, however, then SmartCookie will use cPickle to serialize&#10;the object into a string representation.&#10;&#10;Note: Large cookie values add overhead because they must be&#10;retransmitted on every HTTP transaction.&#10;&#10;Note: HTTP has a 2k limit on the size of a cookie.  This class&#10;does not check for this limit, so be careful!!!">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.js_output" func="yes">
			<Overload retVal="" descr="Return a string suitable for JavaScript.">
				<Param name="self" />
				<Param name="[attrs=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.load" func="yes">
			<Overload retVal="" descr="Load cookies from a string (presumably HTTP_COOKIE) or&#10;from a dictionary.  Loading cookies from a dictionary 'd'&#10;is equivalent to calling:&#10;    map(Cookie.__setitem__, d.keys(), d.values())">
				<Param name="self" />
				<Param name="rawdata" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.output" func="yes">
			<Overload retVal="" descr="Return a string suitable for HTTP.">
				<Param name="self" />
				<Param name="[attrs=None" />
				<Param name="[header=Set-Cookie:" />
				<Param name="[sep=
]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.value_decode" />
		<KeyWord name="Cookie.SmartCookie.value_encode" />
		<KeyWord name="Cookie.SmartCookie.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.SmartCookie.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.dumps" func="yes">
			<Overload retVal="" descr="dumps(obj, protocol=0) -- Return a string containing an object in pickle format.&#10;&#10;See the Pickler docstring for the meaning of optional argument proto.">
			</Overload>
		</KeyWord>
		<KeyWord name="Cookie.loads" func="yes">
			<Overload retVal="" descr="loads(string) -- Load a pickle from the given string">
			</Overload>
		</KeyWord>
		<KeyWord name="Counter" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="CreateRecord" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="Cursor" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="DER_cert_to_PEM_cert" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="Date" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="DateFromTicks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="Decimal" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="DecimalException" func="yes">
			<Overload retVal="" descr="Function of decimal.DecimalException">
			</Overload>
		</KeyWord>
		<KeyWord name="DecimalTuple" func="yes">
			<Overload retVal="" descr="Function of decimal.DecimalTuple">
			</Overload>
		</KeyWord>
		<KeyWord name="DefaultVerifyPaths" func="yes">
			<Overload retVal="" descr="Function of ssl.DefaultVerifyPaths">
			</Overload>
		</KeyWord>
		<KeyWord name="DeprecationWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about deprecated features.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog" />
		<KeyWord name="Dialog.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.AtEnd" />
		<KeyWord name="Dialog.AtInsert" />
		<KeyWord name="Dialog.AtSelFirst" />
		<KeyWord name="Dialog.AtSelLast" />
		<KeyWord name="Dialog.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.BuiltinFunctionType" />
		<KeyWord name="Dialog.BuiltinMethodType" />
		<KeyWord name="Dialog.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DIALOG_ICON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType" />
		<KeyWord name="Dialog.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.EllipsisType" />
		<KeyWord name="Dialog.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType" />
		<KeyWord name="Dialog.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType" />
		<KeyWord name="Dialog.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.GetSetDescriptorType" />
		<KeyWord name="Dialog.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MemberDescriptorType" />
		<KeyWord name="Dialog.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.NoneType" />
		<KeyWord name="Dialog.NotImplementedType" />
		<KeyWord name="Dialog.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TclError" />
		<KeyWord name="Dialog.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TracebackType" />
		<KeyWord name="Dialog.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.image_names" />
		<KeyWord name="Dialog.image_types" />
		<KeyWord name="Dialog.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Dict" func="yes">
			<Overload retVal="" descr="Function of plistlib.Dict">
			</Overload>
		</KeyWord>
		<KeyWord name="DictProxyType" func="yes">
			<Overload retVal="" descr="Function of SimpleDialog.DictProxyType">
			</Overload>
		</KeyWord>
		<KeyWord name="DictType" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.DictType">
			</Overload>
		</KeyWord>
		<KeyWord name="DictionaryType" func="yes">
			<Overload retVal="" descr="Function of Tix.DictionaryType">
			</Overload>
		</KeyWord>
		<KeyWord name="DivisionByZero" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionByZero">
			</Overload>
		</KeyWord>
		<KeyWord name="DivisionImpossible" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionImpossible">
			</Overload>
		</KeyWord>
		<KeyWord name="DivisionUndefined" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionUndefined">
			</Overload>
		</KeyWord>
		<KeyWord name="DllCanUnloadNow" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="DllGetClassObject" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="DocFileCase" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="DocFileSuite" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="DocFileTest" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestCase" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestSuite" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer" func="yes">
			<Overload retVal="" descr="Self documenting XML-RPC Server.&#10;&#10;This module can be used to create XML-RPC servers that&#10;serve pydoc-style documentation in response to HTTP&#10;GET requests. This documentation is dynamically generated&#10;based on the functions and methods registered with the&#10;server.&#10;&#10;This module is built upon the pydoc and SimpleXMLRPCServer&#10;modules.">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.CGIXMLRPCRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.DocCGIXMLRPCRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.DocXMLRPCRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.DocXMLRPCServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.ServerHTMLDoc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.SimpleXMLRPCRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.SimpleXMLRPCServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.XMLRPCDocGenerator" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="DocXMLRPCServer.resolve_dotted_attribute" func="yes">
			<Overload retVal="" descr="resolve_dotted_attribute(a, 'b.c.d') =&gt; a.b.c.d&#10;&#10;Resolves a dotted attribute name to an object.  Raises&#10;an AttributeError if any attribute in the chain starts with a '_'.&#10;&#10;If the optional allow_dotted_names argument is false, dots are not&#10;supported and this function operates similar to getattr(obj, attr).">
				<Param name="obj" />
				<Param name="attr" />
				<Param name="[allow_dotted_names=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="EOFError" func="yes">
			<Overload retVal="" descr="Read beyond end of file.">
			</Overload>
		</KeyWord>
		<KeyWord name="Elinks" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Elinks">
			</Overload>
		</KeyWord>
		<KeyWord name="EncodedFile" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="EnvironmentError" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="ErrorString" func="yes">
			<Overload retVal="" descr="Function of pyexpat">
			</Overload>
		</KeyWord>
		<KeyWord name="Etiny" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="Etop" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="Event" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="ExFileObject" func="yes">
			<Overload retVal="" descr="Function of tarfile.ExFileObject">
			</Overload>
		</KeyWord>
		<KeyWord name="Exception" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="FCICreate" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="FakeSocket" func="yes">
			<Overload retVal="" descr="Function of httplib">
			</Overload>
		</KeyWord>
		<KeyWord name="False" />
		<KeyWord name="FileDialog" func="yes">
			<Overload retVal="" descr="File selection dialog classes.&#10;&#10;Classes:&#10;&#10;- FileDialog&#10;- LoadFileDialog&#10;- SaveFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.AtEnd" />
		<KeyWord name="FileDialog.AtInsert" />
		<KeyWord name="FileDialog.AtSelFirst" />
		<KeyWord name="FileDialog.AtSelLast" />
		<KeyWord name="FileDialog.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.BuiltinFunctionType" />
		<KeyWord name="FileDialog.BuiltinMethodType" />
		<KeyWord name="FileDialog.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType" />
		<KeyWord name="FileDialog.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.EllipsisType" />
		<KeyWord name="FileDialog.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType" />
		<KeyWord name="FileDialog.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType" />
		<KeyWord name="FileDialog.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.GetSetDescriptorType" />
		<KeyWord name="FileDialog.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LoadFileDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MemberDescriptorType" />
		<KeyWord name="FileDialog.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.NoneType" />
		<KeyWord name="FileDialog.NotImplementedType" />
		<KeyWord name="FileDialog.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SaveFileDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TclError" />
		<KeyWord name="FileDialog.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TracebackType" />
		<KeyWord name="FileDialog.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.image_names" />
		<KeyWord name="FileDialog.image_types" />
		<KeyWord name="FileDialog.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.test" func="yes">
			<Overload retVal="" descr="Simple test program.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileDialog.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="FileHandler" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="FileHeader" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="FileIO" func="yes">
			<Overload retVal="" descr="Function of io.FileIO">
			</Overload>
		</KeyWord>
		<KeyWord name="FileType" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.FileType">
			</Overload>
		</KeyWord>
		<KeyWord name="FileTypeList" func="yes">
			<Overload retVal="" descr="Function of Tix">
			</Overload>
		</KeyWord>
		<KeyWord name="Filter" func="yes">
			<Overload retVal="" descr="Function of logging.Filter">
			</Overload>
		</KeyWord>
		<KeyWord name="Filterer" func="yes">
			<Overload retVal="" descr="Function of logging.Filterer">
			</Overload>
		</KeyWord>
		<KeyWord name="FixTk" />
		<KeyWord name="FixTk.convert_path" />
		<KeyWord name="FixTk.name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FixTk.prefix" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FixTk.tcldir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FixTk.tixdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FixTk.v" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FixTk.ver" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="FloatType" func="yes">
			<Overload retVal="" descr="Function of Tkinter.FloatType">
			</Overload>
		</KeyWord>
		<KeyWord name="FloatingPointError" func="yes">
			<Overload retVal="" descr="Floating point operation failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="FormatError" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Formatter" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="Function" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="FunctionTestCase" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="FutureWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about constructs that will change semantically&#10;in the future.">
			</Overload>
		</KeyWord>
		<KeyWord name="Galeon" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Galeon">
			</Overload>
		</KeyWord>
		<KeyWord name="GeneratorExit" func="yes">
			<Overload retVal="" descr="Request that a generator exit.">
			</Overload>
		</KeyWord>
		<KeyWord name="GeneratorType" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.GeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="GenericBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.GenericBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="Grail" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Grail">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser" func="yes">
			<Overload retVal="" descr="A parser for HTML and XHTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.HTMLParseError" func="yes">
			<Overload retVal="" descr="Exception raised for all parse errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.HTMLParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.HTMLParseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.HTMLParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.attrfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.charref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.commentclose" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.endendtag" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.endtagfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.entityref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.incomplete" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.interesting_normal" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.locatestarttagend" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.piclose" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.starttagopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.tagfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLParser.tagfind_tolerant" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="HTTPError" func="yes">
			<Overload retVal="" descr="Function of urllib2.HTTPError">
			</Overload>
		</KeyWord>
		<KeyWord name="Handler" func="yes">
			<Overload retVal="" descr="Function of logging.Handler">
			</Overload>
		</KeyWord>
		<KeyWord name="HelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="HtmlDiff" func="yes">
			<Overload retVal="" descr="Function of difflib.HtmlDiff">
			</Overload>
		</KeyWord>
		<KeyWord name="IOError" func="yes">
			<Overload retVal="" descr="I/O operation failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="ISEOF" func="yes">
			<Overload retVal="" descr="Function of token">
			</Overload>
		</KeyWord>
		<KeyWord name="ISNONTERMINAL" func="yes">
			<Overload retVal="" descr="Function of token">
			</Overload>
		</KeyWord>
		<KeyWord name="ISTERMINAL" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="IS_CHARACTER_JUNK" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="IS_LINE_JUNK" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="ImmutableSet" func="yes">
			<Overload retVal="" descr="Function of sets.ImmutableSet">
			</Overload>
		</KeyWord>
		<KeyWord name="ImportError" func="yes">
			<Overload retVal="" descr="Import can't find module, or can't find name in module.">
			</Overload>
		</KeyWord>
		<KeyWord name="ImportWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about probable mistakes in module imports">
			</Overload>
		</KeyWord>
		<KeyWord name="IncrementalDecoder" func="yes">
			<Overload retVal="" descr="Function of codecs.IncrementalDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="IncrementalEncoder" func="yes">
			<Overload retVal="" descr="Function of codecs.IncrementalEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="IncrementalNewlineDecoder" func="yes">
			<Overload retVal="" descr="Function of io.IncrementalNewlineDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="IndentationError" func="yes">
			<Overload retVal="" descr="Improper indentation.">
			</Overload>
		</KeyWord>
		<KeyWord name="IndexError" func="yes">
			<Overload retVal="" descr="Sequence index out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="Inexact" func="yes">
			<Overload retVal="" descr="Function of decimal.Inexact">
			</Overload>
		</KeyWord>
		<KeyWord name="InstanceType" func="yes">
			<Overload retVal="" descr="Function of types.InstanceType">
			</Overload>
		</KeyWord>
		<KeyWord name="Int2AP" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="IntType" func="yes">
			<Overload retVal="" descr="Function of SimpleDialog.IntType">
			</Overload>
		</KeyWord>
		<KeyWord name="Internaldate2tuple" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidContext" func="yes">
			<Overload retVal="" descr="Function of decimal.InvalidContext">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidOperation" func="yes">
			<Overload retVal="" descr="Function of decimal.InvalidOperation">
			</Overload>
		</KeyWord>
		<KeyWord name="JSONDecoder" func="yes">
			<Overload retVal="" descr="Function of json.JSONDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="JSONEncoder" func="yes">
			<Overload retVal="" descr="Function of json.JSONEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="JoinableQueue" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="KeyError" func="yes">
			<Overload retVal="" descr="Mapping key not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="KeyboardInterrupt" func="yes">
			<Overload retVal="" descr="Program interrupted by user.">
			</Overload>
		</KeyWord>
		<KeyWord name="Konqueror" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Konqueror">
			</Overload>
		</KeyWord>
		<KeyWord name="LabeledScale" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="LibraryLoader" func="yes">
			<Overload retVal="" descr="Function of ctypes.LibraryLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="ListType" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.ListType">
			</Overload>
		</KeyWord>
		<KeyWord name="LoadLibrary" func="yes">
			<Overload retVal="" descr="Function of ctypes.LibraryLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="LocaleHTMLCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="LocaleTextCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="Lock" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="LockType" func="yes">
			<Overload retVal="" descr="Function of dummy_thread.LockType">
			</Overload>
		</KeyWord>
		<KeyWord name="LogRecord" func="yes">
			<Overload retVal="" descr="Function of logging.LogRecord">
			</Overload>
		</KeyWord>
		<KeyWord name="Logger" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="LoggerAdapter" func="yes">
			<Overload retVal="" descr="Function of logging.LoggerAdapter">
			</Overload>
		</KeyWord>
		<KeyWord name="LongType" func="yes">
			<Overload retVal="" descr="Function of FileDialog.LongType">
			</Overload>
		</KeyWord>
		<KeyWord name="LookupError" func="yes">
			<Overload retVal="" descr="Base class for lookup errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Manager" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="Match" func="yes">
			<Overload retVal="" descr="Function of difflib.Match">
			</Overload>
		</KeyWord>
		<KeyWord name="MemoryError" func="yes">
			<Overload retVal="" descr="Out of memory.">
			</Overload>
		</KeyWord>
		<KeyWord name="MessageBeep" func="yes">
			<Overload retVal="" descr="Function of winsound">
			</Overload>
		</KeyWord>
		<KeyWord name="MimeWriter" func="yes">
			<Overload retVal="" descr="Generic MIME writer.&#10;&#10;This module defines the class MimeWriter.  The MimeWriter class implements&#10;a basic formatter for creating MIME multi-part files.  It doesn't seek around&#10;the output file nor does it use large amounts of buffer space. You must write&#10;the parts out in the order that they should occur in the final file.&#10;MimeWriter does buffer the headers you add, allowing you to rearrange their&#10;order.">
			</Overload>
		</KeyWord>
		<KeyWord name="MimeWriter.MimeWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="MissingSectionHeaderError" func="yes">
			<Overload retVal="" descr="Function of ConfigParser.MissingSectionHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="ModuleInfo" func="yes">
			<Overload retVal="" descr="Function of inspect.ModuleInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="Morsel" func="yes">
			<Overload retVal="" descr="Function of Cookie.Morsel">
			</Overload>
		</KeyWord>
		<KeyWord name="Mozilla" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Mozilla">
			</Overload>
		</KeyWord>
		<KeyWord name="NameError" func="yes">
			<Overload retVal="" descr="Name not found globally.">
			</Overload>
		</KeyWord>
		<KeyWord name="NamedTemporaryFile" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="NannyNag" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="Netscape" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Netscape">
			</Overload>
		</KeyWord>
		<KeyWord name="NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Function of Tkinter">
			</Overload>
		</KeyWord>
		<KeyWord name="NodeTransformer" func="yes">
			<Overload retVal="" descr="Function of ast.NodeTransformer">
			</Overload>
		</KeyWord>
		<KeyWord name="NodeVisitor" func="yes">
			<Overload retVal="" descr="Function of ast.NodeVisitor">
			</Overload>
		</KeyWord>
		<KeyWord name="None" />
		<KeyWord name="NotImplementedError" func="yes">
			<Overload retVal="" descr="Method or function hasn't been implemented yet.">
			</Overload>
		</KeyWord>
		<KeyWord name="NullHandler" func="yes">
			<Overload retVal="" descr="Function of logging.NullHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="OSError" func="yes">
			<Overload retVal="" descr="OS system call failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="OpenDatabase" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="OpenWrapper" func="yes">
			<Overload retVal="" descr="Function of io">
			</Overload>
		</KeyWord>
		<KeyWord name="Opera" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Opera">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionName" func="yes">
			<Overload retVal="" descr="Function of Tix">
			</Overload>
		</KeyWord>
		<KeyWord name="OrderedDict" func="yes">
			<Overload retVal="" descr="Function of collections.OrderedDict">
			</Overload>
		</KeyWord>
		<KeyWord name="OutputString" func="yes">
			<Overload retVal="" descr="Function of Cookie.Morsel">
			</Overload>
		</KeyWord>
		<KeyWord name="Overflow" func="yes">
			<Overload retVal="" descr="Function of decimal.Overflow">
			</Overload>
		</KeyWord>
		<KeyWord name="OverflowError" func="yes">
			<Overload retVal="" descr="Result too large to be represented.">
			</Overload>
		</KeyWord>
		<KeyWord name="PEM_cert_to_DER_cert" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="POINTER" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="PYFUNCTYPE" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="ParseFlags" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="ParseResult" func="yes">
			<Overload retVal="" descr="Function of urlparse.ParseResult">
			</Overload>
		</KeyWord>
		<KeyWord name="ParserCreate" func="yes">
			<Overload retVal="" descr="Function of pyexpat">
			</Overload>
		</KeyWord>
		<KeyWord name="ParsingError" func="yes">
			<Overload retVal="" descr="Function of ConfigParser.ParsingError">
			</Overload>
		</KeyWord>
		<KeyWord name="Pen" func="yes">
			<Overload retVal="" descr="Function of turtle.Pen">
			</Overload>
		</KeyWord>
		<KeyWord name="PendingDeprecationWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about features which will be deprecated&#10;in the future.">
			</Overload>
		</KeyWord>
		<KeyWord name="Pickler" func="yes">
			<Overload retVal="" descr="Function of shelve">
			</Overload>
		</KeyWord>
		<KeyWord name="Pipe" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="PlaceHolder" func="yes">
			<Overload retVal="" descr="Function of logging.PlaceHolder">
			</Overload>
		</KeyWord>
		<KeyWord name="PlaySound" func="yes">
			<Overload retVal="" descr="Function of winsound">
			</Overload>
		</KeyWord>
		<KeyWord name="Plist" func="yes">
			<Overload retVal="" descr="Function of plistlib.Plist">
			</Overload>
		</KeyWord>
		<KeyWord name="Pool" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="Popen" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="Process" func="yes">
			<Overload retVal="" descr="Function of multiprocessing.Process">
			</Overload>
		</KeyWord>
		<KeyWord name="Profile" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="ProxyType" func="yes">
			<Overload retVal="" descr="Function of weakref.ProxyType">
			</Overload>
		</KeyWord>
		<KeyWord name="Purpose" func="yes">
			<Overload retVal="" descr="Function of ssl.Purpose">
			</Overload>
		</KeyWord>
		<KeyWord name="PyZipFile" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue" func="yes">
			<Overload retVal="" descr="A multi-producer, multi-consumer queue.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Empty" func="yes">
			<Overload retVal="" descr="Exception raised by Queue.get(block=0)/get_nowait().">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Empty.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Empty.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Full" func="yes">
			<Overload retVal="" descr="Exception raised by Queue.put(block=0)/put_nowait().">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Full.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Full.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.LifoQueue" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.PriorityQueue" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.Queue" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;Build an ordered collection with optimized access from its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_add" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_status" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="RLock" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="Random" func="yes">
			<Overload retVal="" descr="Function of random.Random">
			</Overload>
		</KeyWord>
		<KeyWord name="RawArray" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="RawDescriptionHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.RawDescriptionHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="RawPen" func="yes">
			<Overload retVal="" descr="Function of turtle.RawPen">
			</Overload>
		</KeyWord>
		<KeyWord name="RawTextHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.RawTextHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="RawTurtle" func="yes">
			<Overload retVal="" descr="Function of turtle.RawTurtle">
			</Overload>
		</KeyWord>
		<KeyWord name="RawValue" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ReferenceError" func="yes">
			<Overload retVal="" descr="Weak ref proxy used after referent went away.">
			</Overload>
		</KeyWord>
		<KeyWord name="ReplacePackage" func="yes">
			<Overload retVal="" descr="Function of modulefinder">
			</Overload>
		</KeyWord>
		<KeyWord name="RootLogger" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="Rounded" func="yes">
			<Overload retVal="" descr="Function of decimal.Rounded">
			</Overload>
		</KeyWord>
		<KeyWord name="Row" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Row">
			</Overload>
		</KeyWord>
		<KeyWord name="RuntimeError" func="yes">
			<Overload retVal="" descr="Unspecified run-time error.">
			</Overload>
		</KeyWord>
		<KeyWord name="RuntimeWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about dubious runtime behavior.">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLContext" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLSocket" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="S_IFMT" func="yes">
			<Overload retVal="" descr="Function of stat">
			</Overload>
		</KeyWord>
		<KeyWord name="S_IMODE" func="yes">
			<Overload retVal="" descr="Function of stat">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISBLK" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISCHR" func="yes">
			<Overload retVal="" descr="Function of stat">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISDIR" func="yes">
			<Overload retVal="" descr="Function of stat">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISFIFO" func="yes">
			<Overload retVal="" descr="Function of stat">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISLNK" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISREG" func="yes">
			<Overload retVal="" descr="Function of stat">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISSOCK" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="Screen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText" func="yes">
			<Overload retVal="" descr="A ScrolledText widget feels like a text widget but also has a&#10;vertical scroll bar on its right.  (Later, options may be added to&#10;add a horizontal bar as well, to make the bars disappear&#10;automatically when not needed, to move them to the other side of the&#10;window, etc.)&#10;&#10;Configuration options are passed to the Text widget.&#10;A Frame widget is inserted between the master and the text, to hold&#10;the Scrollbar widget.&#10;Most methods calls are inherited from the Text widget; Pack, Grid and&#10;Place methods are redirected to the Frame widget however.">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.ScrolledText" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ScrolledText.example" />
		<KeyWord name="Semaphore" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="SerialCookie" func="yes">
			<Overload retVal="" descr="Function of Cookie.SerialCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="Set" func="yes">
			<Overload retVal="" descr="Function of sets.Set">
			</Overload>
		</KeyWord>
		<KeyWord name="SetPointerType" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Shape" func="yes">
			<Overload retVal="" descr="Function of turtle.Shape">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleCookie" func="yes">
			<Overload retVal="" descr="Function of Cookie.SimpleCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog" func="yes">
			<Overload retVal="" descr="A simple but flexible modal dialog box.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.AtEnd" />
		<KeyWord name="SimpleDialog.AtInsert" />
		<KeyWord name="SimpleDialog.AtSelFirst" />
		<KeyWord name="SimpleDialog.AtSelLast" />
		<KeyWord name="SimpleDialog.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.BuiltinFunctionType" />
		<KeyWord name="SimpleDialog.BuiltinMethodType" />
		<KeyWord name="SimpleDialog.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType" />
		<KeyWord name="SimpleDialog.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.EllipsisType" />
		<KeyWord name="SimpleDialog.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType" />
		<KeyWord name="SimpleDialog.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType" />
		<KeyWord name="SimpleDialog.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.GetSetDescriptorType" />
		<KeyWord name="SimpleDialog.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MemberDescriptorType" />
		<KeyWord name="SimpleDialog.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.NoneType" />
		<KeyWord name="SimpleDialog.NotImplementedType" />
		<KeyWord name="SimpleDialog.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SimpleDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TclError" />
		<KeyWord name="SimpleDialog.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TracebackType" />
		<KeyWord name="SimpleDialog.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.image_names" />
		<KeyWord name="SimpleDialog.image_types" />
		<KeyWord name="SimpleDialog.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleDialog.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleHTTPServer" func="yes">
			<Overload retVal="" descr="Simple HTTP Server.&#10;&#10;This module builds on BaseHTTPServer by implementing the standard GET&#10;and HEAD requests in a fairly straightforward manner.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleHTTPServer.SimpleHTTPRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleHTTPServer.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleHTTPServer.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[HandlerClass=SimpleHTTPServer.SimpleHTTPRequestHandler" />
				<Param name="[ServerClass=BaseHTTPServer.HTTPServer]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer" func="yes">
			<Overload retVal="" descr="Simple XML-RPC Server.&#10;&#10;This module can be used to create simple XML-RPC servers&#10;by creating a server and either installing functions, a&#10;class instance, or by extending the SimpleXMLRPCServer&#10;class.&#10;&#10;It can also be used to handle XML-RPC requests in a CGI&#10;environment using CGIXMLRPCRequestHandler.&#10;&#10;A list of possible usage patterns follows:&#10;&#10;1. Install functions:&#10;&#10;server = SimpleXMLRPCServer((&quot;localhost&quot;, 8000))&#10;server.register_function(pow)&#10;server.register_function(lambda x,y: x+y, 'add')&#10;server.serve_forever()&#10;&#10;2. Install an instance:&#10;&#10;class MyFuncs:&#10;    def __init__(self):&#10;        # make all of the string functions available through&#10;        # string.func_name&#10;        import string&#10;        self.string = string&#10;    def _listMethods(self):&#10;        # implement this method so that system.listMethods&#10;        # knows to advertise the strings methods&#10;        return list_public_methods(self) + \&#10;                ['string.' + method for method in list_public_methods(self.string)]&#10;    def pow(self, x, y): return pow(x, y)&#10;    def add(self, x, y) : return x + y&#10;&#10;server = SimpleXMLRPCServer((&quot;localhost&quot;, 8000))&#10;server.register_introspection_functions()&#10;server.register_instance(MyFuncs())&#10;server.serve_forever()&#10;&#10;3. Install an instance with custom dispatch method:&#10;&#10;class Math:&#10;    def _listMethods(self):&#10;        # this method must be present for system.listMethods&#10;        # to work&#10;        return ['add', 'pow']&#10;    def _methodHelp(self, method):&#10;        # this method must be present for system.methodHelp&#10;        # to work&#10;        if method == 'add':&#10;            return &quot;add(2,3) =&gt; 5&quot;&#10;        elif method == 'pow':&#10;            return &quot;pow(x, y[, z]) =&gt; number&quot;&#10;        else:&#10;            # By convention, return empty&#10;            # string if no help is available&#10;            return &quot;&quot;&#10;    def _dispatch(self, method, params):&#10;        if method == 'pow':&#10;            return pow(*params)&#10;        elif method == 'add':&#10;            return params[0] + params[1]&#10;        else:&#10;            raise 'bad method'&#10;&#10;server = SimpleXMLRPCServer((&quot;localhost&quot;, 8000))&#10;server.register_introspection_functions()&#10;server.register_instance(Math())&#10;server.serve_forever()&#10;&#10;4. Subclass SimpleXMLRPCServer:&#10;&#10;class MathServer(SimpleXMLRPCServer):&#10;    def _dispatch(self, method, params):&#10;        try:&#10;            # We are forcing the 'export_' prefix on methods that are&#10;            # callable through XML-RPC to prevent potential security&#10;            # problems&#10;            func = getattr(self, 'export_' + method)&#10;        except AttributeError:&#10;            raise Exception('method &quot;%s&quot; is not supported' % method)&#10;        else:&#10;            return func(*params)&#10;&#10;    def export_add(self, x, y):&#10;        return x + y&#10;&#10;server = MathServer((&quot;localhost&quot;, 8000))&#10;server.serve_forever()&#10;&#10;5. CGI script:&#10;&#10;server = CGIXMLRPCRequestHandler()&#10;server.register_function(pow)&#10;server.handle_request()">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.CGIXMLRPCRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.Fault" func="yes">
			<Overload retVal="" descr="Indicates an XML-RPC fault package.">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.Fault.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.Fault.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.MultiPathXMLRPCServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.SimpleXMLRPCDispatcher" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.SimpleXMLRPCRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.SimpleXMLRPCServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.list_public_methods" func="yes">
			<Overload retVal="" descr="Returns a list of attribute strings, found in the specified&#10;object, which represent callable attributes">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.remove_duplicates" func="yes">
			<Overload retVal="" descr="remove_duplicates([2,2,2,1,3,3]) =&gt; [3,1,2]&#10;&#10;Returns a copy of a list without duplicates. Every list&#10;item must be hashable and the order of the items in the&#10;resulting list is not defined.">
				<Param name="lst" />
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleXMLRPCServer.resolve_dotted_attribute" func="yes">
			<Overload retVal="" descr="resolve_dotted_attribute(a, 'b.c.d') =&gt; a.b.c.d&#10;&#10;Resolves a dotted attribute name to an object.  Raises&#10;an AttributeError if any attribute in the chain starts with a '_'.&#10;&#10;If the optional allow_dotted_names argument is false, dots are not&#10;supported and this function operates similar to getattr(obj, attr).">
				<Param name="obj" />
				<Param name="attr" />
				<Param name="[allow_dotted_names=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="SkipDocTestCase" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="SliceType" func="yes">
			<Overload retVal="" descr="Function of FileDialog.SliceType">
			</Overload>
		</KeyWord>
		<KeyWord name="SmartCookie" func="yes">
			<Overload retVal="" descr="Function of Cookie.SmartCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer" func="yes">
			<Overload retVal="" descr="Generic socket server classes.&#10;&#10;This module tries to capture the various aspects of defining a server:&#10;&#10;For socket-based servers:&#10;&#10;- address family:&#10;        - AF_INET{,6}: IP (Internet Protocol) sockets (default)&#10;        - AF_UNIX: Unix domain sockets&#10;        - others, e.g. AF_DECNET are conceivable (see &lt;socket.h&gt;&#10;- socket type:&#10;        - SOCK_STREAM (reliable stream, e.g. TCP)&#10;        - SOCK_DGRAM (datagrams, e.g. UDP)&#10;&#10;For request-based servers (including socket-based):&#10;&#10;- client address verification before further looking at the request&#10;        (This is actually a hook for any processing that needs to look&#10;         at the request before anything else, e.g. logging)&#10;- how to handle multiple requests:&#10;        - synchronous (one request is handled at a time)&#10;        - forking (each request is handled by a new process)&#10;        - threading (each request is handled by a new thread)&#10;&#10;The classes in this module favor the server type that is simplest to&#10;write: a synchronous TCP/IP server.  This is bad class design, but&#10;save some typing.  (There's also the issue that a deep class hierarchy&#10;slows down method lookups.)&#10;&#10;There are five classes in an inheritance diagram, four of which represent&#10;synchronous servers of four types:&#10;&#10;        +------------+&#10;        | BaseServer |&#10;        +------------+&#10;              |&#10;              v&#10;        +-----------+        +------------------+&#10;        | TCPServer |-------&gt;| UnixStreamServer |&#10;        +-----------+        +------------------+&#10;              |&#10;              v&#10;        +-----------+        +--------------------+&#10;        | UDPServer |-------&gt;| UnixDatagramServer |&#10;        +-----------+        +--------------------+&#10;&#10;Note that UnixDatagramServer derives from UDPServer, not from&#10;UnixStreamServer -- the only difference between an IP and a Unix&#10;stream server is the address family, which is simply repeated in both&#10;unix server classes.&#10;&#10;Forking and threading versions of each type of server can be created&#10;using the ForkingMixIn and ThreadingMixIn mix-in classes.  For&#10;instance, a threading UDP server class is created as follows:&#10;&#10;        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass&#10;&#10;The Mix-in class must come first, since it overrides a method defined&#10;in UDPServer! Setting the various member variables also changes&#10;the behavior of the underlying server mechanism.&#10;&#10;To implement a service, you must derive a class from&#10;BaseRequestHandler and redefine its handle() method.  You can then run&#10;various versions of the service by combining one of the server classes&#10;with your request handler class.&#10;&#10;The request handler class must be different for datagram or stream&#10;services.  This can be hidden by using the request handler&#10;subclasses StreamRequestHandler or DatagramRequestHandler.&#10;&#10;Of course, you still have to use your head!&#10;&#10;For instance, it makes no sense to use a forking server if the service&#10;contains state in memory that can be modified by requests (since the&#10;modifications in the child process would never reach the initial state&#10;kept in the parent process and passed to each child).  In this case,&#10;you can use a threading server, but you will probably have to use&#10;locks to avoid two requests that come in nearly simultaneous to apply&#10;conflicting changes to the server state.&#10;&#10;On the other hand, if you are building e.g. an HTTP server, where all&#10;data is stored externally (e.g. in the file system), a synchronous&#10;class will essentially render the service &quot;deaf&quot; while one request is&#10;being handled -- which may be for a very long time if a client is slow&#10;to read all the data it has requested.  Here a threading or forking&#10;server is appropriate.&#10;&#10;In some cases, it may be appropriate to process part of a request&#10;synchronously, but to finish processing in a forked child depending on&#10;the request data.  This can be implemented by using a synchronous&#10;server and doing an explicit fork in the request handler class&#10;handle() method.&#10;&#10;Another approach to handling multiple simultaneous requests in an&#10;environment that supports neither threads nor fork (or where these are&#10;too expensive or inappropriate for the service) is to maintain an&#10;explicit table of partially finished requests and to use select() to&#10;decide which request to work on next (or whether to handle a new&#10;incoming request).  This is particularly important for stream services&#10;where each client can potentially be connected for a long time (if&#10;threads or subprocesses cannot be used).&#10;&#10;Future work:&#10;- Standard classes for Sun RPC (which uses either UDP or TCP)&#10;- Standard mix-in classes to implement various authentication&#10;  and encryption schemes&#10;- Standard framework for select-based multiplexing&#10;&#10;XXX Open problems:&#10;- What to do with out-of-band data?&#10;&#10;BaseServer:&#10;- split generic &quot;request&quot; functionality out into BaseServer class.&#10;  Copyright (C) 2000  Luke Kenneth Casson Leighton &lt;lkcl@samba.org&gt;&#10;&#10;  example: read entries from a SQL database (requires overriding&#10;  get_request() to return a table entry from the database).&#10;  entry is processed by a RequestHandlerClass.">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.BaseRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.BaseServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.DatagramRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.ForkingMixIn" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.ForkingTCPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.ForkingUDPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.StreamRequestHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.TCPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.ThreadingMixIn" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.ThreadingTCPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.ThreadingUDPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketServer.UDPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketType" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="SplitResult" func="yes">
			<Overload retVal="" descr="Function of urlparse.SplitResult">
			</Overload>
		</KeyWord>
		<KeyWord name="StandardError" func="yes">
			<Overload retVal="" descr="Base class for all standard Python exceptions that do not represent&#10;interpreter exiting.">
			</Overload>
		</KeyWord>
		<KeyWord name="Stats" func="yes">
			<Overload retVal="" descr="Function of profile">
			</Overload>
		</KeyWord>
		<KeyWord name="StopIteration" func="yes">
			<Overload retVal="" descr="Signal the end from iterator.next().">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamHandler" func="yes">
			<Overload retVal="" descr="Function of logging.StreamHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="StringIO" func="yes">
			<Overload retVal="" descr="File-like objects that read from or write to a string buffer.&#10;&#10;This implements (nearly) all stdio methods.&#10;&#10;f = StringIO()      # ready for writing&#10;f = StringIO(buf)   # ready for reading&#10;f.close()           # explicitly release resources held&#10;flag = f.isatty()   # always false&#10;pos = f.tell()      # get current position&#10;f.seek(pos)         # set current position&#10;f.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF&#10;buf = f.read()      # read until EOF&#10;buf = f.read(n)     # read up to n bytes&#10;buf = f.readline()  # read until end of line ('\n') or EOF&#10;list = f.readlines()# list of f.readline() results until EOF&#10;f.truncate([size])  # truncate file at to at most size (default: current pos)&#10;f.write(buf)        # write at current position&#10;f.writelines(list)  # for line in list: f.write(line)&#10;f.getvalue()        # return whole file's contents as a string&#10;&#10;Notes:&#10;- Using a real file is often faster (but less convenient).&#10;- There's also a much faster implementation in C, called cStringIO, but&#10;  it's not subclassable.&#10;- fileno() is left unimplemented so that code which uses it triggers&#10;  an exception early.&#10;- Seeking far beyond EOF and then writing will insert real null&#10;  bytes that occupy space in the buffer.&#10;- There's a simple test set (see end of this file).">
			</Overload>
		</KeyWord>
		<KeyWord name="StringIO.EINVAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="StringIO.StringIO" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="StringIO.test" />
		<KeyWord name="StringType" func="yes">
			<Overload retVal="" descr="Function of types.StringType">
			</Overload>
		</KeyWord>
		<KeyWord name="Struct" func="yes">
			<Overload retVal="" descr="Function of struct.Struct">
			</Overload>
		</KeyWord>
		<KeyWord name="Style" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="Subnormal" func="yes">
			<Overload retVal="" descr="Function of decimal.Subnormal">
			</Overload>
		</KeyWord>
		<KeyWord name="Symbol" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="SymbolTable" func="yes">
			<Overload retVal="" descr="Function of symtable.SymbolTable">
			</Overload>
		</KeyWord>
		<KeyWord name="SyntaxError" func="yes">
			<Overload retVal="" descr="Invalid syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="SyntaxWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about dubious syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="SystemError" func="yes">
			<Overload retVal="" descr="Internal error in the Python interpreter.&#10;&#10;Please report this to the Python maintainer, along with the traceback,&#10;the Python version, and the hardware/OS platform and version.">
			</Overload>
		</KeyWord>
		<KeyWord name="SystemExit" func="yes">
			<Overload retVal="" descr="Request to exit from the interpreter.">
			</Overload>
		</KeyWord>
		<KeyWord name="SystemRandom" func="yes">
			<Overload retVal="" descr="Function of random.SystemRandom">
			</Overload>
		</KeyWord>
		<KeyWord name="TNavigator" func="yes">
			<Overload retVal="" descr="Function of turtle.TNavigator">
			</Overload>
		</KeyWord>
		<KeyWord name="TPen" func="yes">
			<Overload retVal="" descr="Function of turtle.TPen">
			</Overload>
		</KeyWord>
		<KeyWord name="TabError" func="yes">
			<Overload retVal="" descr="Improper mixture of spaces and tabs.">
			</Overload>
		</KeyWord>
		<KeyWord name="TarFile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="TarInfo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="Tbuffer" func="yes">
			<Overload retVal="" descr="Function of turtle.Tbuffer">
			</Overload>
		</KeyWord>
		<KeyWord name="Tcl" func="yes">
			<Overload retVal="" descr="Function of FileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="TemporaryFile" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="TestCase" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="TestLoader" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="TestProgram" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="TestResult" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="TestResults" func="yes">
			<Overload retVal="" descr="Function of doctest.TestResults">
			</Overload>
		</KeyWord>
		<KeyWord name="TestSuite" func="yes">
			<Overload retVal="" descr="Function of unittest.TestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="TextCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.TextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="TextIOWrapper" func="yes">
			<Overload retVal="" descr="Function of io.TextIOWrapper">
			</Overload>
		</KeyWord>
		<KeyWord name="TextTestResult" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="TextTestRunner" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="Thread" func="yes">
			<Overload retVal="" descr="Function of threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="Time" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Time">
			</Overload>
		</KeyWord>
		<KeyWord name="Time2Internaldate" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="TimeFromTicks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="Timer" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="Timestamp" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="TimestampFromTicks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix" />
		<KeyWord name="Tix.ACROSSTOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ASCII" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.AUTO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.AtEnd" />
		<KeyWord name="Tix.AtInsert" />
		<KeyWord name="Tix.AtSelFirst" />
		<KeyWord name="Tix.AtSelLast" />
		<KeyWord name="Tix.BALLOON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Balloon" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.BuiltinFunctionType" />
		<KeyWord name="Tix.BuiltinMethodType" />
		<KeyWord name="Tix.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ButtonBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CELL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.COLUMN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CObjView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CheckList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ComboBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Control" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DECREASING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DialogShell" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType" />
		<KeyWord name="Tix.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DirList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DirSelectBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DirSelectDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DirTree" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DisplayStyle" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.EllipsisType" />
		<KeyWord name="Tix.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ExFileSelectBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ExFileSelectDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileEntry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileSelectBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileSelectDialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FileTypeList" />
		<KeyWord name="Tix.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Form" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType" />
		<KeyWord name="Tix.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType" />
		<KeyWord name="Tix.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.GetSetDescriptorType" />
		<KeyWord name="Tix.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.HList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IMAGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IMAGETEXT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IMMEDIATE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.INCREASING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.INTEGER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.InputOnly" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LabelEntry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListNoteBook" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MAIN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MAX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MemberDescriptorType" />
		<KeyWord name="Tix.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Meter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NoneType" />
		<KeyWord name="Tix.NotImplementedType" />
		<KeyWord name="Tix.NoteBook" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.NoteBookFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.OptionName" func="yes">
			<Overload retVal="" descr="Returns the qualified path name for the widget. Normally used to set&#10;default options for subwidgets. See tixwidgets.py">
				<Param name="widget" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.PopupMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.REAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ROW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ResizeHandle" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.STATUS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.S_REGION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ScrolledGrid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ScrolledHList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ScrolledListBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ScrolledTList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ScrolledText" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.ScrolledWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Select" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Shell" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StdButtonBox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TCL_DONT_WAIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TCL_FILE_EVENTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TCL_IDLE_EVENTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TCL_TIMER_EVENTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TCL_WINDOW_EVENTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TEXT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TclError" />
		<KeyWord name="Tix.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TixSubWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TixWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TracebackType" />
		<KeyWord name="Tix.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Tree" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.WINDOW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.X_REGION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.Y_REGION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.image_names" />
		<KeyWord name="Tix.image_types" />
		<KeyWord name="Tix.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.tixCommand" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tix.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants" />
		<KeyWord name="Tkconstants.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkconstants.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkdnd" func="yes">
			<Overload retVal="" descr="Drag-and-drop support for Tkinter.&#10;&#10;This is very preliminary.  I currently only support dnd *within* one&#10;application, between different windows (or within the same window).&#10;&#10;I an trying to make this as generic as possible -- not dependent on&#10;the use of a particular widget or icon type, etc.  I also hope that&#10;this will work with Pmw.&#10;&#10;To enable an object to be dragged, you must create an event binding&#10;for it that starts the drag-and-drop process. Typically, you should&#10;bind &lt;ButtonPress&gt; to a callback function that you write. The function&#10;should call Tkdnd.dnd_start(source, event), where 'source' is the&#10;object to be dragged, and 'event' is the event that invoked the call&#10;(the argument to your callback function).  Even though this is a class&#10;instantiation, the returned instance should not be stored -- it will&#10;be kept alive automatically for the duration of the drag-and-drop.&#10;&#10;When a drag-and-drop is already in process for the Tk interpreter, the&#10;call is *ignored*; this normally averts starting multiple simultaneous&#10;dnd processes, e.g. because different button callbacks all&#10;dnd_start().&#10;&#10;The object is *not* necessarily a widget -- it can be any&#10;application-specific object that is meaningful to potential&#10;drag-and-drop targets.&#10;&#10;Potential drag-and-drop targets are discovered as follows.  Whenever&#10;the mouse moves, and at the start and end of a drag-and-drop move, the&#10;Tk widget directly under the mouse is inspected.  This is the target&#10;widget (not to be confused with the target object, yet to be&#10;determined).  If there is no target widget, there is no dnd target&#10;object.  If there is a target widget, and it has an attribute&#10;dnd_accept, this should be a function (or any callable object).  The&#10;function is called as dnd_accept(source, event), where 'source' is the&#10;object being dragged (the object passed to dnd_start() above), and&#10;'event' is the most recent event object (generally a &lt;Motion&gt; event;&#10;it can also be &lt;ButtonPress&gt; or &lt;ButtonRelease&gt;).  If the dnd_accept()&#10;function returns something other than None, this is the new dnd target&#10;object.  If dnd_accept() returns None, or if the target widget has no&#10;dnd_accept attribute, the target widget's parent is considered as the&#10;target widget, and the search for a target object is repeated from&#10;there.  If necessary, the search is repeated all the way up to the&#10;root widget.  If none of the target widgets can produce a target&#10;object, there is no target object (the target object is None).&#10;&#10;The target object thus produced, if any, is called the new target&#10;object.  It is compared with the old target object (or None, if there&#10;was no old target widget).  There are several cases ('source' is the&#10;source object, and 'event' is the most recent event object):&#10;&#10;- Both the old and new target objects are None.  Nothing happens.&#10;&#10;- The old and new target objects are the same object.  Its method&#10;dnd_motion(source, event) is called.&#10;&#10;- The old target object was None, and the new target object is not&#10;None.  The new target object's method dnd_enter(source, event) is&#10;called.&#10;&#10;- The new target object is None, and the old target object is not&#10;None.  The old target object's method dnd_leave(source, event) is&#10;called.&#10;&#10;- The old and new target objects differ and neither is None.  The old&#10;target object's method dnd_leave(source, event), and then the new&#10;target object's method dnd_enter(source, event) is called.&#10;&#10;Once this is done, the new target object replaces the old one, and the&#10;Tk mainloop proceeds.  The return value of the methods mentioned above&#10;is ignored; if they raise an exception, the normal exception handling&#10;mechanisms take over.&#10;&#10;The drag-and-drop processes can end in two ways: a final target object&#10;is selected, or no final target object is selected.  When a final&#10;target object is selected, it will always have been notified of the&#10;potential drop by a call to its dnd_enter() method, as described&#10;above, and possibly one or more calls to its dnd_motion() method; its&#10;dnd_leave() method has not been called since the last call to&#10;dnd_enter().  The target is notified of the drop by a call to its&#10;method dnd_commit(source, event).&#10;&#10;If no final target object is selected, and there was an old target&#10;object, its dnd_leave(source, event) method is called to complete the&#10;dnd sequence.&#10;&#10;Finally, the source object is notified that the drag-and-drop process&#10;is over, by a call to source.dnd_end(target, event), specifying either&#10;the selected target object, or None if no target object was selected.&#10;The source object can use this to implement the commit action; this is&#10;sometimes simpler than to do it in the target's dnd_commit().  The&#10;target's dnd_commit() method could then simply be aliased to&#10;dnd_leave().&#10;&#10;At any time during a dnd sequence, the application can cancel the&#10;sequence by calling the cancel() method on the object returned by&#10;dnd_start().  This will call dnd_leave() if a target is currently&#10;active; it will never call dnd_commit().">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkdnd.DndHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkdnd.Icon" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkdnd.Tester" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkdnd.dnd_start" />
		<KeyWord name="Tkdnd.test" />
		<KeyWord name="Tkinter" func="yes">
			<Overload retVal="" descr='Wrapper functions for Tcl/Tk.&#10;&#10;Tkinter provides classes which allow the display, positioning and&#10;control of widgets. Toplevel widgets are Tk and Toplevel. Other&#10;widgets are Frame, Label, Entry, Text, Canvas, Button, Radiobutton,&#10;Checkbutton, Scale, Listbox, Scrollbar, OptionMenu, Spinbox&#10;LabelFrame and PanedWindow.&#10;&#10;Properties of the widgets are specified with keyword arguments.&#10;Keyword arguments have the same name as the corresponding resource&#10;under Tk.&#10;&#10;Widgets are positioned with one of the geometry managers Place, Pack&#10;or Grid. These managers can be called with methods place, pack, grid&#10;available in every Widget.&#10;&#10;Actions are bound to events by resources (e.g. keyword argument&#10;command) or with the method bind.&#10;&#10;Example (Hello, World):&#10;import Tkinter&#10;from Tkconstants import *&#10;tk = Tkinter.Tk()&#10;frame = Tkinter.Frame(tk, relief=RIDGE, borderwidth=2)&#10;frame.pack(fill=BOTH,expand=1)&#10;label = Tkinter.Label(frame, text="Hello, World")&#10;label.pack(fill=X, expand=1)&#10;button = Tkinter.Button(frame,text="Exit",command=tk.destroy)&#10;button.pack(side=BOTTOM)&#10;tk.mainloop()'>
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.AtEnd" />
		<KeyWord name="Tkinter.AtInsert" />
		<KeyWord name="Tkinter.AtSelFirst" />
		<KeyWord name="Tkinter.AtSelLast" />
		<KeyWord name="Tkinter.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.BuiltinFunctionType" />
		<KeyWord name="Tkinter.BuiltinMethodType" />
		<KeyWord name="Tkinter.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType" />
		<KeyWord name="Tkinter.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.EllipsisType" />
		<KeyWord name="Tkinter.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType" />
		<KeyWord name="Tkinter.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType" />
		<KeyWord name="Tkinter.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.GetSetDescriptorType" />
		<KeyWord name="Tkinter.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MemberDescriptorType" />
		<KeyWord name="Tkinter.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.NoneType" />
		<KeyWord name="Tkinter.NotImplementedType" />
		<KeyWord name="Tkinter.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TclError" />
		<KeyWord name="Tkinter.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TracebackType" />
		<KeyWord name="Tkinter.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.image_names" />
		<KeyWord name="Tkinter.image_types" />
		<KeyWord name="Tkinter.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="Tkinter.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="Traceback" func="yes">
			<Overload retVal="" descr="Function of inspect.Traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="True" />
		<KeyWord name="TupleType" func="yes">
			<Overload retVal="" descr="Function of FileDialog.TupleType">
			</Overload>
		</KeyWord>
		<KeyWord name="Turtle" func="yes">
			<Overload retVal="" descr="Function of turtle.Turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="TurtleScreen" func="yes">
			<Overload retVal="" descr="Function of turtle.TurtleScreen">
			</Overload>
		</KeyWord>
		<KeyWord name="TypeError" func="yes">
			<Overload retVal="" descr="Inappropriate argument type.">
			</Overload>
		</KeyWord>
		<KeyWord name="TypeType" func="yes">
			<Overload retVal="" descr="Function of tkSimpleDialog.TypeType">
			</Overload>
		</KeyWord>
		<KeyWord name="UCD" func="yes">
			<Overload retVal="" descr="Function of unicodedata.UCD">
			</Overload>
		</KeyWord>
		<KeyWord name="UUID" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="UnboundLocalError" func="yes">
			<Overload retVal="" descr="Local name referenced but not bound to a value.">
			</Overload>
		</KeyWord>
		<KeyWord name="Underflow" func="yes">
			<Overload retVal="" descr="Function of decimal.Underflow">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeDecodeError" func="yes">
			<Overload retVal="" descr="Unicode decoding error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeEncodeError" func="yes">
			<Overload retVal="" descr="Unicode encoding error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeError" func="yes">
			<Overload retVal="" descr="Unicode related error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeTranslateError" func="yes">
			<Overload retVal="" descr="Unicode translation error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeType" func="yes">
			<Overload retVal="" descr="Function of Dialog.UnicodeType">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about Unicode related problems, mostly&#10;related to conversion problems.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnixBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.UnixBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="Unpickler" func="yes">
			<Overload retVal="" descr="Function of shelve">
			</Overload>
		</KeyWord>
		<KeyWord name="UserDict" func="yes">
			<Overload retVal="" descr="A more or less complete user-defined wrapper around dictionary objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="UserDict.DictMixin" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="UserDict.IterableUserDict" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="UserDict.UserDict" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="UserList" func="yes">
			<Overload retVal="" descr="A more or less complete user-defined wrapper around list objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="UserList.UserList" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="UserString" func="yes">
			<Overload retVal="" descr="A user-defined wrapper around string objects&#10;&#10;Note: string objects have grown methods in Python 1.6&#10;This module requires Python 1.6 or later.">
			</Overload>
		</KeyWord>
		<KeyWord name="UserString.MutableString" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="UserString.UserString" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="UserWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings generated by user code.">
			</Overload>
		</KeyWord>
		<KeyWord name="UuidCreate" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="Value" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ValueError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="Vec2D" func="yes">
			<Overload retVal="" descr="Function of turtle.Vec2D">
			</Overload>
		</KeyWord>
		<KeyWord name="WINFUNCTYPE" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Warning" func="yes">
			<Overload retVal="" descr="Base class for warning categories.">
			</Overload>
		</KeyWord>
		<KeyWord name="WeakSet" func="yes">
			<Overload retVal="" descr="Function of weakref.WeakSet">
			</Overload>
		</KeyWord>
		<KeyWord name="WichmannHill" func="yes">
			<Overload retVal="" descr="Function of random.WichmannHill">
			</Overload>
		</KeyWord>
		<KeyWord name="WinError" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="WindowsDefault" func="yes">
			<Overload retVal="" descr="Function of webbrowser.WindowsDefault">
			</Overload>
		</KeyWord>
		<KeyWord name="WindowsError" func="yes">
			<Overload retVal="" descr="MS-Windows OS system call failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="ZeroDivisionError" func="yes">
			<Overload retVal="" descr="Second argument to a division or modulo operation was zero.">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipFile" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipInfo" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="a2b_qp" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="abc" func="yes">
			<Overload retVal="" descr="Abstract Base Classes (ABCs) according to PEP 3119.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABCMeta" func="yes">
			<Overload retVal="" descr="Metaclass for defining Abstract Base Classes (ABCs).&#10;&#10;Use this metaclass to create an ABC.  An ABC can be subclassed&#10;directly, and then acts as a mix-in class.  You can also register&#10;unrelated concrete classes (even built-in classes) and unrelated&#10;ABCs as 'virtual subclasses' -- these and their descendants will&#10;be considered subclasses of the registering ABC by the built-in&#10;issubclass() function, but the registering ABC won't show up in&#10;their MRO (Method Resolution Order) nor will method&#10;implementations defined by the registering ABC be callable (not&#10;even via super()).">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABCMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABCMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="abc.WeakSet" />
		<KeyWord name="abc.WeakSet.add" />
		<KeyWord name="abc.WeakSet.clear" />
		<KeyWord name="abc.WeakSet.copy" />
		<KeyWord name="abc.WeakSet.difference" />
		<KeyWord name="abc.WeakSet.difference_update" />
		<KeyWord name="abc.WeakSet.discard" />
		<KeyWord name="abc.WeakSet.intersection" />
		<KeyWord name="abc.WeakSet.intersection_update" />
		<KeyWord name="abc.WeakSet.isdisjoint" />
		<KeyWord name="abc.WeakSet.issubset" />
		<KeyWord name="abc.WeakSet.issuperset" />
		<KeyWord name="abc.WeakSet.pop" />
		<KeyWord name="abc.WeakSet.remove" />
		<KeyWord name="abc.WeakSet.symmetric_difference" />
		<KeyWord name="abc.WeakSet.symmetric_difference_update" />
		<KeyWord name="abc.WeakSet.union" />
		<KeyWord name="abc.WeakSet.update" />
		<KeyWord name="abc.abstractmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract methods.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract methods are overridden.&#10;The abstract methods can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C:&#10;        __metaclass__ = ABCMeta&#10;        @abstractmethod&#10;        def my_abstract_method(self, ...):&#10;            ...">
				<Param name="funcobj" />
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract properties.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract properties are overridden.&#10;The abstract properties can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C:&#10;        __metaclass__ = ABCMeta&#10;        @abstractproperty&#10;        def my_abstract_property(self):&#10;            ...&#10;&#10;This defines a read-only property; you can also define a read-write&#10;abstract property using the 'long' form of property declaration:&#10;&#10;    class C:&#10;        __metaclass__ = ABCMeta&#10;        def getx(self): ...&#10;        def setx(self, value): ...&#10;        x = abstractproperty(getx, setx)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.deleter" func="yes">
			<Overload retVal="" descr="Descriptor to change the deleter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.fdel" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.fget" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.fset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.getter" func="yes">
			<Overload retVal="" descr="Descriptor to change the getter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.setter" func="yes">
			<Overload retVal="" descr="Descriptor to change the setter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="abort" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="abs" func="yes">
			<Overload retVal="" descr="abs(number) -&gt; number&#10;&#10;Return the absolute value of the argument.">
			</Overload>
		</KeyWord>
		<KeyWord name="abspath" func="yes">
			<Overload retVal="" descr="Function of os2emxpath">
			</Overload>
		</KeyWord>
		<KeyWord name="abstractmethod" func="yes">
			<Overload retVal="" descr="Function of numbers">
			</Overload>
		</KeyWord>
		<KeyWord name="abstractproperty" func="yes">
			<Overload retVal="" descr="Function of numbers.abstractproperty">
			</Overload>
		</KeyWord>
		<KeyWord name="accept" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="access" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="acos" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="acosh" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="acquire" func="yes">
			<Overload retVal="" descr="Function of logging.NullHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="activeCount" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="active_children" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="active_count" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="adapt" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="add" func="yes">
			<Overload retVal="" descr="Add an element to a set.&#10;&#10;This has no effect if the element is already present.">
			</Overload>
		</KeyWord>
		<KeyWord name="addCleanup" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="addError" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addExpectedFailure" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addFailure" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addFilter" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="addHandler" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="addLevelName" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="addSkip" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addSuccess" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addTest" func="yes">
			<Overload retVal="" descr="Function of unittest.TestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="addTests" func="yes">
			<Overload retVal="" descr="Function of unittest.TestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="addUnexpectedSuccess" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="add_argument" func="yes">
			<Overload retVal="" descr="Function of argparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_argument_group" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_arguments" func="yes">
			<Overload retVal="" descr="Function of argparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_callers" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="add_data" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="add_extension" func="yes">
			<Overload retVal="" descr="Function of copy_reg">
			</Overload>
		</KeyWord>
		<KeyWord name="add_func_stats" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="add_mutually_exclusive_group" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_stream" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="add_subparsers" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_tables" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="add_text" func="yes">
			<Overload retVal="" descr="Function of argparse.RawDescriptionHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_type" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="add_usage" func="yes">
			<Overload retVal="" descr="Function of argparse.RawDescriptionHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="addcomponent" func="yes">
			<Overload retVal="" descr="Function of turtle.Shape">
			</Overload>
		</KeyWord>
		<KeyWord name="addfile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="addpackage" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="addressof" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="addshape" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="addsitedir" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="addsitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="addusersitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="adjusted" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="after" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="after_cancel" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="after_idle" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc" func="yes">
			<Overload retVal="" descr="Stuff to parse AIFF-C and AIFF files.&#10;&#10;Unless explicitly stated otherwise, the description below is true&#10;both for AIFF-C files and AIFF files.&#10;&#10;An AIFF-C file has the following structure.&#10;&#10;  +-----------------+&#10;  | FORM            |&#10;  +-----------------+&#10;  | &lt;size&gt;          |&#10;  +----+------------+&#10;  |    | AIFC       |&#10;  |    +------------+&#10;  |    | &lt;chunks&gt;   |&#10;  |    |    .       |&#10;  |    |    .       |&#10;  |    |    .       |&#10;  +----+------------+&#10;&#10;An AIFF file has the string &quot;AIFF&quot; instead of &quot;AIFC&quot;.&#10;&#10;A chunk consists of an identifier (4 bytes) followed by a size (4 bytes,&#10;big endian order), followed by the data.  The size field does not include&#10;the size of the 8 byte header.&#10;&#10;The following chunk types are recognized.&#10;&#10;  FVER&#10;      &lt;version number of AIFF-C defining document&gt; (AIFF-C only).&#10;  MARK&#10;      &lt;# of markers&gt; (2 bytes)&#10;      list of markers:&#10;          &lt;marker ID&gt; (2 bytes, must be &gt; 0)&#10;          &lt;position&gt; (4 bytes)&#10;          &lt;marker name&gt; (&quot;pstring&quot;)&#10;  COMM&#10;      &lt;# of channels&gt; (2 bytes)&#10;      &lt;# of sound frames&gt; (4 bytes)&#10;      &lt;size of the samples&gt; (2 bytes)&#10;      &lt;sampling frequency&gt; (10 bytes, IEEE 80-bit extended&#10;          floating point)&#10;      in AIFF-C files only:&#10;      &lt;compression type&gt; (4 bytes)&#10;      &lt;human-readable version of compression type&gt; (&quot;pstring&quot;)&#10;  SSND&#10;      &lt;offset&gt; (4 bytes, not used by this program)&#10;      &lt;blocksize&gt; (4 bytes, not used by this program)&#10;      &lt;sound data&gt;&#10;&#10;A pstring consists of 1 byte length, a string of characters, and 0 or 1&#10;byte pad to make the total length even.&#10;&#10;Usage.&#10;&#10;Reading AIFF files:&#10;  f = aifc.open(file, 'r')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods read(), seek(), and close().&#10;In some types of audio files, if the setpos() method is not used,&#10;the seek() method is not necessary.&#10;&#10;This returns an instance of a class with the following public methods:&#10;  getnchannels()  -- returns number of audio channels (1 for&#10;             mono, 2 for stereo)&#10;  getsampwidth()  -- returns sample width in bytes&#10;  getframerate()  -- returns sampling frequency&#10;  getnframes()    -- returns number of audio frames&#10;  getcomptype()   -- returns compression type ('NONE' for AIFF files)&#10;  getcompname()   -- returns human-readable version of&#10;             compression type ('not compressed' for AIFF files)&#10;  getparams() -- returns a tuple consisting of all of the&#10;             above in the above order&#10;  getmarkers()    -- get the list of marks in the audio file or None&#10;             if there are no marks&#10;  getmark(id) -- get mark with the specified id (raises an error&#10;             if the mark does not exist)&#10;  readframes(n)   -- returns at most n frames of audio&#10;  rewind()    -- rewind to the beginning of the audio stream&#10;  setpos(pos) -- seek to the specified position&#10;  tell()      -- return the current position&#10;  close()     -- close the instance (make it unusable)&#10;The position returned by tell(), the position given to setpos() and&#10;the position of marks are all compatible and have nothing to do with&#10;the actual position in the file.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;Writing AIFF files:&#10;  f = aifc.open(file, 'w')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods write(), tell(), seek(), and&#10;close().&#10;&#10;This returns an instance of a class with the following public methods:&#10;  aiff()      -- create an AIFF file (AIFF-C default)&#10;  aifc()      -- create an AIFF-C file&#10;  setnchannels(n) -- set the number of channels&#10;  setsampwidth(n) -- set the sample width&#10;  setframerate(n) -- set the frame rate&#10;  setnframes(n)   -- set the number of frames&#10;  setcomptype(type, name)&#10;          -- set the compression type and the&#10;             human-readable compression type&#10;  setparams(tuple)&#10;          -- set all parameters at once&#10;  setmark(id, pos, name)&#10;          -- add specified mark to the list of marks&#10;  tell()      -- return current position in output file (useful&#10;             in combination with setmark())&#10;  writeframesraw(data)&#10;          -- write audio frames without pathing up the&#10;             file header&#10;  writeframes(data)&#10;          -- write audio frames and patch up the file header&#10;  close()     -- patch up the file header and close the&#10;             output file&#10;You should set the parameters before the first writeframesraw or&#10;writeframes.  The total number of frames does not need to be set,&#10;but when it is set to the correct value, the header does not have to&#10;be patched up.&#10;It is best to first set all parameters, perhaps possibly the&#10;compression type, and then write audio frames using writeframesraw.&#10;When all frames have been written, either call writeframes('') or&#10;close() to patch up the sizes in the header.&#10;Marks can be added anytime.  If there are any marks, you must call&#10;close() after all frames have been written.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;When a file is opened with the extension '.aiff', an AIFF file is&#10;written, otherwise an AIFF-C file is written.  This default can be&#10;changed by calling aiff() or aifc() before the first writeframes or&#10;writeframesraw.">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Aifc_read" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Aifc_write" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Chunk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Error" />
		<KeyWord name="aifc.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.openfp" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="aliasmbcs" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="alignment" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="all" func="yes">
			<Overload retVal="" descr="all(iterable) -&gt; bool&#10;&#10;Return True if bool(x) is True for all values x in the iterable.&#10;If the iterable is empty, return True.">
			</Overload>
		</KeyWord>
		<KeyWord name="allmethods" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="allocate_lock" func="yes">
			<Overload retVal="" descr="Function of dummy_thread">
			</Overload>
		</KeyWord>
		<KeyWord name="allow_connection_pickling" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="and" />
		<KeyWord name="annotate" func="yes">
			<Overload retVal="" descr="Function of dircache">
			</Overload>
		</KeyWord>
		<KeyWord name="antigravity" />
		<KeyWord name="any" func="yes">
			<Overload retVal="" descr="any(iterable) -&gt; bool&#10;&#10;Return True if bool(x) is True for any x in the iterable.&#10;If the iterable is empty, return False.">
			</Overload>
		</KeyWord>
		<KeyWord name="anydbm" func="yes">
			<Overload retVal="" descr="Generic interface to all dbm clones.&#10;&#10;Instead of&#10;&#10;        import dbm&#10;        d = dbm.open(file, 'w', 0666)&#10;&#10;use&#10;&#10;        import anydbm&#10;        d = anydbm.open(file, 'w')&#10;&#10;The returned object is a dbhash, gdbm, dbm or dumbdbm object,&#10;dependent on the type of database being opened (determined by whichdb&#10;module) in the case of an existing dbm. If the dbm does not exist and&#10;the create or new flag ('c' or 'n') was specified, the dbm type will&#10;be determined by the availability of the modules (tested in the above&#10;order).&#10;&#10;It has the following interface (key and data are strings):&#10;&#10;        d[key] = data   # store data at key (may override data at&#10;                        # existing key)&#10;        data = d[key]   # retrieve data at key (raise KeyError if no&#10;                        # such key)&#10;        del d[key]      # delete data stored at key (raises KeyError&#10;                        # if no such key)&#10;        flag = key in d   # true if the key exists&#10;        list = d.keys() # return a list of all existing keys (slow!)&#10;&#10;Future versions may change the order in which implementations are&#10;tested for existence, and add interfaces to other dbm-like&#10;implementations.">
			</Overload>
		</KeyWord>
		<KeyWord name="anydbm.error" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="anydbm.open" func="yes">
			<Overload retVal="" descr="Open or create database at path given by *file*.&#10;&#10;Optional argument *flag* can be 'r' (default) for read-only access, 'w'&#10;for read-write access of an existing database, 'c' for read-write access&#10;to a new or existing database, and 'n' for read-write access to a new&#10;database.&#10;&#10;Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it&#10;only if it doesn't exist; and 'n' always creates a new database.">
				<Param name="file" />
				<Param name="[flag=r" />
				<Param name="[mode=438]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="appendleft" func="yes">
			<Overload retVal="" descr="Function of pydoc.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="apply" func="yes">
			<Overload retVal="" descr="apply(object[, args[, kwargs]]) -&gt; value&#10;&#10;Call a callable object with positional arguments taken from the tuple args,&#10;and keyword arguments taken from the optional dictionary kwargs.&#10;Note that classes are callable, as are instances with a __call__() method.&#10;&#10;Deprecated since release 2.3. Instead, use the extended call syntax:&#10;    function(*args, **keywords).">
			</Overload>
		</KeyWord>
		<KeyWord name="apropos" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="architecture" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse" func="yes">
			<Overload retVal="" descr="Command-line parsing library&#10;&#10;This module is an optparse-inspired command-line parsing library that:&#10;&#10;    - handles both optional and positional arguments&#10;    - produces highly informative usage messages&#10;    - supports parsers that dispatch to sub-parsers&#10;&#10;The following is a simple usage example that sums integers from the&#10;command-line and writes the result to a file::&#10;&#10;    parser = argparse.ArgumentParser(&#10;        description='sum the integers at the command line')&#10;    parser.add_argument(&#10;        'integers', metavar='int', nargs='+', type=int,&#10;        help='an integer to be summed')&#10;    parser.add_argument(&#10;        '--log', default=sys.stdout, type=argparse.FileType('w'),&#10;        help='the file where the sum should be written')&#10;    args = parser.parse_args()&#10;    args.log.write('%s' % sum(args.integers))&#10;    args.log.close()&#10;&#10;The module contains the following public classes:&#10;&#10;    - ArgumentParser -- The main entry point for command-line parsing. As the&#10;        example above shows, the add_argument() method is used to populate&#10;        the parser with actions for optional and positional arguments. Then&#10;        the parse_args() method is invoked to convert the args at the&#10;        command-line into an object with attributes.&#10;&#10;    - ArgumentError -- The exception raised by ArgumentParser objects when&#10;        there are errors with the parser's actions. Errors raised while&#10;        parsing the command-line are caught by ArgumentParser and emitted&#10;        as command-line messages.&#10;&#10;    - FileType -- A factory for defining types of files to be created. As the&#10;        example above shows, instances of FileType are typically passed as&#10;        the type= argument of add_argument() calls.&#10;&#10;    - Action -- The base class for parser actions. Typically actions are&#10;        selected by passing strings like 'store_true' or 'append_const' to&#10;        the action= argument of add_argument(). However, for greater&#10;        customization of ArgumentParser actions, subclasses of Action may&#10;        be defined and passed as the action= argument.&#10;&#10;    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,&#10;        ArgumentDefaultsHelpFormatter -- Formatter classes which&#10;        may be passed as the formatter_class= argument to the&#10;        ArgumentParser constructor. HelpFormatter is the default,&#10;        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser&#10;        not to change the formatting for help text, and&#10;        ArgumentDefaultsHelpFormatter adds information about argument defaults&#10;        to the help.&#10;&#10;All other classes in this module are considered implementation details.&#10;(Also note that HelpFormatter and RawDescriptionHelpFormatter are only&#10;considered public as object names -- the API of the formatter objects is&#10;still considered an implementation detail.)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.Action" func="yes">
			<Overload retVal="" descr="Information about how to convert command line strings to Python objects.&#10;&#10;Action objects are used by an ArgumentParser to represent the information&#10;needed to parse a single argument from one or more strings from the&#10;command line. The keyword arguments to the Action constructor are also&#10;all attributes of Action instances.&#10;&#10;Keyword Arguments:&#10;&#10;    - option_strings -- A list of command-line option strings which&#10;        should be associated with this action.&#10;&#10;    - dest -- The name of the attribute to hold the created object(s)&#10;&#10;    - nargs -- The number of command-line arguments that should be&#10;        consumed. By default, one argument will be consumed and a single&#10;        value will be produced.  Other values include:&#10;            - N (an integer) consumes N arguments (and produces a list)&#10;            - '?' consumes zero or one arguments&#10;            - '*' consumes zero or more arguments (and produces a list)&#10;            - '+' consumes one or more arguments (and produces a list)&#10;        Note that the difference between the default and nargs=1 is that&#10;        with the default, a single value will be produced, while with&#10;        nargs=1, a list containing a single value will be produced.&#10;&#10;    - const -- The value to be produced if the option is specified and the&#10;        option uses an action that takes no values.&#10;&#10;    - default -- The value to be produced if the option is not specified.&#10;&#10;    - type -- A callable that accepts a single string argument, and&#10;        returns the converted value.  The standard Python types str, int,&#10;        float, and complex are useful examples of such callables.  If None,&#10;        str is used.&#10;&#10;    - choices -- A container of values that should be allowed. If not None,&#10;        after a command-line argument has been converted to the appropriate&#10;        type, an exception will be raised if it is not a member of this&#10;        collection.&#10;&#10;    - required -- True if the action must always be specified at the&#10;        command line. This is only meaningful for optional command-line&#10;        arguments.&#10;&#10;    - help -- The help string describing the argument.&#10;&#10;    - metavar -- The name to be used for the option's argument with the&#10;        help string. If None, the 'dest' value will be used as the name.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which adds default values to argument help.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_argument" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_arguments" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_text" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.end_section" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.format_help" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.start_section" />
		<KeyWord name="argparse.ArgumentError" func="yes">
			<Overload retVal="" descr="An error from creating or using an argument (optional or positional).&#10;&#10;The string value of this exception is the message, augmented with&#10;information about the argument that caused it.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser" func="yes">
			<Overload retVal="" descr="Object for parsing command line strings into Python objects.&#10;&#10;Keyword Arguments:&#10;    - prog -- The name of the program (default: sys.argv[0])&#10;    - usage -- A usage message (default: auto-generated from arguments)&#10;    - description -- A description of what the program does&#10;    - epilog -- Text following the argument descriptions&#10;    - parents -- Parsers whose arguments should be copied into this one&#10;    - formatter_class -- HelpFormatter class for printing help messages&#10;    - prefix_chars -- Characters that prefix optional arguments&#10;    - fromfile_prefix_chars -- Characters that prefix files containing&#10;        additional arguments&#10;    - argument_default -- The default value for all arguments&#10;    - conflict_handler -- String indicating how to handle conflicts&#10;    - add_help -- Add a -h/-help option">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_argument" func="yes">
			<Overload retVal="" descr="add_argument(dest, ..., name=value, ...)&#10;add_argument(option_string, option_string, ..., name=value, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_argument_group" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_mutually_exclusive_group" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_subparsers" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.convert_arg_line_to_args" />
		<KeyWord name="argparse.ArgumentParser.error" func="yes">
			<Overload retVal="" descr="error(message: string)&#10;&#10;Prints a usage message incorporating the message to stderr and&#10;exits.&#10;&#10;If you override this in a subclass, it should not return -- it&#10;should either exit or raise an exception.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.exit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[status=0" />
				<Param name="[message=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.format_help" />
		<KeyWord name="argparse.ArgumentParser.format_usage" />
		<KeyWord name="argparse.ArgumentParser.format_version" />
		<KeyWord name="argparse.ArgumentParser.get_default" />
		<KeyWord name="argparse.ArgumentParser.parse_args" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[namespace=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.parse_known_args" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[namespace=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.print_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.print_usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.print_version" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.register" />
		<KeyWord name="argparse.ArgumentParser.set_defaults" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentTypeError" func="yes">
			<Overload retVal="" descr="An error from trying to convert a command line string to a type.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentTypeError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentTypeError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.FileType" func="yes">
			<Overload retVal="" descr="Factory for creating file object types&#10;&#10;Instances of FileType are typically passed as type= arguments to the&#10;ArgumentParser add_argument() method.&#10;&#10;Keyword Arguments:&#10;    - mode -- A string indicating how the file is to be opened. Accepts the&#10;        same values as the builtin open() function.&#10;    - bufsize -- The file's desired buffer size. Accepts the same values as&#10;        the builtin open() function.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.HelpFormatter" func="yes">
			<Overload retVal="" descr="Formatter for generating usage messages and argument help strings.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.HelpFormatter.add_argument" />
		<KeyWord name="argparse.HelpFormatter.add_arguments" />
		<KeyWord name="argparse.HelpFormatter.add_text" />
		<KeyWord name="argparse.HelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.HelpFormatter.end_section" />
		<KeyWord name="argparse.HelpFormatter.format_help" />
		<KeyWord name="argparse.HelpFormatter.start_section" />
		<KeyWord name="argparse.Namespace" func="yes">
			<Overload retVal="" descr="Simple object for storing attributes.&#10;&#10;Implements equality by attribute names and values, and provides a simple&#10;string representation.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ONE_OR_MORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.OPTIONAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.PARSER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.REMAINDER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawDescriptionHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which retains any formatting in descriptions.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_argument" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_arguments" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_text" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawDescriptionHelpFormatter.end_section" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.format_help" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.start_section" />
		<KeyWord name="argparse.RawTextHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which retains formatting of all help text.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawTextHelpFormatter.add_argument" />
		<KeyWord name="argparse.RawTextHelpFormatter.add_arguments" />
		<KeyWord name="argparse.RawTextHelpFormatter.add_text" />
		<KeyWord name="argparse.RawTextHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawTextHelpFormatter.end_section" />
		<KeyWord name="argparse.RawTextHelpFormatter.format_help" />
		<KeyWord name="argparse.RawTextHelpFormatter.start_section" />
		<KeyWord name="argparse.SUPPRESS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ZERO_OR_MORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="array" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="as" />
		<KeyWord name="as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="as_tuple" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="ascii_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="ascii_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="asin" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="asinh" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="askcolor" func="yes">
			<Overload retVal="" descr="Function of tkColorChooser">
			</Overload>
		</KeyWord>
		<KeyWord name="askdirectory" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askfloat" func="yes">
			<Overload retVal="" descr="Function of tkSimpleDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askinteger" func="yes">
			<Overload retVal="" descr="Function of tkSimpleDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askokcancel" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="askopenfile" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askopenfilename" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askopenfilenames" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askopenfiles" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askquestion" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="askretrycancel" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="asksaveasfile" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="asksaveasfilename" func="yes">
			<Overload retVal="" descr="Function of tkFileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askstring" func="yes">
			<Overload retVal="" descr="Function of tkSimpleDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="askyesno" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="askyesnocancel" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="assert" />
		<KeyWord name="assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertDictEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertEquals" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertFalse" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertGreater" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIn" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIs" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsInstance" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsNone" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsNot" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsNotNone" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertItemsEqual" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertLess" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertLessEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertListEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotEquals" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotIn" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRaises" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertSequenceEqual" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertSetEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertTrue" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertTupleEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="ast" func="yes">
			<Overload retVal="" descr="ast&#10;~~~&#10;&#10;The `ast` module helps Python applications to process trees of the Python&#10;abstract syntax grammar.  The abstract syntax itself might change with&#10;each Python release; this module helps to find out programmatically what&#10;the current grammar looks like and allows modifications of it.&#10;&#10;An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as&#10;a flag to the `compile()` builtin function or by using the `parse()`&#10;function from this module.  The result will be a tree of objects whose&#10;classes all inherit from `ast.AST`.&#10;&#10;A modified abstract syntax tree can be compiled into a Python code object&#10;using the built-in `compile()` function.&#10;&#10;Additionally various helper functions are provided that make working with&#10;the trees simpler.  The main intention of the helper functions and this&#10;module in general is to provide an easy to use interface for libraries&#10;that work tightly with the python syntax (template engines for example).&#10;&#10;&#10;:copyright: Copyright 2008 by Armin Ronacher.&#10;:license: Python License.">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.AST" />
		<KeyWord name="ast.Add" />
		<KeyWord name="ast.And" />
		<KeyWord name="ast.Assert" />
		<KeyWord name="ast.Assign" />
		<KeyWord name="ast.Attribute" />
		<KeyWord name="ast.AugAssign" />
		<KeyWord name="ast.AugLoad" />
		<KeyWord name="ast.AugStore" />
		<KeyWord name="ast.BinOp" />
		<KeyWord name="ast.BitAnd" />
		<KeyWord name="ast.BitOr" />
		<KeyWord name="ast.BitXor" />
		<KeyWord name="ast.BoolOp" />
		<KeyWord name="ast.Break" />
		<KeyWord name="ast.Call" />
		<KeyWord name="ast.ClassDef" />
		<KeyWord name="ast.Compare" />
		<KeyWord name="ast.Continue" />
		<KeyWord name="ast.Del" />
		<KeyWord name="ast.Delete" />
		<KeyWord name="ast.Dict" />
		<KeyWord name="ast.DictComp" />
		<KeyWord name="ast.Div" />
		<KeyWord name="ast.Ellipsis" />
		<KeyWord name="ast.Eq" />
		<KeyWord name="ast.ExceptHandler" />
		<KeyWord name="ast.Exec" />
		<KeyWord name="ast.Expr" />
		<KeyWord name="ast.Expression" />
		<KeyWord name="ast.ExtSlice" />
		<KeyWord name="ast.FloorDiv" />
		<KeyWord name="ast.For" />
		<KeyWord name="ast.FunctionDef" />
		<KeyWord name="ast.GeneratorExp" />
		<KeyWord name="ast.Global" />
		<KeyWord name="ast.Gt" />
		<KeyWord name="ast.GtE" />
		<KeyWord name="ast.If" />
		<KeyWord name="ast.IfExp" />
		<KeyWord name="ast.Import" />
		<KeyWord name="ast.ImportFrom" />
		<KeyWord name="ast.In" />
		<KeyWord name="ast.Index" />
		<KeyWord name="ast.Interactive" />
		<KeyWord name="ast.Invert" />
		<KeyWord name="ast.Is" />
		<KeyWord name="ast.IsNot" />
		<KeyWord name="ast.LShift" />
		<KeyWord name="ast.Lambda" />
		<KeyWord name="ast.List" />
		<KeyWord name="ast.ListComp" />
		<KeyWord name="ast.Load" />
		<KeyWord name="ast.Lt" />
		<KeyWord name="ast.LtE" />
		<KeyWord name="ast.Mod" />
		<KeyWord name="ast.Module" />
		<KeyWord name="ast.Mult" />
		<KeyWord name="ast.Name" />
		<KeyWord name="ast.NodeTransformer" func="yes">
			<Overload retVal="" descr="A :class:`NodeVisitor` subclass that walks the abstract syntax tree and&#10;allows modification of nodes.&#10;&#10;The `NodeTransformer` will walk the AST and use the return value of the&#10;visitor methods to replace or remove the old node.  If the return value of&#10;the visitor method is ``None``, the node will be removed from its location,&#10;otherwise it is replaced with the return value.  The return value may be the&#10;original node in which case no replacement takes place.&#10;&#10;Here is an example transformer that rewrites all occurrences of name lookups&#10;(``foo``) to ``data['foo']``::&#10;&#10;   class RewriteName(NodeTransformer):&#10;&#10;       def visit_Name(self, node):&#10;           return copy_location(Subscript(&#10;               value=Name(id='data', ctx=Load()),&#10;               slice=Index(value=Str(s=node.id)),&#10;               ctx=node.ctx&#10;           ), node)&#10;&#10;Keep in mind that if the node you're operating on has child nodes you must&#10;either transform the child nodes yourself or call the :meth:`generic_visit`&#10;method for the node first.&#10;&#10;For nodes that were part of a collection of statements (that applies to all&#10;statement nodes), the visitor may also return a list of nodes rather than&#10;just a single node.&#10;&#10;Usually you use the transformer like this::&#10;&#10;   node = YourTransformer().visit(node)">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeTransformer.generic_visit" />
		<KeyWord name="ast.NodeTransformer.visit" func="yes">
			<Overload retVal="" descr="Visit a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeVisitor" func="yes">
			<Overload retVal="" descr="A node visitor base class that walks the abstract syntax tree and calls a&#10;visitor function for every node found.  This function may return a value&#10;which is forwarded by the `visit` method.&#10;&#10;This class is meant to be subclassed, with the subclass adding visitor&#10;methods.&#10;&#10;Per default the visitor functions for the nodes are ``'visit_'`` +&#10;class name of the node.  So a `TryFinally` node visit function would&#10;be `visit_TryFinally`.  This behavior can be changed by overriding&#10;the `visit` method.  If no visitor function exists for a node&#10;(return value `None`) the `generic_visit` visitor is used instead.&#10;&#10;Don't use the `NodeVisitor` if you want to apply changes to nodes during&#10;traversing.  For this a special visitor exists (`NodeTransformer`) that&#10;allows modifications.">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeVisitor.generic_visit" func="yes">
			<Overload retVal="" descr="Called if no explicit visitor function exists for a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeVisitor.visit" func="yes">
			<Overload retVal="" descr="Visit a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.Not" />
		<KeyWord name="ast.NotEq" />
		<KeyWord name="ast.NotIn" />
		<KeyWord name="ast.Num" />
		<KeyWord name="ast.Or" />
		<KeyWord name="ast.Param" />
		<KeyWord name="ast.Pass" />
		<KeyWord name="ast.Pow" />
		<KeyWord name="ast.Print" />
		<KeyWord name="ast.PyCF_ONLY_AST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.RShift" />
		<KeyWord name="ast.Raise" />
		<KeyWord name="ast.Repr" />
		<KeyWord name="ast.Return" />
		<KeyWord name="ast.Set" />
		<KeyWord name="ast.SetComp" />
		<KeyWord name="ast.Slice" />
		<KeyWord name="ast.Store" />
		<KeyWord name="ast.Str" />
		<KeyWord name="ast.Sub" />
		<KeyWord name="ast.Subscript" />
		<KeyWord name="ast.Suite" />
		<KeyWord name="ast.TryExcept" />
		<KeyWord name="ast.TryFinally" />
		<KeyWord name="ast.Tuple" />
		<KeyWord name="ast.UAdd" />
		<KeyWord name="ast.USub" />
		<KeyWord name="ast.UnaryOp" />
		<KeyWord name="ast.While" />
		<KeyWord name="ast.With" />
		<KeyWord name="ast.Yield" />
		<KeyWord name="ast.alias" />
		<KeyWord name="ast.arguments" />
		<KeyWord name="ast.boolop" />
		<KeyWord name="ast.cmpop" />
		<KeyWord name="ast.comprehension" />
		<KeyWord name="ast.copy_location" func="yes">
			<Overload retVal="" descr="Copy source location (`lineno` and `col_offset` attributes) from&#10;*old_node* to *new_node* if possible, and return *new_node*.">
				<Param name="new_node" />
				<Param name="old_node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.dump" func="yes">
			<Overload retVal="" descr="Return a formatted dump of the tree in *node*.  This is mainly useful for&#10;debugging purposes.  The returned string will show the names and the values&#10;for fields.  This makes the code impossible to evaluate, so if evaluation is&#10;wanted *annotate_fields* must be set to False.  Attributes such as line&#10;numbers and column offsets are not dumped by default.  If this is wanted,&#10;*include_attributes* can be set to True.">
				<Param name="node" />
				<Param name="[annotate_fields=True" />
				<Param name="[include_attributes=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.excepthandler" />
		<KeyWord name="ast.expr" />
		<KeyWord name="ast.expr_context" />
		<KeyWord name="ast.fix_missing_locations" func="yes">
			<Overload retVal="" descr="When you compile a node tree with compile(), the compiler expects lineno and&#10;col_offset attributes for every node that supports them.  This is rather&#10;tedious to fill in for generated nodes, so this helper adds these attributes&#10;recursively where not already set, by setting them to the values of the&#10;parent node.  It works recursively starting at *node*.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.get_docstring" func="yes">
			<Overload retVal="" descr="Return the docstring for the given node or None if no docstring can&#10;be found.  If the node provided does not have docstrings a TypeError&#10;will be raised.">
				<Param name="node" />
				<Param name="[clean=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.increment_lineno" func="yes">
			<Overload retVal="" descr='Increment the line number of each node in the tree starting at *node* by *n*.&#10;This is useful to "move code" to a different location in a file.'>
				<Param name="node" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.iter_child_nodes" func="yes">
			<Overload retVal="" descr="Yield all direct child nodes of *node*, that is, all fields that are nodes&#10;and all items of fields that are lists of nodes.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.iter_fields" func="yes">
			<Overload retVal="" descr="Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``&#10;that is present on *node*.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.keyword" />
		<KeyWord name="ast.literal_eval" func="yes">
			<Overload retVal="" descr="Safely evaluate an expression node or a string containing a Python&#10;expression.  The string or node provided may only consist of the following&#10;Python literal structures: strings, numbers, tuples, lists, dicts, booleans,&#10;and None.">
				<Param name="node_or_string" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.mod" />
		<KeyWord name="ast.operator" />
		<KeyWord name="ast.parse" func="yes">
			<Overload retVal="" descr="Parse the source into an AST node.&#10;Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).">
				<Param name="source" />
				<Param name="[filename=<unknown>" />
				<Param name="[mode=exec]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.slice" />
		<KeyWord name="ast.stmt" />
		<KeyWord name="ast.unaryop" />
		<KeyWord name="ast.walk" func="yes">
			<Overload retVal="" descr="Recursively yield all descendant nodes in the tree starting at *node*&#10;(including *node* itself), in no specified order.  This is useful if you&#10;only want to modify nodes in place and don't care about the context.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="astimezone" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat" func="yes">
			<Overload retVal="" descr="A class supporting chat-style (command/response) protocols.&#10;&#10;This class adds support for 'chat' style protocols - where one side&#10;sends a 'command', and the other sends a response (examples would be&#10;the common internet protocols - smtp, nntp, ftp, etc..).&#10;&#10;The handle_read() method looks at the input stream for the current&#10;'terminator' (usually '\r\n' for single-line responses, '\r\n.\r\n'&#10;for multi-line output), calling self.found_terminator() on its&#10;receipt.&#10;&#10;for example:&#10;Say you build an async nntp client using this class.  At the start&#10;of the connection, you'll have self.terminator set to '\r\n', in&#10;order to process the single-line greeting.  Just before issuing a&#10;'LIST' command you'll set it to '\r\n.\r\n'.  The output of the LIST&#10;command will be accumulated (using your own 'collect_incoming_data'&#10;method) up to the terminator, and then control will be returned to&#10;you - by calling your self.found_terminator() method.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.catch_warnings" func="yes">
			<Overload retVal="" descr="A context manager that copies and restores the warnings filter upon&#10;exiting the context.&#10;&#10;The 'record' argument specifies whether warnings should be captured by a&#10;custom implementation of warnings.showwarning() and be appended to a list&#10;returned by the context manager. Otherwise None is returned by the context&#10;manager. The objects appended to the list are arguments whose attributes&#10;mirror the arguments to showwarning().&#10;&#10;The 'module' argument is to specify an alternative module to the module&#10;named 'warnings' and imported under that name. This argument is only useful&#10;when testing the warnings module itself.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;Build an ordered collection with optimized access from its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.fifo" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.filterwarnings" func="yes">
			<Overload retVal="" descr="Insert an entry into the list of warnings filters (at the front).&#10;&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'message' -- a regex that the warning message must match&#10;'category' -- a class that the warning must be a subclass of&#10;'module' -- a regex that the module name must match&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[message" />
				<Param name="[category=<type 'exceptions.Warning'>" />
				<Param name="[module" />
				<Param name="[lineno=0" />
				<Param name="[append=0]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.find_prefix_at_end" />
		<KeyWord name="asynchat.simple_producer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore" func="yes">
			<Overload retVal="" descr="Basic infrastructure for asynchronous socket service clients and servers.&#10;&#10;There are only two ways to have a program on a single processor do &quot;more&#10;than one thing at a time&quot;.  Multi-threaded programming is the simplest and&#10;most popular way to do it, but there is another very different technique,&#10;that lets you have nearly all the advantages of multi-threading, without&#10;actually using multiple threads. it's really only practical if your program&#10;is largely I/O bound. If your program is CPU bound, then pre-emptive&#10;scheduled threads are probably what you really need. Network servers are&#10;rarely CPU-bound, however.&#10;&#10;If your operating system supports the select() system call in its I/O&#10;library (and nearly all do), then you can use it to juggle multiple&#10;communication channels at once; doing other work while your I/O is taking&#10;place in the &quot;background.&quot;  Although this strategy can seem strange and&#10;complex, especially at first, it is in many ways easier to understand and&#10;control than multi-threaded programming. The module documented here solves&#10;many of the difficult problems for you, making the task of building&#10;sophisticated high-performance network servers and clients a snap.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EAGAIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EALREADY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EBADF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ECONNABORTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ECONNRESET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EINPROGRESS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EINTR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EINVAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EISCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ENOTCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EPIPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ESHUTDOWN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EWOULDBLOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ExitNow" />
		<KeyWord name="asyncore.ExitNow.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ExitNow.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.close_all" func="yes">
			<Overload retVal="" descr=>
				<Param name="[map=None" />
				<Param name="[ignore_all=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.compact_traceback" />
		<KeyWord name="asyncore.dispatcher" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.errorcode" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.loop" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=30.0" />
				<Param name="[use_poll=False" />
				<Param name="[map=None" />
				<Param name="[count=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.poll" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=0.0" />
				<Param name="[map=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.poll2" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=0.0" />
				<Param name="[map=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.poll3" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=0.0" />
				<Param name="[map=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.read" />
		<KeyWord name="asyncore.readwrite" />
		<KeyWord name="asyncore.write" />
		<KeyWord name="atan" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="atan2" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="atanh" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="atexit" func="yes">
			<Overload retVal="" descr="atexit.py - allow programmer to define multiple exit functions to be executed&#10;upon normal program termination.&#10;&#10;One public function, register, is defined.">
			</Overload>
		</KeyWord>
		<KeyWord name="atexit.register" func="yes">
			<Overload retVal="" descr="register a function to be executed upon normal program termination&#10;&#10;func - function to be called at exit&#10;targs - optional arguments to pass to func&#10;kargs - optional keyword arguments to pass to func&#10;&#10;func is returned to facilitate usage as a decorator.">
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="atof" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="atoi" func="yes">
			<Overload retVal="" descr="Function of stringold">
			</Overload>
		</KeyWord>
		<KeyWord name="atol" func="yes">
			<Overload retVal="" descr="Function of stringold">
			</Overload>
		</KeyWord>
		<KeyWord name="audiodev" func="yes">
			<Overload retVal="" descr="Classes for manipulating audio devices (currently only for Sun and SGI)">
			</Overload>
		</KeyWord>
		<KeyWord name="audiodev.AudioDev" />
		<KeyWord name="audiodev.Play_Audio_sgi" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="audiodev.Play_Audio_sun" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="audiodev.error" />
		<KeyWord name="audiodev.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="audiodev.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="audiodev.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[fn=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="b16decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b16encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b2a_qp" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="b32decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b32encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b64decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b64encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="back" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="backslashreplace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="backward" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="bar" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="base64" func="yes">
			<Overload retVal="" descr="RFC 3548: Base16, Base32, Base64 Data Encodings">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.MAXBINSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.MAXLINESIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b16decode" func="yes">
			<Overload retVal="" descr="Decode a Base16 encoded string.&#10;&#10;s is the string to decode.  Optional casefold is a flag specifying whether&#10;a lowercase alphabet is acceptable as input.  For security purposes, the&#10;default is False.&#10;&#10;The decoded string is returned.  A TypeError is raised if s were&#10;incorrectly padded or if there are non-alphabet characters present in the&#10;string.">
				<Param name="s" />
				<Param name="[casefold=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b16encode" func="yes">
			<Overload retVal="" descr="Encode a string using Base16.&#10;&#10;s is the string to encode.  The encoded string is returned.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b32decode" func="yes">
			<Overload retVal="" descr="Decode a Base32 encoded string.&#10;&#10;s is the string to decode.  Optional casefold is a flag specifying whether&#10;a lowercase alphabet is acceptable as input.  For security purposes, the&#10;default is False.&#10;&#10;RFC 3548 allows for optional mapping of the digit 0 (zero) to the letter O&#10;(oh), and for optional mapping of the digit 1 (one) to either the letter I&#10;(eye) or letter L (el).  The optional argument map01 when not None,&#10;specifies which letter the digit 1 should be mapped to (when map01 is not&#10;None, the digit 0 is always mapped to the letter O).  For security&#10;purposes the default is None, so that 0 and 1 are not allowed in the&#10;input.&#10;&#10;The decoded string is returned.  A TypeError is raised if s were&#10;incorrectly padded or if there are non-alphabet characters present in the&#10;string.">
				<Param name="s" />
				<Param name="[casefold=False" />
				<Param name="[map01=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b32encode" func="yes">
			<Overload retVal="" descr="Encode a string using Base32.&#10;&#10;s is the string to encode.  The encoded string is returned.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b64decode" func="yes">
			<Overload retVal="" descr="Decode a Base64 encoded string.&#10;&#10;s is the string to decode.  Optional altchars must be a string of at least&#10;length 2 (additional characters are ignored) which specifies the&#10;alternative alphabet used instead of the '+' and '/' characters.&#10;&#10;The decoded string is returned.  A TypeError is raised if s were&#10;incorrectly padded or if there are non-alphabet characters present in the&#10;string.">
				<Param name="s" />
				<Param name="[altchars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b64encode" func="yes">
			<Overload retVal="" descr="Encode a string using Base64.&#10;&#10;s is the string to encode.  Optional altchars must be a string of at least&#10;length 2 (additional characters are ignored) which specifies an&#10;alternative alphabet for the '+' and '/' characters.  This allows an&#10;application to e.g. generate url or filesystem safe Base64 strings.&#10;&#10;The encoded string is returned.">
				<Param name="s" />
				<Param name="[altchars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.decode" func="yes">
			<Overload retVal="" descr="Decode a file.">
				<Param name="input" />
				<Param name="output" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.decodestring" func="yes">
			<Overload retVal="" descr="Decode a string.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.encode" func="yes">
			<Overload retVal="" descr="Encode a file.">
				<Param name="input" />
				<Param name="output" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.encodestring" func="yes">
			<Overload retVal="" descr="Encode a string into multiple lines of base-64 data.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.k" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.standard_b64decode" func="yes">
			<Overload retVal="" descr="Decode a string encoded with the standard Base64 alphabet.&#10;&#10;s is the string to decode.  The decoded string is returned.  A TypeError&#10;is raised if the string is incorrectly padded or if there are non-alphabet&#10;characters present in the string.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.standard_b64encode" func="yes">
			<Overload retVal="" descr="Encode a string using the standard Base64 alphabet.&#10;&#10;s is the string to encode.  The encoded string is returned.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.test" func="yes">
			<Overload retVal="" descr="Small test program">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.test1" />
		<KeyWord name="base64.urlsafe_b64decode" func="yes">
			<Overload retVal="" descr="Decode a string encoded with the standard Base64 alphabet.&#10;&#10;s is the string to decode.  The decoded string is returned.  A TypeError&#10;is raised if the string is incorrectly padded or if there are non-alphabet&#10;characters present in the string.&#10;&#10;The alphabet uses '-' instead of '+' and '_' instead of '/'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.urlsafe_b64encode" func="yes">
			<Overload retVal="" descr="Encode a string using a url-safe Base64 alphabet.&#10;&#10;s is the string to encode.  The encoded string is returned.  The alphabet&#10;uses '-' instead of '+' and '_' instead of '/'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.v" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="basejoin" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="basename" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="basestring" func="yes">
			<Overload retVal="" descr="Type basestring cannot be instantiated; it is the base for str and unicode.">
			</Overload>
		</KeyWord>
		<KeyWord name="basicConfig" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="bbox" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb" func="yes">
			<Overload retVal="" descr="Debugger basics">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.BdbQuit" func="yes">
			<Overload retVal="" descr="Exception to give up completely">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.BdbQuit.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.BdbQuit.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Breakpoint" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.bar" />
		<KeyWord name="bdb.checkfuncname" func="yes">
			<Overload retVal="" descr="Check whether we should break here because of `b.funcname`.">
				<Param name="b" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.effective" func="yes">
			<Overload retVal="" descr="Determine which breakpoint for this file:line is to be acted upon.&#10;&#10;Called only if we know there is a bpt at this&#10;location.  Returns breakpoint that was triggered and a flag&#10;that indicates if it is ok to delete a temporary bp.">
				<Param name="file" />
				<Param name="line" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.foo" />
		<KeyWord name="bdb.set_trace" />
		<KeyWord name="bdb.test" />
		<KeyWord name="begin_fill" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="begin_poly" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="bell" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="betavariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="bgcolor" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="bgpic" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="bidirectional" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="bin" func="yes">
			<Overload retVal="" descr="bin(number) -&gt; string&#10;&#10;Return the binary representation of an integer or long integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="bind" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="bind_all" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="bind_class" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="bind_textdomain_codeset" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="bindtags" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="bindtextdomain" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex" func="yes">
			<Overload retVal="" descr="Macintosh binhex compression/decompression.&#10;&#10;easy interface:&#10;binhex(inputfilename, outputfilename)&#10;hexbin(inputfilename, outputfilename)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.BinHex" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.Error" />
		<KeyWord name="binhex.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.FInfo" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.HexBin" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.LINELEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.REASONABLY_LARGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.RUNCHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.binhex" func="yes">
			<Overload retVal="" descr="(infilename, outfilename) - Create binhex-encoded copy of a file">
				<Param name="inp" />
				<Param name="out" />
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.getfileinfo" />
		<KeyWord name="binhex.hexbin" func="yes">
			<Overload retVal="" descr="(infilename, outfilename) - Decode binhexed file">
				<Param name="inp" />
				<Param name="out" />
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.openrsrc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect" func="yes">
			<Overload retVal="" descr="Bisection algorithms.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.bisect" func="yes">
			<Overload retVal="" descr="bisect(a, x[, lo[, hi]]) -&gt; index&#10;bisect_right(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt;= x, and all e in&#10;a[i:] have e &gt; x.  So if x already appears in the list, i points just&#10;beyond the rightmost x already there&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.bisect_left" func="yes">
			<Overload retVal="" descr="bisect_left(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt; x, and all e in&#10;a[i:] have e &gt;= x.  So if x already appears in the list, i points just&#10;before the leftmost x already there.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.bisect_right" func="yes">
			<Overload retVal="" descr="bisect(a, x[, lo[, hi]]) -&gt; index&#10;bisect_right(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt;= x, and all e in&#10;a[i:] have e &gt; x.  So if x already appears in the list, i points just&#10;beyond the rightmost x already there&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.insort" func="yes">
			<Overload retVal="" descr="insort(a, x[, lo[, hi]])&#10;insort_right(a, x[, lo[, hi]])&#10;&#10;Insert item x in list a, and keep it sorted assuming a is sorted.&#10;&#10;If x is already in a, insert it to the right of the rightmost x.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.insort_left" func="yes">
			<Overload retVal="" descr="insort_left(a, x[, lo[, hi]])&#10;&#10;Insert item x in list a, and keep it sorted assuming a is sorted.&#10;&#10;If x is already in a, insert it to the left of the leftmost x.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.insort_right" func="yes">
			<Overload retVal="" descr="insort(a, x[, lo[, hi]])&#10;insort_right(a, x[, lo[, hi]])&#10;&#10;Insert item x in list a, and keep it sorted assuming a is sorted.&#10;&#10;If x is already in a, insert it to the right of the rightmost x.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect_left" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect_right" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="bk" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="bltn_open" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="bool" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="boolean" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.boolean">
			</Overload>
		</KeyWord>
		<KeyWord name="break" />
		<KeyWord name="bsddb" func="yes">
			<Overload retVal="" descr="Support for Berkeley DB 4.3 through 5.3 with a simple interface.&#10;&#10;For the full featured object oriented interface use the bsddb.db module&#10;instead.  It mirrors the Oracle Berkeley DB C API.">
			</Overload>
		</KeyWord>
		<KeyWord name="bsddb.MutableMapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="bsddb.btopen" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="[flag=c" />
				<Param name="[mode=438" />
				<Param name="[btflags=0" />
				<Param name="[cachesize=None" />
				<Param name="[maxkeypage=None" />
				<Param name="[minkeypage=None" />
				<Param name="[pgsize=None" />
				<Param name="[lorder=None]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bsddb.error" />
		<KeyWord name="bsddb.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bsddb.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bsddb.hashopen" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="[flag=c" />
				<Param name="[mode=438" />
				<Param name="[pgsize=None" />
				<Param name="[ffactor=None" />
				<Param name="[nelem=None" />
				<Param name="[cachesize=None" />
				<Param name="[lorder=None" />
				<Param name="[hflags=0]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bsddb.ref" />
		<KeyWord name="bsddb.rnopen" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="[flag=c" />
				<Param name="[mode=438" />
				<Param name="[rnflags=0" />
				<Param name="[cachesize=None" />
				<Param name="[pgsize=None" />
				<Param name="[lorder=None" />
				<Param name="[rlen=None" />
				<Param name="[delim=None" />
				<Param name="[source=None" />
				<Param name="[pad=None]]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="btopen" func="yes">
			<Overload retVal="" descr="Function of bsddb">
			</Overload>
		</KeyWord>
		<KeyWord name="buffer" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="buffer_info" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="build_opener" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="bye" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="byref" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="bytearray" func="yes">
			<Overload retVal="" descr="bytearray(iterable_of_ints) -&gt; bytearray.&#10;bytearray(string, encoding[, errors]) -&gt; bytearray.&#10;bytearray(bytes_or_bytearray) -&gt; mutable copy of bytes_or_bytearray.&#10;bytearray(memory_view) -&gt; bytearray.&#10;&#10;Construct an mutable bytearray object from:&#10;  - an iterable yielding integers in range(256)&#10;  - a text string encoded using the specified encoding&#10;  - a bytes or a bytearray object&#10;  - any object implementing the buffer API.&#10;&#10;bytearray(int) -&gt; bytearray.&#10;&#10;Construct a zero-initialized bytearray of the given length.">
			</Overload>
		</KeyWord>
		<KeyWord name="bytes" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="byteswap" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2" func="yes">
			<Overload retVal="" descr="The python bz2 module provides a comprehensive interface for&#10;the bz2 compression library. It implements a complete file&#10;interface, one shot (de)compression functions, and types for&#10;sequential (de)compression.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Compressor" func="yes">
			<Overload retVal="" descr="BZ2Compressor([compresslevel=9]) -&gt; compressor object&#10;&#10;Create a new compressor object. This object may be used to compress&#10;data sequentially. If you want to compress data in one shot, use the&#10;compress() function instead. The compresslevel parameter, if given,&#10;must be a number between 1 and 9.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Compressor.compress" func="yes">
			<Overload retVal="" descr="compress(data) -&gt; string&#10;&#10;Provide more data to the compressor object. It will return chunks of&#10;compressed data whenever possible. When you've finished providing data&#10;to compress, call the flush() method to finish the compression process,&#10;and return what is left in the internal buffers.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Compressor.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; string&#10;&#10;Finish the compression process and return what is left in internal buffers.&#10;You must not use the compressor object after calling this method.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor" func="yes">
			<Overload retVal="" descr="BZ2Decompressor() -&gt; decompressor object&#10;&#10;Create a new decompressor object. This object may be used to decompress&#10;data sequentially. If you want to decompress data in one shot, use the&#10;decompress() function instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor.decompress" func="yes">
			<Overload retVal="" descr="decompress(data) -&gt; string&#10;&#10;Provide more data to the decompressor object. It will return chunks&#10;of decompressed data whenever possible. If you try to decompress data&#10;after the end of stream is found, EOFError will be raised. If any data&#10;was found after the end of stream, it'll be ignored and saved in&#10;unused_data attribute.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor.unused_data" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File" func="yes">
			<Overload retVal="" descr="BZ2File(name [, mode='r', buffering=0, compresslevel=9]) -&gt; file object&#10;&#10;Open a bz2 file. The mode can be 'r' or 'w', for reading (default) or&#10;writing. When opened for writing, the file will be created if it doesn't&#10;exist, and truncated otherwise. If the buffering argument is given, 0 means&#10;unbuffered, and larger numbers specify the buffer size. If compresslevel&#10;is given, must be a number between 1 and 9.&#10;&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support. Any line ending in the input file will be seen as a '\n' in&#10;Python. Also, a file so opened gains the attribute 'newlines'; the value&#10;for this attribute is one of None (no newline read yet), '\r', '\n',&#10;'\r\n' or a tuple containing all the newline types seen. Universal&#10;newlines are available only when reading.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer&#10;&#10;Close the file. Sets data attribute .closed to true. A closed file&#10;cannot be used for further I/O operations. close() may be called more&#10;than once without error.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; string&#10;&#10;Read at most size uncompressed bytes, returned as a string. If the size&#10;argument is negative or omitted, read until EOF is reached.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; string&#10;&#10;Return the next line from the file, as a string, retaining newline.&#10;A non-negative size argument will limit the maximum number of bytes to&#10;return (an incomplete line may be returned then). Return an empty&#10;string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list&#10;&#10;Call readline() repeatedly and return a list of lines read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.seek" func="yes">
			<Overload retVal="" descr="seek(offset [, whence]) -&gt; None&#10;&#10;Move to new file position. Argument offset is a byte count. Optional&#10;argument whence defaults to 0 (offset from start of file, offset&#10;should be &gt;= 0); other values are 1 (move relative to current position,&#10;positive or negative), and 2 (move relative to end of file, usually&#10;negative, although many platforms allow seeking beyond the end of a file).&#10;&#10;Note that seeking of bz2 files is emulated, and depending on the parameters&#10;the operation may be extremely slow.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.softspace" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; int&#10;&#10;Return the current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.write" func="yes">
			<Overload retVal="" descr="write(data) -&gt; None&#10;&#10;Write the 'data' string to file. Note that due to buffering, close() may&#10;be needed before the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None&#10;&#10;Write the sequence of strings to the file. Note that newlines are not&#10;added. The sequence can be any iterable object producing strings. This is&#10;equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; self&#10;&#10;For backward compatibility. BZ2File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.compress" func="yes">
			<Overload retVal="" descr="compress(data [, compresslevel=9]) -&gt; string&#10;&#10;Compress data in one shot. If you want to compress data sequentially,&#10;use an instance of BZ2Compressor instead. The compresslevel parameter, if&#10;given, must be a number between 1 and 9.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.decompress" func="yes">
			<Overload retVal="" descr="decompress(data) -&gt; decompressed data&#10;&#10;Decompress data in one shot. If you want to decompress data sequentially,&#10;use an instance of BZ2Decompressor instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2open" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="c2py" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile" func="yes">
			<Overload retVal="" descr="Python interface for the 'lsprof' profiler.&#10;Compatible with the 'profile' module.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile" func="yes">
			<Overload retVal="" descr="Profile(custom_timer=None, time_unit=None, subcalls=True, builtins=True)&#10;&#10;Builds a profiler object using the specified timer function.&#10;The default timer is a fast built-in one based on real time.&#10;For custom timer functions returning integers, time_unit can&#10;be a float specifying a scale (i.e. how long each integer unit&#10;is, in seconds).">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.clear" func="yes">
			<Overload retVal="" descr="clear()&#10;&#10;Clear all profiling information collected so far.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.create_stats" />
		<KeyWord name="cProfile.Profile.disable" func="yes">
			<Overload retVal="" descr="disable()&#10;&#10;Stop collecting profiling information.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.dump_stats" />
		<KeyWord name="cProfile.Profile.enable" func="yes">
			<Overload retVal="" descr="enable(subcalls=True, builtins=True)&#10;&#10;Start collecting profiling information.&#10;If 'subcalls' is True, also records for each function&#10;statistics separated according to its current caller.&#10;If 'builtins' is True, records the time spent in&#10;built-in functions separately from their caller.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.getstats" func="yes">
			<Overload retVal="" descr="getstats() -&gt; list of profiler_entry objects&#10;&#10;Return all information collected by the profiler.&#10;Each profiler_entry is a tuple-like object with the&#10;following attributes:&#10;&#10;    code          code object&#10;    callcount     how many times this was called&#10;    reccallcount  how many times called recursively&#10;    totaltime     total time in this entry&#10;    inlinetime    inline time in this entry (not in subcalls)&#10;    calls         details of the calls&#10;&#10;The calls attribute is either None or a list of&#10;profiler_subentry objects:&#10;&#10;    code          called code object&#10;    callcount     how many times this is called&#10;    reccallcount  how many times this is called recursively&#10;    totaltime     total time spent in this call&#10;    inlinetime    inline time (not in further subcalls)">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.print_stats" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[sort=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.run" />
		<KeyWord name="cProfile.Profile.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.runctx" />
		<KeyWord name="cProfile.Profile.snapshot_stats" />
		<KeyWord name="cProfile.help" />
		<KeyWord name="cProfile.label" />
		<KeyWord name="cProfile.main" />
		<KeyWord name="cProfile.run" func="yes">
			<Overload retVal="" descr='Run statement under profiler optionally saving results in filename&#10;&#10;This function takes a single argument that can be passed to the&#10;"exec" statement, and an optional file name.  In all cases this&#10;routine attempts to "exec" its first argument and gather profiling&#10;statistics from the execution. If no file name is present, then this&#10;function automatically prints a simple profiling report, sorted by the&#10;standard name string (file/line/function-name) that is presented in&#10;each line.'>
				<Param name="statement" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.runctx" func="yes">
			<Overload retVal="" descr="Run statement under profiler, supplying your own globals and locals,&#10;optionally saving results in filename.&#10;&#10;statement and filename have the same semantics as profile.run">
				<Param name="statement" />
				<Param name="globals" />
				<Param name="locals" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="c_buffer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="calc_chksums" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="calcsize" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar" func="yes">
			<Overload retVal="" descr="Calendar printing functions&#10;&#10;Note when comparing these calendars to the ones printed by cal(1): By&#10;default, these calendars have Monday as the first day of the week, and&#10;Sunday as the last (the European convention). Use setfirstweekday() to&#10;set the first day of the week (0=Monday, 6=Sunday).">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar" func="yes">
			<Overload retVal="" descr="Base calendar class. This class doesn't do any formatting. It simply&#10;provides data to subclasses.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.getfirstweekday" />
		<KeyWord name="calendar.Calendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return a iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.setfirstweekday" />
		<KeyWord name="calendar.Calendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.EPOCH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.FRIDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.February" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar" func="yes">
			<Overload retVal="" descr="This calendar returns complete HTML pages.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.cssclasses" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatday" func="yes">
			<Overload retVal="" descr="Return a day as a table cell.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a formatted month as a table.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr="Return a month name as a table row.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Return a complete week as a table row.">
				<Param name="self" />
				<Param name="theweek" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatweekday" func="yes">
			<Overload retVal="" descr="Return a weekday name as a table header.">
				<Param name="self" />
				<Param name="day" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week as a table row.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Return a formatted year as a table of tables.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatyearpage" func="yes">
			<Overload retVal="" descr="Return a formatted year as a complete HTML page.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3" />
				<Param name="[css=calendar.css" />
				<Param name="[encoding=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.getfirstweekday" />
		<KeyWord name="calendar.HTMLCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return a iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.setfirstweekday" />
		<KeyWord name="calendar.HTMLCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalMonthError" />
		<KeyWord name="calendar.IllegalMonthError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalMonthError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalWeekdayError" />
		<KeyWord name="calendar.IllegalWeekdayError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalWeekdayError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.January" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar" func="yes">
			<Overload retVal="" descr="This class can be passed a locale name in the constructor and will return&#10;month and weekday names in the specified locale. If this locale includes&#10;an encoding all strings containing month and weekday names will be returned&#10;as unicode.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.cssclasses" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatday" func="yes">
			<Overload retVal="" descr="Return a day as a table cell.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a formatted month as a table.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Return a complete week as a table row.">
				<Param name="self" />
				<Param name="theweek" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatweekday" />
		<KeyWord name="calendar.LocaleHTMLCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week as a table row.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Return a formatted year as a table of tables.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatyearpage" func="yes">
			<Overload retVal="" descr="Return a formatted year as a complete HTML page.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3" />
				<Param name="[css=calendar.css" />
				<Param name="[encoding=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.getfirstweekday" />
		<KeyWord name="calendar.LocaleHTMLCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return a iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.setfirstweekday" />
		<KeyWord name="calendar.LocaleHTMLCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar" func="yes">
			<Overload retVal="" descr="This class can be passed a locale name in the constructor and will return&#10;month and weekday names in the specified locale. If this locale includes&#10;an encoding all strings containing month and weekday names will be returned&#10;as unicode.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatday" func="yes">
			<Overload retVal="" descr="Returns a formatted day.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a month's calendar string (multi-line).">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="width" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Returns a single week in a string (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatweekday" />
		<KeyWord name="calendar.LocaleTextCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week.">
				<Param name="self" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Returns a year's calendar as a multi-line string.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=2" />
				<Param name="[l=1" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.getfirstweekday" />
		<KeyWord name="calendar.LocaleTextCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return a iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.prmonth" func="yes">
			<Overload retVal="" descr="Print a month's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.prweek" func="yes">
			<Overload retVal="" descr="Print a single week (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.pryear" func="yes">
			<Overload retVal="" descr="Print a year's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=0" />
				<Param name="[l=0" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.setfirstweekday" />
		<KeyWord name="calendar.LocaleTextCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.SATURDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.SUNDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.THURSDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TUESDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar" func="yes">
			<Overload retVal="" descr="Subclass of Calendar that outputs a calendar as a simple plain text&#10;similar to the UNIX program cal.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatday" func="yes">
			<Overload retVal="" descr="Returns a formatted day.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a month's calendar string (multi-line).">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr="Return a formatted month name.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="width" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Returns a single week in a string (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatweekday" func="yes">
			<Overload retVal="" descr="Returns a formatted week day name.">
				<Param name="self" />
				<Param name="day" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week.">
				<Param name="self" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Returns a year's calendar as a multi-line string.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=2" />
				<Param name="[l=1" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.getfirstweekday" />
		<KeyWord name="calendar.TextCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return a iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.prmonth" func="yes">
			<Overload retVal="" descr="Print a month's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.prweek" func="yes">
			<Overload retVal="" descr="Print a single week (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.pryear" func="yes">
			<Overload retVal="" descr="Print a year's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=0" />
				<Param name="[l=0" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.setfirstweekday" />
		<KeyWord name="calendar.TextCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TimeEncoding" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.WEDNESDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.c" func="yes">
			<Overload retVal="" descr="(TextCalendar)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.calendar" func="yes">
			<Overload retVal="" descr="Returns a year's calendar as a multi-line string.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=2" />
				<Param name="[l=1" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.day_abbr" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.day_name" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.firstweekday" />
		<KeyWord name="calendar.format" func="yes">
			<Overload retVal="" descr="Prints multi-column formatting for year calendars">
				<Param name="cols" />
				<Param name="[colwidth=20" />
				<Param name="[spacing=6]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.formatstring" func="yes">
			<Overload retVal="" descr="Returns a string formatted from n strings, centered within n columns.">
				<Param name="cols" />
				<Param name="[colwidth=20" />
				<Param name="[spacing=6]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.isleap" func="yes">
			<Overload retVal="" descr="Return True for leap years, False for non-leap years.">
				<Param name="year" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.leapdays" func="yes">
			<Overload retVal="" descr="Return number of leap years in range [y1, y2).&#10;Assume y1 &lt;= y2.">
				<Param name="y1" />
				<Param name="y2" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.main" />
		<KeyWord name="calendar.mdays" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.month" func="yes">
			<Overload retVal="" descr="Return a month's calendar string (multi-line).">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.month_abbr" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.month_name" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.monthcalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.monthrange" func="yes">
			<Overload retVal="" descr="Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for&#10;year, month.">
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.prcal" func="yes">
			<Overload retVal="" descr="Print a year's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=0" />
				<Param name="[l=0" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.prmonth" func="yes">
			<Overload retVal="" descr="Print a month's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.prweek" func="yes">
			<Overload retVal="" descr="Print a single week (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.setfirstweekday" />
		<KeyWord name="calendar.week" func="yes">
			<Overload retVal="" descr="Returns a single week in a string (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.weekday" func="yes">
			<Overload retVal="" descr="Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),&#10;day (1-31).">
				<Param name="year" />
				<Param name="month" />
				<Param name="day" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.weekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week.">
				<Param name="self" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="call" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="callHandlers" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="callable" func="yes">
			<Overload retVal="" descr="callable(object) -&gt; bool&#10;&#10;Return whether the object is callable (i.e., some kind of function).&#10;Note that classes are callable, as are instances with a __call__() method.">
			</Overload>
		</KeyWord>
		<KeyWord name="canonical" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="captureWarnings" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="capwords" func="yes">
			<Overload retVal="" descr="Function of stringold">
			</Overload>
		</KeyWord>
		<KeyWord name="cast" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="category" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="ceil" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="cert_store_stats" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="cert_time_to_seconds" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="cget" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi" func="yes">
			<Overload retVal="" descr="Support module for CGI (Common Gateway Interface) scripts.&#10;&#10;This module defines a number of utilities for use by CGI scripts&#10;written in Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FormContent" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FormContentDict" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.InterpFormContentDict" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.MiniFieldStorage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.SvFormContentDict" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.attrgetter" func="yes">
			<Overload retVal="" descr="attrgetter(attr, ...) --&gt; attrgetter object&#10;&#10;Return a callable object that fetches the given attribute(s) from its operand.&#10;After f = attrgetter('name'), the call f(r) returns r.name.&#10;After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).&#10;After h = attrgetter('name.first', 'name.last'), the call h(r) returns&#10;(r.name.first, r.name.last).">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.catch_warnings" func="yes">
			<Overload retVal="" descr="A context manager that copies and restores the warnings filter upon&#10;exiting the context.&#10;&#10;The 'record' argument specifies whether warnings should be captured by a&#10;custom implementation of warnings.showwarning() and be appended to a list&#10;returned by the context manager. Otherwise None is returned by the context&#10;manager. The objects appended to the list are arguments whose attributes&#10;mirror the arguments to showwarning().&#10;&#10;The 'module' argument is to specify an alternative module to the module&#10;named 'warnings' and imported under that name. This argument is only useful&#10;when testing the warnings module itself.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.dolog" func="yes">
			<Overload retVal="" descr="Write a log message to the log file.  See initlog() for docs.">
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.escape" func="yes">
			<Overload retVal="" descr='Replace special characters "&amp;", "&lt;" and "&gt;" to HTML-safe sequences.&#10;If the optional flag quote is true, the quotation mark character (")&#10;is also translated.'>
				<Param name="s" />
				<Param name="[quote=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.filterwarnings" func="yes">
			<Overload retVal="" descr="Insert an entry into the list of warnings filters (at the front).&#10;&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'message' -- a regex that the warning message must match&#10;'category' -- a class that the warning must be a subclass of&#10;'module' -- a regex that the module name must match&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[message" />
				<Param name="[category=<type 'exceptions.Warning'>" />
				<Param name="[module" />
				<Param name="[lineno=0" />
				<Param name="[append=0]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.initlog" func="yes">
			<Overload retVal="" descr="Write a log message, if there is a log file.&#10;&#10;Even though this function is called initlog(), you should always&#10;use log(); log is a variable that is set either to initlog&#10;(initially), to dolog (once the log file has been opened), or to&#10;nolog (when logging is disabled).&#10;&#10;The first argument is a format string; the remaining arguments (if&#10;any) are arguments to the % operator, so e.g.&#10;    log(&quot;%s: %s&quot;, &quot;a&quot;, &quot;b&quot;)&#10;will write &quot;a: b&quot; to the log file, followed by a newline.&#10;&#10;If the global logfp is not None, it should be a file object to&#10;which log data is written.&#10;&#10;If the global logfp is None, the global logfile may be a string&#10;giving a filename to open, in append mode.  This file should be&#10;world writable!!!  If the file can't be opened, logging is&#10;silently disabled (since there is no safe place where we could&#10;send an error message).">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.log" func="yes">
			<Overload retVal="" descr="Write a log message, if there is a log file.&#10;&#10;Even though this function is called initlog(), you should always&#10;use log(); log is a variable that is set either to initlog&#10;(initially), to dolog (once the log file has been opened), or to&#10;nolog (when logging is disabled).&#10;&#10;The first argument is a format string; the remaining arguments (if&#10;any) are arguments to the % operator, so e.g.&#10;    log(&quot;%s: %s&quot;, &quot;a&quot;, &quot;b&quot;)&#10;will write &quot;a: b&quot; to the log file, followed by a newline.&#10;&#10;If the global logfp is not None, it should be a file object to&#10;which log data is written.&#10;&#10;If the global logfp is None, the global logfile may be a string&#10;giving a filename to open, in append mode.  This file should be&#10;world writable!!!  If the file can't be opened, logging is&#10;silently disabled (since there is no safe place where we could&#10;send an error message).">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.nolog" func="yes">
			<Overload retVal="" descr="Dummy function, assigned to log when logging is disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_header" func="yes">
			<Overload retVal="" descr="Parse a Content-type like header.&#10;&#10;Return the main content-type and a dictionary of options.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_multipart" func="yes">
			<Overload retVal="" descr="Parse multipart input.&#10;&#10;Arguments:&#10;fp   : input file&#10;pdict: dictionary containing other parameters of content-type header&#10;&#10;Returns a dictionary just like parse_qs(): keys are the field names, each&#10;value is a list of values for that field.  This is easy to use but not&#10;much good if you are expecting megabytes to be uploaded -- in that case,&#10;use the FieldStorage class instead which is much more flexible.  Note&#10;that content-type is the raw, unparsed contents of the content-type&#10;header.&#10;&#10;XXX This does not parse nested multipart parts -- use FieldStorage for&#10;that.&#10;&#10;XXX This should really be subsumed by FieldStorage altogether -- no&#10;point in having two implementations of the same parsing algorithm.&#10;Also, FieldStorage protects itself better against certain DoS attacks&#10;by limiting the size of the data read in one chunk.  The API here&#10;does not support that kind of protection.  This also affects parse()&#10;since it can call parse_multipart().">
				<Param name="fp" />
				<Param name="pdict" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_qs" func="yes">
			<Overload retVal="" descr="Parse a query given as a string argument.">
				<Param name="qs" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_qsl" func="yes">
			<Overload retVal="" descr="Parse a query given as a string argument.">
				<Param name="qs" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_arguments" />
		<KeyWord name="cgi.print_directory" func="yes">
			<Overload retVal="" descr="Dump the current directory as HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_environ_usage" func="yes">
			<Overload retVal="" descr="Dump a list of environment variables used by CGI as HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_exception" func="yes">
			<Overload retVal="" descr=>
				<Param name="[type=None" />
				<Param name="[value=None" />
				<Param name="[tb=None" />
				<Param name="[limit=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_form" func="yes">
			<Overload retVal="" descr="Dump the contents of a form as HTML.">
				<Param name="form" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.valid_boundary" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[_vb_pattern=^[ -~]{0,200}[!-~]$]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb" func="yes">
			<Overload retVal="" descr="More comprehensive traceback formatting for Python scripts.&#10;&#10;To enable this module, do:&#10;&#10;    import cgitb; cgitb.enable()&#10;&#10;at the top of your script.  The optional arguments to enable() are:&#10;&#10;    display     - if true, tracebacks are displayed in the web browser&#10;    logdir      - if set, tracebacks are written to files in this directory&#10;    context     - number of lines of source code to show for each stack frame&#10;    format      - 'text' or 'html' controls the output format&#10;&#10;By default, tracebacks are displayed but not saved, the context is 5 lines&#10;and the output format is 'html' (for backwards compatibility with the&#10;original use of this module)&#10;&#10;Alternatively, if you have caught an exception and want cgitb to display it&#10;for you, call cgitb.handler().  The optional argument to handler() is a&#10;3-item tuple (etype, evalue, etb) just like the value of sys.exc_info().&#10;The default handler displays output as HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.Hook" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.enable" func="yes">
			<Overload retVal="" descr="Install an exception handler that formats tracebacks as HTML.&#10;&#10;The optional argument 'display' can be set to 0 to suppress sending the&#10;traceback to the browser, and 'logdir' can be set to a directory to cause&#10;tracebacks to be written to files there.">
				<Param name="[display=1" />
				<Param name="[logdir=None" />
				<Param name="[context=5" />
				<Param name="[format=html]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.grey" />
		<KeyWord name="cgitb.handler" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[info=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.html" func="yes">
			<Overload retVal="" descr="Return a nice HTML document describing a given traceback.">
				<Param name="einfo" />
				<Param name="[context=5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.lookup" func="yes">
			<Overload retVal="" descr="Find the value for a given name in the given environment.">
				<Param name="name" />
				<Param name="frame" />
				<Param name="locals" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.reset" func="yes">
			<Overload retVal="" descr="Return a string that resets the CGI and browser to a known state.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.scanvars" func="yes">
			<Overload retVal="" descr="Scan one logical line of Python and look up values of variables used.">
				<Param name="reader" />
				<Param name="frame" />
				<Param name="locals" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.small" />
		<KeyWord name="cgitb.strong" />
		<KeyWord name="cgitb.text" func="yes">
			<Overload retVal="" descr="Return a plain text document describing a given traceback.">
				<Param name="einfo" />
				<Param name="[context=5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="chain" func="yes">
			<Overload retVal="" descr="Function of heapq.chain">
			</Overload>
		</KeyWord>
		<KeyWord name="change_sequence" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="charbuffer_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="charmap_build" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="charmap_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="charmap_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="chdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="check" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="check_builtin" func="yes">
			<Overload retVal="" descr="Function of optparse">
			</Overload>
		</KeyWord>
		<KeyWord name="check_call" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="check_choice" func="yes">
			<Overload retVal="" descr="Function of optparse">
			</Overload>
		</KeyWord>
		<KeyWord name="check_enableusersite" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="check_output" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="check_unused_args" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="checkcache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="checkfuncname" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="chmod" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="choice" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="choose_boundary" func="yes">
			<Overload retVal="" descr="Function of mimetools">
			</Overload>
		</KeyWord>
		<KeyWord name="chown" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="chr" func="yes">
			<Overload retVal="" descr="chr(i) -&gt; character&#10;&#10;Return a string of one character with ordinal i; 0 &lt;= i &lt; 256.">
			</Overload>
		</KeyWord>
		<KeyWord name="chunk" func="yes">
			<Overload retVal="" descr="Simple class to read IFF chunks.&#10;&#10;An IFF chunk (used in formats such as AIFF, TIFF, RMFF (RealMedia File&#10;Format)) has the following structure:&#10;&#10;+----------------+&#10;| ID (4 bytes)   |&#10;+----------------+&#10;| size (4 bytes) |&#10;+----------------+&#10;| data           |&#10;| ...            |&#10;+----------------+&#10;&#10;The ID is a 4-byte string which identifies the type of chunk.&#10;&#10;The size field (a 32-bit value, encoded using big-endian byte order)&#10;gives the size of the whole chunk, including the 8-byte header.&#10;&#10;Usually an IFF-type file consists of one or more chunks.  The proposed&#10;usage of the Chunk class defined here is to instantiate an instance at&#10;the start of each chunk and read from the instance until it reaches&#10;the end, after which a new instance can be instantiated.  At the end&#10;of the file, creating a new instance will fail with a EOFError&#10;exception.&#10;&#10;Usage:&#10;while True:&#10;    try:&#10;        chunk = Chunk(file)&#10;    except EOFError:&#10;        break&#10;    chunktype = chunk.getname()&#10;    while True:&#10;        data = chunk.read(nbytes)&#10;        if not data:&#10;            pass&#10;        # do something with data&#10;&#10;The interface is file-like.  The implemented methods are:&#10;read, close, seek, tell, isatty.&#10;Extra methods are: skip() (called by close, skips to the end of the chunk),&#10;getname() (returns the name (ID) of the chunk)&#10;&#10;The __init__ method has one required argument, a file-like object&#10;(including a chunk instance), and one optional argument, a flag which&#10;specifies whether or not chunks are aligned on 2-byte boundaries.  The&#10;default is 1, i.e. aligned.">
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cipher" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="circle" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="class" />
		<KeyWord name="classify_class_attrs" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="classmethod" func="yes">
			<Overload retVal="" descr="classmethod(function) -&gt; method&#10;&#10;Convert a function to be a class method.&#10;&#10;A class method receives the class as implicit first argument,&#10;just like an instance method receives the instance.&#10;To declare a class method, use this idiom:&#10;&#10;  class C:&#10;      def f(cls, arg1, arg2, ...): ...&#10;      f = classmethod(f)&#10;&#10;It can be called either on the class (e.g. C.f()) or on an instance&#10;(e.g. C().f()).  The instance is ignored except for its class.&#10;If a class method is called for a derived class, the derived class&#10;object is passed as the implied first argument.&#10;&#10;Class methods are different than C++ or Java static methods.&#10;If you want those, see the staticmethod builtin.">
			</Overload>
		</KeyWord>
		<KeyWord name="classname" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="cleandoc" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="clear" func="yes">
			<Overload retVal="" descr="Remove all elements from this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_cache" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_extension_cache" func="yes">
			<Overload retVal="" descr="Function of copy_reg">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_flags" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="clearcache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="clearscreen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="clearstamp" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="clearstamps" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="cli" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="clipboard_append" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="clipboard_clear" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="clipboard_get" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="clone" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="close_all" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="closerange" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd" func="yes">
			<Overload retVal="" descr="A generic class to build line-oriented command interpreters.&#10;&#10;Interpreters constructed with this class obey the following conventions:&#10;&#10;1. End of file on input is processed as the command 'EOF'.&#10;2. A command is parsed out of each line by collecting the prefix composed&#10;   of characters in the identchars member.&#10;3. A command `foo' is dispatched to a method 'do_foo()'; the do_ method&#10;   is passed a single argument consisting of the remainder of the line.&#10;4. Typing an empty line repeats the last command.  (Actually, it calls the&#10;   method `emptyline', which may be overridden in a subclass.)&#10;5. There is a predefined `help' method.  Given an argument `topic', it&#10;   calls the command `help_topic'.  With no arguments, it lists all topics&#10;   with defined help_ functions, broken into up to three topics; documented&#10;   commands, miscellaneous help topics, and undocumented commands.&#10;6. The command '?' is a synonym for `help'.  The command '!' is a synonym&#10;   for `shell', if a do_shell method exists.&#10;7. If completion is enabled, completing commands will be done automatically,&#10;   and completing of commands args is done by calling complete_foo() with&#10;   arguments text, line, begidx, endidx.  text is string we are matching&#10;   against, all returned matches must begin with it.  line is the current&#10;   input line (lstripped), begidx and endidx are the beginning and end&#10;   indexes of the text being matched, which could be used to provide&#10;   different completion depending upon which position the argument is in.&#10;&#10;The `default' method may be overridden to intercept commands for which there&#10;is no do_ method.&#10;&#10;The `completedefault' method may be overridden to intercept completions for&#10;commands that have no complete_ method.&#10;&#10;The data member `self.ruler' sets the character used to draw separator lines&#10;in the help messages.  If empty, no ruler line is drawn.  It defaults to &quot;=&quot;.&#10;&#10;If the value of `self.intro' is nonempty when the cmdloop method is called,&#10;it is printed out on interpreter startup.  This value may be overridden&#10;via an optional argument to the cmdloop() method.&#10;&#10;The data members `self.doc_header', `self.misc_header', and&#10;`self.undoc_header' set the headers used for the help function's&#10;listings of documented functions, miscellaneous topics, and undocumented&#10;functions respectively.&#10;&#10;These interpreters use raw_input; thus, if the readline module is loaded,&#10;they automatically support Emacs-like command history and editing features.">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.IDENTCHARS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.PROMPT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmp" func="yes">
			<Overload retVal="" descr="cmp(x, y) -&gt; integer&#10;&#10;Return negative if x&lt;y, zero if x==y, positive if x&gt;y.">
			</Overload>
		</KeyWord>
		<KeyWord name="cmp_lt" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="cmp_to_key" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="cmpfiles" func="yes">
			<Overload retVal="" descr="Function of filecmp">
			</Overload>
		</KeyWord>
		<KeyWord name="code" func="yes">
			<Overload retVal="" descr="Utilities needed to emulate Python's interactive interpreter.">
			</Overload>
		</KeyWord>
		<KeyWord name="code.CommandCompiler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="code.compile_command" func="yes">
			<Overload retVal="" descr='Compile a command and determine whether it is incomplete.&#10;&#10;Arguments:&#10;&#10;source -- the source string; may contain \n characters&#10;filename -- optional filename from which source was read; default&#10;            "&lt;input&gt;"&#10;symbol -- optional grammar start symbol; "single" (default) or "eval"&#10;&#10;Return value / exceptions raised:&#10;&#10;- Return a code object if the command is complete and valid&#10;- Return None if the command is incomplete&#10;- Raise SyntaxError, ValueError or OverflowError if the command is a&#10;  syntax error (OverflowError and ValueError can be produced by&#10;  malformed literals).'>
				<Param name="source" />
				<Param name="[filename=<input>" />
				<Param name="[symbol=single]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.interact" func="yes">
			<Overload retVal="" descr="Closely emulate the interactive Python interpreter.&#10;&#10;This is a backwards compatible interface to the InteractiveConsole&#10;class.  When readfunc is not specified, it attempts to import the&#10;readline module to enable GNU readline if it is available.&#10;&#10;Arguments (all optional, all default to None):&#10;&#10;banner -- passed to InteractiveConsole.interact()&#10;readfunc -- if not None, replaces InteractiveConsole.raw_input()&#10;local -- passed to InteractiveInterpreter.__init__()">
				<Param name="[banner=None" />
				<Param name="[readfunc=None" />
				<Param name="[local=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.softspace" />
		<KeyWord name="codecs" func="yes">
			<Overload retVal="" descr="codecs -- Python Codec Registry, API and helpers.&#10;&#10;&#10;Written by Marc-Andre Lemburg (mal@lemburg.com).&#10;&#10;(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM32_BE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM32_LE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM64_BE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM64_LE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_BE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_LE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF16" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF16_BE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF16_LE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF32" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF32_BE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF32_LE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF8" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder" func="yes">
			<Overload retVal="" descr="This subclass of IncrementalDecoder can be used as the baseclass for an&#10;incremental decoder if the decoder must be able to handle incomplete byte&#10;sequences.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder.decode" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder.getstate" />
		<KeyWord name="codecs.BufferedIncrementalDecoder.reset" />
		<KeyWord name="codecs.BufferedIncrementalDecoder.setstate" />
		<KeyWord name="codecs.BufferedIncrementalEncoder" func="yes">
			<Overload retVal="" descr="This subclass of IncrementalEncoder can be used as the baseclass for an&#10;incremental encoder if the encoder must keep some of the output in a&#10;buffer between calls to encode().">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder.encode" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder.getstate" />
		<KeyWord name="codecs.BufferedIncrementalEncoder.reset" />
		<KeyWord name="codecs.BufferedIncrementalEncoder.setstate" />
		<KeyWord name="codecs.Codec" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.CodecInfo" />
		<KeyWord name="codecs.CodecInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.CodecInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.EncodedFile" func="yes">
			<Overload retVal="" descr="Return a wrapped version of file which provides transparent&#10;encoding translation.&#10;&#10;Strings written to the wrapped file are interpreted according&#10;to the given data_encoding and then written to the original&#10;file as string using file_encoding. The intermediate encoding&#10;will usually be Unicode but depends on the specified codecs.&#10;&#10;Strings are read from the file using file_encoding and then&#10;passed back to the caller as string using data_encoding.&#10;&#10;If file_encoding is not given, it defaults to data_encoding.&#10;&#10;errors may be given to define the error handling. It defaults&#10;to 'strict' which causes ValueErrors to be raised in case an&#10;encoding error occurs.&#10;&#10;The returned wrapped file object provides two extra attributes&#10;.data_encoding and .file_encoding which reflect the given&#10;parameters of the same name. The attributes can be used for&#10;introspection by Python programs.">
				<Param name="file" />
				<Param name="data_encoding" />
				<Param name="[file_encoding=None" />
				<Param name="[errors=strict]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder" func="yes">
			<Overload retVal="" descr="An IncrementalDecoder decodes an input in multiple steps. The input can be&#10;passed piece by piece to the decode() method. The IncrementalDecoder&#10;remembers the state of the decoding process between calls to decode().">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.decode" func="yes">
			<Overload retVal="" descr="Decodes input and returns the resulting object.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.getstate" func="yes">
			<Overload retVal="" descr='Return the current state of the decoder.&#10;&#10;This must be a (buffered_input, additional_state_info) tuple.&#10;buffered_input must be a bytes object containing bytes that&#10;were passed to decode() that have not yet been converted.&#10;additional_state_info must be a non-negative integer&#10;representing the state of the decoder WITHOUT yet having&#10;processed the contents of buffered_input.  In the initial state&#10;and after reset(), getstate() must return (b"", 0).'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.reset" func="yes">
			<Overload retVal="" descr="Resets the decoder to the initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.setstate" func="yes">
			<Overload retVal="" descr='Set the current state of the decoder.&#10;&#10;state must have been returned by getstate().  The effect of&#10;setstate((b"", 0)) must be equivalent to reset().'>
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder" func="yes">
			<Overload retVal="" descr="An IncrementalEncoder encodes an input in multiple steps. The input can be&#10;passed piece by piece to the encode() method. The IncrementalEncoder remembers&#10;the state of the Encoding process between calls to encode().">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.encode" func="yes">
			<Overload retVal="" descr="Encodes input and returns the resulting object.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.getstate" func="yes">
			<Overload retVal="" descr="Return the current state of the encoder.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.reset" func="yes">
			<Overload retVal="" descr="Resets the encoder to the initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.setstate" func="yes">
			<Overload retVal="" descr="Set the current state of the encoder. state must have been&#10;returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.ascii_decode" />
		<KeyWord name="codecs.ascii_encode" />
		<KeyWord name="codecs.backslashreplace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'backslashreplace' error handling, which replaces an unencodable character with a backslashed escape sequence.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.charbuffer_encode" />
		<KeyWord name="codecs.charmap_build" />
		<KeyWord name="codecs.charmap_decode" />
		<KeyWord name="codecs.charmap_encode" />
		<KeyWord name="codecs.decode" func="yes">
			<Overload retVal="" descr="decode(obj, [encoding[,errors]]) -&gt; object&#10;&#10;Decodes obj using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a ValueError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle ValueErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.encode" func="yes">
			<Overload retVal="" descr="encode(obj, [encoding[,errors]]) -&gt; object&#10;&#10;Encodes obj using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a ValueError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle ValueErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.escape_decode" />
		<KeyWord name="codecs.escape_encode" />
		<KeyWord name="codecs.getdecoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its decoder function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getencoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its encoder function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getincrementaldecoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its IncrementalDecoder class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found&#10;or the codecs doesn't provide an incremental decoder.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getincrementalencoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its IncrementalEncoder class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found&#10;or the codecs doesn't provide an incremental encoder.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getreader" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its StreamReader class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getwriter" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its StreamWriter class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.ignore_errors" func="yes">
			<Overload retVal="" descr="Implements the 'ignore' error handling, which ignores malformed data and continues.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.iterdecode" func="yes">
			<Overload retVal="" descr="Decoding iterator.&#10;&#10;Decodes the input strings from the iterator using a IncrementalDecoder.&#10;&#10;errors and kwargs are passed through to the IncrementalDecoder&#10;constructor.">
				<Param name="iterator" />
				<Param name="encoding" />
				<Param name="[errors=strict" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.iterencode" func="yes">
			<Overload retVal="" descr="Encoding iterator.&#10;&#10;Encodes the input strings from the iterator using a IncrementalEncoder.&#10;&#10;errors and kwargs are passed through to the IncrementalEncoder&#10;constructor.">
				<Param name="iterator" />
				<Param name="encoding" />
				<Param name="[errors=strict" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.latin_1_decode" />
		<KeyWord name="codecs.latin_1_encode" />
		<KeyWord name="codecs.lookup" func="yes">
			<Overload retVal="" descr="lookup(encoding) -&gt; CodecInfo&#10;&#10;Looks up a codec tuple in the Python codec registry and returns&#10;a CodecInfo object.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.lookup_error" func="yes">
			<Overload retVal="" descr="lookup_error(errors) -&gt; handler&#10;&#10;Return the error handler for the specified error handling name&#10;or raise a LookupError, if no handler exists under this name.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.make_encoding_map" func="yes">
			<Overload retVal="" descr="Creates an encoding map from a decoding map.&#10;&#10;If a target mapping in the decoding map occurs multiple&#10;times, then that target is mapped to None (undefined mapping),&#10;causing an exception when encountered by the charmap codec&#10;during translation.&#10;&#10;One example where this happens is cp875.py which decodes&#10;multiple character to \u001a.">
				<Param name="decoding_map" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.make_identity_dict" func="yes">
			<Overload retVal="" descr="make_identity_dict(rng) -&gt; dict&#10;&#10;Return a dictionary where elements of the rng sequence are&#10;mapped to themselves.">
				<Param name="rng" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.mbcs_decode" />
		<KeyWord name="codecs.mbcs_encode" />
		<KeyWord name="codecs.open" func="yes">
			<Overload retVal="" descr="Open an encoded file using the given mode and return&#10;a wrapped version providing transparent encoding/decoding.&#10;&#10;Note: The wrapped version will only accept the object format&#10;defined by the codecs, i.e. Unicode objects for most builtin&#10;codecs. Output is also codec dependent and will usually be&#10;Unicode as well.&#10;&#10;Files are always opened in binary mode, even if no binary mode&#10;was specified. This is done to avoid data loss due to encodings&#10;using 8-bit values. The default file mode is 'rb' meaning to&#10;open the file in binary read mode.&#10;&#10;encoding specifies the encoding which is to be used for the&#10;file.&#10;&#10;errors may be given to define the error handling. It defaults&#10;to 'strict' which causes ValueErrors to be raised in case an&#10;encoding error occurs.&#10;&#10;buffering has the same meaning as for the builtin open() API.&#10;It defaults to line buffered.&#10;&#10;The returned wrapped file object provides an extra attribute&#10;.encoding which allows querying the used encoding. This&#10;attribute is only available if an encoding was specified as&#10;parameter.">
				<Param name="filename" />
				<Param name="[mode=rb" />
				<Param name="[encoding=None" />
				<Param name="[errors=strict" />
				<Param name="[buffering=1]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.raw_unicode_escape_decode" />
		<KeyWord name="codecs.raw_unicode_escape_encode" />
		<KeyWord name="codecs.readbuffer_encode" />
		<KeyWord name="codecs.register" func="yes">
			<Overload retVal="" descr="register(search_function)&#10;&#10;Register a codec search function. Search functions are expected to take&#10;one argument, the encoding name in all lower case letters, and return&#10;a tuple of functions (encoder, decoder, stream_reader, stream_writer)&#10;(or a CodecInfo object).">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.register_error" func="yes">
			<Overload retVal="" descr="register_error(errors, handler)&#10;&#10;Register the specified error handler under the name&#10;errors. handler must be a callable object, that&#10;will be called with an exception instance containing&#10;information about the location of the encoding/decoding&#10;error and must return a (replacement, new position) tuple.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.replace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'replace' error handling, which replaces malformed data with a replacement marker.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.strict_errors" func="yes">
			<Overload retVal="" descr="Implements the 'strict' error handling, which raises a UnicodeError on coding errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.unicode_escape_decode" />
		<KeyWord name="codecs.unicode_escape_encode" />
		<KeyWord name="codecs.unicode_internal_decode" />
		<KeyWord name="codecs.unicode_internal_encode" />
		<KeyWord name="codecs.utf_16_be_decode" />
		<KeyWord name="codecs.utf_16_be_encode" />
		<KeyWord name="codecs.utf_16_decode" />
		<KeyWord name="codecs.utf_16_encode" />
		<KeyWord name="codecs.utf_16_ex_decode" />
		<KeyWord name="codecs.utf_16_le_decode" />
		<KeyWord name="codecs.utf_16_le_encode" />
		<KeyWord name="codecs.utf_32_be_decode" />
		<KeyWord name="codecs.utf_32_be_encode" />
		<KeyWord name="codecs.utf_32_decode" />
		<KeyWord name="codecs.utf_32_encode" />
		<KeyWord name="codecs.utf_32_ex_decode" />
		<KeyWord name="codecs.utf_32_le_decode" />
		<KeyWord name="codecs.utf_32_le_encode" />
		<KeyWord name="codecs.utf_7_decode" />
		<KeyWord name="codecs.utf_7_encode" />
		<KeyWord name="codecs.utf_8_decode" />
		<KeyWord name="codecs.utf_8_encode" />
		<KeyWord name="codecs.xmlcharrefreplace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'xmlcharrefreplace' error handling, which replaces an unencodable character with the appropriate XML character reference.">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop" func="yes">
			<Overload retVal="" descr="Utilities to compile possibly incomplete Python source code.&#10;&#10;This module provides two interfaces, broadly similar to the builtin&#10;function compile(), which take program text, a filename and a 'mode'&#10;and:&#10;&#10;- Return code object if the command is complete and valid&#10;- Return None if the command is incomplete&#10;- Raise SyntaxError, ValueError or OverflowError if the command is a&#10;  syntax error (OverflowError and ValueError can be produced by&#10;  malformed literals).&#10;&#10;Approach:&#10;&#10;First, check if the source consists entirely of blank lines and&#10;comments; if so, replace it with 'pass', because the built-in&#10;parser doesn't always do the right thing for these.&#10;&#10;Compile three times: as is, with \n, and with \n\n appended.  If it&#10;compiles as is, it's complete.  If it compiles with one \n appended,&#10;we expect more.  If it doesn't compile either way, we compare the&#10;error we get when compiling with \n or \n\n appended.  If the errors&#10;are the same, the code is broken.  But if the errors are different, we&#10;expect more.  Not intuitive; not even guaranteed to hold in future&#10;releases; but this matches the compiler's behavior from Python 1.4&#10;through 2.2, at least.&#10;&#10;Caveat:&#10;&#10;It is possible (but not likely) that the parser stops parsing with a&#10;successful outcome before reaching the end of the source; in this&#10;case, trailing symbols may be ignored instead of causing an error.&#10;For example, a backslash followed by two newlines may be followed by&#10;arbitrary garbage.  This will be fixed once the API for the parser is&#10;better.&#10;&#10;The two interfaces are:&#10;&#10;compile_command(source, filename, symbol):&#10;&#10;    Compiles a single command in the manner described above.&#10;&#10;CommandCompiler():&#10;&#10;    Instances of this class have __call__ methods identical in&#10;    signature to compile_command; the difference is that if the&#10;    instance compiles program text containing a __future__ statement,&#10;    the instance 'remembers' and compiles all subsequent program texts&#10;    with the statement in force.&#10;&#10;The module also provides another class:&#10;&#10;Compile():&#10;&#10;    Instances of this class act like the built-in function compile,&#10;    but with 'memory' in the sense described above.">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.CommandCompiler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.Compile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.PyCF_DONT_IMPLY_DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.compile_command" func="yes">
			<Overload retVal="" descr='Compile a command and determine whether it is incomplete.&#10;&#10;Arguments:&#10;&#10;source -- the source string; may contain \n characters&#10;filename -- optional filename from which source was read; default&#10;            "&lt;input&gt;"&#10;symbol -- optional grammar start symbol; "single" (default) or "eval"&#10;&#10;Return value / exceptions raised:&#10;&#10;- Return a code object if the command is complete and valid&#10;- Return None if the command is incomplete&#10;- Raise SyntaxError, ValueError or OverflowError if the command is a&#10;  syntax error (OverflowError and ValueError can be produced by&#10;  malformed literals).'>
				<Param name="source" />
				<Param name="[filename=<input>" />
				<Param name="[symbol=single]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.fname" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="coerce" func="yes">
			<Overload retVal="" descr="coerce(x, y) -&gt; (x1, y1)&#10;&#10;Return a tuple consisting of the two numeric arguments converted to&#10;a common type, using the same rules as used by arithmetic operations.&#10;If coercion is not possible, raise TypeError.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections" />
		<KeyWord name="collections.Callable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Container" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter" func="yes">
			<Overload retVal="" descr="Dict subclass for counting hashable items.  Sometimes called a bag&#10;or multiset.  Elements are stored as dictionary keys and their counts&#10;are stored as dictionary values.&#10;&#10;&gt;&gt;&gt; c = Counter('abcdeabcdabcaba')  # count elements from a string&#10;&#10;&gt;&gt;&gt; c.most_common(3)                # three most common elements&#10;[('a', 5), ('b', 4), ('c', 3)]&#10;&gt;&gt;&gt; sorted(c)                       # list all unique elements&#10;['a', 'b', 'c', 'd', 'e']&#10;&gt;&gt;&gt; ''.join(sorted(c.elements()))   # list elements with repetitions&#10;'aaaaabbbbcccdde'&#10;&gt;&gt;&gt; sum(c.values())                 # total of all counts&#10;15&#10;&#10;&gt;&gt;&gt; c['a']                          # count of letter 'a'&#10;5&#10;&gt;&gt;&gt; for elem in 'shazam':           # update counts from an iterable&#10;...     c[elem] += 1                # by adding 1 to each element's count&#10;&gt;&gt;&gt; c['a']                          # now there are seven 'a'&#10;7&#10;&gt;&gt;&gt; del c['b']                      # remove all 'b'&#10;&gt;&gt;&gt; c['b']                          # now there are zero 'b'&#10;0&#10;&#10;&gt;&gt;&gt; d = Counter('simsalabim')       # make another counter&#10;&gt;&gt;&gt; c.update(d)                     # add in the second counter&#10;&gt;&gt;&gt; c['a']                          # now there are nine 'a'&#10;9&#10;&#10;&gt;&gt;&gt; c.clear()                       # empty the counter&#10;&gt;&gt;&gt; c&#10;Counter()&#10;&#10;Note:  If a count is set to zero or reduced to zero, it will remain&#10;in the counter until the entry is deleted or the counter is cleared:&#10;&#10;&gt;&gt;&gt; c = Counter('aaabbc')&#10;&gt;&gt;&gt; c['b'] -= 2                     # reduce the count of 'b' by two&#10;&gt;&gt;&gt; c.most_common()                 # 'b' is still in, but its count is zero&#10;[('a', 3), ('c', 1), ('b', 0)]">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.elements" func="yes">
			<Overload retVal="" descr="Iterator over elements repeating each as many times as its count.&#10;&#10;&gt;&gt;&gt; c = Counter('ABCABC')&#10;&gt;&gt;&gt; sorted(c.elements())&#10;['A', 'A', 'B', 'B', 'C', 'C']&#10;&#10;# Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1&#10;&gt;&gt;&gt; prime_factors = Counter({2: 2, 3: 3, 17: 1})&#10;&gt;&gt;&gt; product = 1&#10;&gt;&gt;&gt; for factor in prime_factors.elements():     # loop over factors&#10;...     product *= factor                       # and multiply them&#10;&gt;&gt;&gt; product&#10;1836&#10;&#10;Note, if an element's count has been set to zero or is a negative&#10;number, elements() will ignore it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.fromkeys" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="iterable" />
				<Param name="[v=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.most_common" func="yes">
			<Overload retVal="" descr="List the n most common elements and their counts from the most&#10;common to the least.  If n is None, then list all element counts.&#10;&#10;&gt;&gt;&gt; Counter('abcdeabcdabcaba').most_common(3)&#10;[('a', 5), ('b', 4), ('c', 3)]">
				<Param name="self" />
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.subtract" func="yes">
			<Overload retVal="" descr="Like dict.update() but subtracts counts instead of replacing them.&#10;Counts can be reduced below zero.  Both the inputs and outputs are&#10;allowed to contain zero and negative counts.&#10;&#10;Source can be an iterable, a dictionary, or another Counter instance.&#10;&#10;&gt;&gt;&gt; c = Counter('which')&#10;&gt;&gt;&gt; c.subtract('witch')             # subtract elements from another iterable&#10;&gt;&gt;&gt; c.subtract(Counter('watch'))    # subtract elements from another counter&#10;&gt;&gt;&gt; c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch&#10;0&#10;&gt;&gt;&gt; c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch&#10;-1">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.update" func="yes">
			<Overload retVal="" descr="Like dict.update() but add counts instead of replacing them.&#10;&#10;Source can be an iterable, a dictionary, or another Counter instance.&#10;&#10;&gt;&gt;&gt; c = Counter('which')&#10;&gt;&gt;&gt; c.update('witch')           # add elements from another iterable&#10;&gt;&gt;&gt; d = Counter('watch')&#10;&gt;&gt;&gt; c.update(d)                 # add elements from another counter&#10;&gt;&gt;&gt; c['h']                      # four 'h' in which, witch, and watch&#10;4">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Hashable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.ItemsView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Iterable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Iterator" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.KeysView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Mapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MappingView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MutableMapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MutableSequence" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MutableSet" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict" func="yes">
			<Overload retVal="" descr="Dictionary that remembers insertion order">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.clear" func="yes">
			<Overload retVal="" descr="od.clear() -&gt; None.  Remove all items from od.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.copy" func="yes">
			<Overload retVal="" descr="od.copy() -&gt; a shallow copy of od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.fromkeys" func="yes">
			<Overload retVal="" descr="OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.&#10;If not specified, the value defaults to None.">
				<Param name="cls" />
				<Param name="iterable" />
				<Param name="[value=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.items" func="yes">
			<Overload retVal="" descr="od.items() -&gt; list of (key, value) pairs in od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.iteritems" func="yes">
			<Overload retVal="" descr="od.iteritems -&gt; an iterator over the (key, value) pairs in od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.iterkeys" func="yes">
			<Overload retVal="" descr="od.iterkeys() -&gt; an iterator over the keys in od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.itervalues" func="yes">
			<Overload retVal="" descr="od.itervalues -&gt; an iterator over the values in od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.keys" func="yes">
			<Overload retVal="" descr="od.keys() -&gt; list of keys in od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.pop" func="yes">
			<Overload retVal="" descr="od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding&#10;value.  If key is not found, d is returned if given, otherwise KeyError&#10;is raised.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=<object object at 0x00000000024AA0B0>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.popitem" func="yes">
			<Overload retVal="" descr="od.popitem() -&gt; (k, v), return and remove a (key, value) pair.&#10;Pairs are returned in LIFO order if last is true or FIFO order if false.">
				<Param name="self" />
				<Param name="[last=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.setdefault" func="yes">
			<Overload retVal="" descr="od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from mapping/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k, v in F.items(): D[k] = v">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.values" func="yes">
			<Overload retVal="" descr="od.values() -&gt; list of values in od">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.viewitems" func="yes">
			<Overload retVal="" descr="od.viewitems() -&gt; a set-like object providing a view on od's items">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.viewkeys" func="yes">
			<Overload retVal="" descr="od.viewkeys() -&gt; a set-like object providing a view on od's keys">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.viewvalues" func="yes">
			<Overload retVal="" descr="od.viewvalues() -&gt; an object providing a view on od's values">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Sequence" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Set" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Sized" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.ValuesView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict" func="yes">
			<Overload retVal="" descr="defaultdict(default_factory[, ...]) --&gt; dict with default factory&#10;&#10;The default factory is called without arguments to produce&#10;a new value when a key is not present, in __getitem__ only.&#10;A defaultdict compares equal to a dict with the same items.&#10;All remaining arguments are treated the same as if they were&#10;passed to the dict constructor, including keyword arguments.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.default_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;Build an ordered collection with optimized access from its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
				<Param name="typename" />
				<Param name="field_names" />
				<Param name="[verbose=False" />
				<Param name="[rename=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="color" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="colormode" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="colormodel" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys" func="yes">
			<Overload retVal="" descr="Conversion functions between RGB and other color systems.&#10;&#10;This modules provides two functions for each color system ABC:&#10;&#10;  rgb_to_abc(r, g, b) --&gt; a, b, c&#10;  abc_to_rgb(a, b, c) --&gt; r, g, b&#10;&#10;All inputs and outputs are triples of floats in the range [0.0...1.0]&#10;(with the exception of I and Q, which covers a slightly larger range).&#10;Inputs outside the valid range may cause exceptions or invalid outputs.&#10;&#10;Supported color systems:&#10;RGB: Red, Green, Blue components&#10;YIQ: Luminance, Chrominance (used by composite video signals)&#10;HLS: Hue, Luminance, Saturation&#10;HSV: Hue, Saturation, Value">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.ONE_SIXTH" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.ONE_THIRD" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.TWO_THIRD" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.hls_to_rgb" />
		<KeyWord name="colorsys.hsv_to_rgb" />
		<KeyWord name="colorsys.rgb_to_hls" />
		<KeyWord name="colorsys.rgb_to_hsv" />
		<KeyWord name="colorsys.rgb_to_yiq" />
		<KeyWord name="colorsys.yiq_to_rgb" />
		<KeyWord name="columnconfigure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="combine" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="combining" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="commands" func="yes">
			<Overload retVal="" descr="Execute shell commands via os.popen() and return status, output.&#10;&#10;Interface summary:&#10;&#10;       import commands&#10;&#10;       outtext = commands.getoutput(cmd)&#10;       (exitstatus, outtext) = commands.getstatusoutput(cmd)&#10;       outtext = commands.getstatus(file)  # returns output of &quot;ls -ld file&quot;&#10;&#10;A trailing newline is removed from the output string.&#10;&#10;Encapsulates the basic operation:&#10;&#10;      pipe = os.popen('{ ' + cmd + '; } 2&gt;&amp;1', 'r')&#10;      text = pipe.read()&#10;      sts = pipe.close()&#10;&#10; [Note:  it would be nice to add functions to interpret the exit status.]">
			</Overload>
		</KeyWord>
		<KeyWord name="commands.getoutput" func="yes">
			<Overload retVal="" descr="Return output (stdout or stderr) of executing cmd in a shell.">
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="commands.getstatus" func="yes">
			<Overload retVal="" descr='Return output of "ls -ld &lt;file&gt;" in a string.'>
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="commands.getstatusoutput" func="yes">
			<Overload retVal="" descr="Return (status, output) of executing cmd in a shell.">
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="commands.mk2arg" />
		<KeyWord name="commands.mkarg" />
		<KeyWord name="commit" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="commonprefix" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="communicate" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="compact_traceback" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="compare" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_digest" func="yes">
			<Overload retVal="" descr="Function of hmac">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_signal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_total" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_total_mag" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="compile" func="yes">
			<Overload retVal="" descr="compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object&#10;&#10;Compile the source string (a Python module, statement or expression)&#10;into a code object that can be executed by the exec statement or eval().&#10;The filename will be used for run-time error messages.&#10;The mode must be 'exec' to compile a module, 'single' to compile a&#10;single (interactive) statement, or 'eval' to compile an expression.&#10;The flags argument, if present, controls which future statements influence&#10;the compilation of the code.&#10;The dont_inherit argument, if non-zero, stops the compilation inheriting&#10;the effects of any future statements in effect in the code calling&#10;compile; if absent or zero these statements do influence the compilation,&#10;in addition to any features explicitly specified.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileFile" func="yes">
			<Overload retVal="" descr="Function of compiler">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_command" func="yes">
			<Overload retVal="" descr="Function of codeop">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_dir" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_file" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_path" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall" func="yes">
			<Overload retVal="" descr="Module/script to byte-compile all .py files to .pyc (or .pyo) files.&#10;&#10;When called as a script with arguments, this compiles the directories&#10;given as arguments recursively; the -l option prevents it from&#10;recursing into directories.&#10;&#10;Without arguments, if compiles all modules on sys.path, without&#10;recursing into subdirectories.  (Even though it should do so for&#10;packages -- for now, you'll have to deal with packages separately.)&#10;&#10;See module py_compile for details of the actual byte-compilation.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.compile_dir" func="yes">
			<Overload retVal="" descr="Byte-compile all modules in the given directory tree.&#10;&#10;Arguments (only dir is required):&#10;&#10;dir:       the directory to byte-compile&#10;maxlevels: maximum recursion level (default 10)&#10;ddir:      the directory that will be prepended to the path to the&#10;           file as it is compiled into each byte-code file.&#10;force:     if 1, force compilation, even if timestamps are up-to-date&#10;quiet:     if 1, be quiet during compilation">
				<Param name="dir" />
				<Param name="[maxlevels=10" />
				<Param name="[ddir=None" />
				<Param name="[force=0" />
				<Param name="[rx=None" />
				<Param name="[quiet=0]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.compile_file" func="yes">
			<Overload retVal="" descr="Byte-compile one file.&#10;&#10;Arguments (only fullname is required):&#10;&#10;fullname:  the file to byte-compile&#10;ddir:      if given, the directory name compiled in to the&#10;           byte-code file.&#10;force:     if 1, force compilation, even if timestamps are up-to-date&#10;quiet:     if 1, be quiet during compilation">
				<Param name="fullname" />
				<Param name="[ddir=None" />
				<Param name="[force=0" />
				<Param name="[rx=None" />
				<Param name="[quiet=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.compile_path" func="yes">
			<Overload retVal="" descr="Byte-compile all module on sys.path.&#10;&#10;Arguments (all optional):&#10;&#10;skip_curdir: if true, skip current directory (default true)&#10;maxlevels:   max recursion level (default 0)&#10;force: as for compile_dir() (default 0)&#10;quiet: as for compile_dir() (default 0)">
				<Param name="[skip_curdir=1" />
				<Param name="[maxlevels=0" />
				<Param name="[force=0" />
				<Param name="[quiet=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.expand_args" func="yes">
			<Overload retVal="" descr="read names in flist and append to args">
				<Param name="args" />
				<Param name="flist" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.main" func="yes">
			<Overload retVal="" descr="Script main program.">
			</Overload>
		</KeyWord>
		<KeyWord name="compiler" func="yes">
			<Overload retVal="" descr='Package for parsing and compiling Python source code&#10;&#10;There are several functions defined at the top level that are imported&#10;from modules contained in the package.&#10;&#10;parse(buf, mode="exec") -&gt; AST&#10;    Converts a string containing Python source code to an abstract&#10;    syntax tree (AST).  The AST is defined in compiler.ast.&#10;&#10;parseFile(path) -&gt; AST&#10;    The same as parse(open(path))&#10;&#10;walk(ast, visitor, verbose=None)&#10;    Does a pre-order walk over the ast using the visitor instance.&#10;    See compiler.visitor for details.&#10;&#10;compile(source, filename, mode, flags=None, dont_inherit=None)&#10;    Returns a code object.  A replacement for the builtin compile() function.&#10;&#10;compileFile(filename)&#10;    Generates a .pyc file by compiling filename.'>
			</Overload>
		</KeyWord>
		<KeyWord name="compiler.compile" func="yes">
			<Overload retVal="" descr="Replacement for builtin compile() function">
				<Param name="source" />
				<Param name="filename" />
				<Param name="mode" />
				<Param name="[flags=None" />
				<Param name="[dont_inherit=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compiler.compileFile" func="yes">
			<Overload retVal="" descr=>
				<Param name="filename" />
				<Param name="[display=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compiler.parse" func="yes">
			<Overload retVal="" descr=>
				<Param name="buf" />
				<Param name="[mode=exec]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compiler.parseFile" />
		<KeyWord name="compiler.walk" func="yes">
			<Overload retVal="" descr=>
				<Param name="tree" />
				<Param name="visitor" />
				<Param name="[walker=None" />
				<Param name="[verbose=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="complete_statement" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="complex" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="compress" func="yes">
			<Overload retVal="" descr="Function of bz2">
			</Overload>
		</KeyWord>
		<KeyWord name="compression" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="config" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="config_dict" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="configure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="connect" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="connect_ex" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="constructor" func="yes">
			<Overload retVal="" descr="Function of copy_reg">
			</Overload>
		</KeyWord>
		<KeyWord name="context_diff" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib" func="yes">
			<Overload retVal="" descr="Utilities for with-statement contexts.  See PEP 343.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.GeneratorContextManager" func="yes">
			<Overload retVal="" descr="Helper for @contextmanager decorator.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.closing" func="yes">
			<Overload retVal="" descr="Context to automatically close something at the end of a block.&#10;&#10;Code like this:&#10;&#10;    with closing(&lt;module&gt;.open(&lt;arguments&gt;)) as f:&#10;        &lt;block&gt;&#10;&#10;is equivalent to this:&#10;&#10;    f = &lt;module&gt;.open(&lt;arguments&gt;)&#10;    try:&#10;        &lt;block&gt;&#10;    finally:&#10;        f.close()">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.contextmanager" func="yes">
			<Overload retVal="" descr="@contextmanager decorator.&#10;&#10;Typical usage:&#10;&#10;    @contextmanager&#10;    def some_generator(&lt;arguments&gt;):&#10;        &lt;setup&gt;&#10;        try:&#10;            yield &lt;value&gt;&#10;        finally:&#10;            &lt;cleanup&gt;&#10;&#10;This makes this:&#10;&#10;    with some_generator(&lt;arguments&gt;) as &lt;variable&gt;:&#10;        &lt;body&gt;&#10;&#10;equivalent to this:&#10;&#10;    &lt;setup&gt;&#10;    try:&#10;        &lt;variable&gt; = &lt;value&gt;&#10;        &lt;body&gt;&#10;    finally:&#10;        &lt;cleanup&gt;">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.nested" func="yes">
			<Overload retVal="" descr="Combine multiple context managers into a single nested context manager.&#10;&#10;This function has been deprecated in favour of the multiple manager form&#10;of the with statement.&#10;&#10;The one advantage of this function over the multiple manager form of the&#10;with statement is that argument unpacking allows it to be&#10;used with a variable number of context managers as follows:&#10;&#10;   with nested(*managers):&#10;       do_something()">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.wraps" func="yes">
			<Overload retVal="" descr="Decorator factory to apply update_wrapper() to a wrapper function&#10;&#10;Returns a decorator that invokes update_wrapper() with the decorated&#10;function as the wrapper argument and the arguments to wraps() as the&#10;remaining arguments. Default arguments are as for update_wrapper().&#10;This is a convenience function to simplify applying partial() to&#10;update_wrapper().">
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__doc__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="contextmanager" func="yes">
			<Overload retVal="" descr="Function of contextlib">
			</Overload>
		</KeyWord>
		<KeyWord name="continue" />
		<KeyWord name="convert_arg_line_to_args" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="convert_field" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="convert_path" func="yes">
			<Overload retVal="" descr="Function of FixTk">
			</Overload>
		</KeyWord>
		<KeyWord name="converter" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib" func="yes">
			<Overload retVal="" descr="HTTP cookie handling for web clients.&#10;&#10;This module has (now fairly distant) origins in Gisle Aas' Perl module&#10;HTTP::Cookies, from the libwww-perl library.&#10;&#10;Docstrings, comments and debug strings in this code refer to the&#10;attributes of the HTTP cookie system as cookie-attributes, to distinguish&#10;them clearly from Python attributes.&#10;&#10;Class diagram (note that BSDDBCookieJar and the MSIE* classes are not&#10;distributed with the Python standard library, but are available from&#10;http://wwwsearch.sf.net/):&#10;&#10;                        CookieJar____&#10;                        /     \      \&#10;            FileCookieJar      \      \&#10;             /    |   \         \      \&#10; MozillaCookieJar | LWPCookieJar \      \&#10;                  |               |      \&#10;                  |   ---MSIEBase |       \&#10;                  |  /      |     |        \&#10;                  | /   MSIEDBCookieJar BSDDBCookieJar&#10;                  |/&#10;               MSIECookieJar">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.Absent" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.Cookie" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.CookieJar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.CookiePolicy" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.DAYS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.DEFAULT_HTTP_PORT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.DefaultCookiePolicy" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.EPOCH_YEAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.ESCAPED_CHAR_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.FileCookieJar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.HEADER_ESCAPE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.HEADER_JOIN_ESCAPE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.HEADER_QUOTED_VALUE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.HEADER_TOKEN_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.HEADER_VALUE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.HTTP_PATH_SAFE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.IPV4_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.ISO_DATE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LOOSE_HTTP_DATE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LWPCookieJar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LoadError" />
		<KeyWord name="cookielib.LoadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LoadError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LoadError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LoadError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.LoadError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.MISSING_FILENAME_TEXT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.MONTHS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.MONTHS_LOWER" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.MozillaCookieJar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.STRICT_DATE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.TIMEZONE_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.UTC_ZONES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.WEEKDAY_RE" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.cut_port_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.deepvalues" func="yes">
			<Overload retVal="" descr="Iterates over nested mapping, depth-first, in sorted order by key.">
				<Param name="mapping" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.domain_match" func="yes">
			<Overload retVal="" descr="Return True if domain A domain-matches domain B, according to RFC 2965.&#10;&#10;A and B may be host domain names or IP addresses.&#10;&#10;RFC 2965, section 1:&#10;&#10;Host names can be specified either as an IP address or a HDN string.&#10;Sometimes we compare one host name with another.  (Such comparisons SHALL&#10;be case-insensitive.)  Host A's name domain-matches host B's if&#10;&#10;     *  their host name strings string-compare equal; or&#10;&#10;     * A is a HDN string and has the form NB, where N is a non-empty&#10;        name string, B has the form .B', and B' is a HDN string.  (So,&#10;        x.y.com domain-matches .Y.com but not Y.com.)&#10;&#10;Note that domain-match is not a commutative operation: a.b.c.com&#10;domain-matches .c.com, but not the reverse.">
				<Param name="A" />
				<Param name="B" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.eff_request_host" func="yes">
			<Overload retVal="" descr="Return a tuple (request-host, effective request-host name).&#10;&#10;As defined by RFC 2965, except both are lowercased.">
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.escape_path" func="yes">
			<Overload retVal="" descr="Escape any invalid characters in HTTP URL, and uppercase all escapes.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.http2time" func="yes">
			<Overload retVal="" descr='Returns time in seconds since epoch of time represented by a string.&#10;&#10;Return value is an integer.&#10;&#10;None is returned if the format of str is unrecognized, the time is outside&#10;the representable range, or the timezone string is not recognized.  If the&#10;string contains no timezone, UTC is assumed.&#10;&#10;The timezone in the string may be numerical (like "-0800" or "+0100") or a&#10;string timezone (like "UTC", "GMT", "BST" or "EST").  Currently, only the&#10;timezone strings equivalent to UTC (zero offset) are known to the function.&#10;&#10;The function loosely parses the following formats:&#10;&#10;Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format&#10;Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format&#10;Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format&#10;09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)&#10;08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)&#10;08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)&#10;&#10;The parser ignores leading and trailing whitespace.  The time may be&#10;absent.&#10;&#10;If the year is given with only 2 digits, the function will select the&#10;century that makes the year closest to the current date.'>
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.is_HDN" func="yes">
			<Overload retVal="" descr="Return True if text is a host domain name.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.is_third_party" func="yes">
			<Overload retVal="" descr="RFC 2965, section 3.3.6:&#10;&#10;    An unverifiable transaction is to a third-party host if its request-&#10;    host U does not domain-match the reach R of the request-host O in the&#10;    origin transaction.">
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.iso2time" func="yes">
			<Overload retVal="" descr="As for http2time, but parses the ISO 8601 formats:&#10;&#10;1994-02-03 14:15:29 -0100    -- ISO 8601 format&#10;1994-02-03 14:15:29          -- zone is optional&#10;1994-02-03                   -- only date&#10;1994-02-03T14:15:29          -- Use T as separator&#10;19940203T141529Z             -- ISO 8601 compact format&#10;19940203                     -- only date">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.join_header_words" func="yes">
			<Overload retVal="" descr="Do the inverse (almost) of the conversion done by split_header_words.&#10;&#10;Takes a list of lists of (key, value) pairs and produces a single header&#10;value.  Attribute values are quoted if needed.&#10;&#10;&gt;&gt;&gt; join_header_words([[(&quot;text/plain&quot;, None), (&quot;charset&quot;, &quot;iso-8859/1&quot;)]])&#10;'text/plain; charset=&quot;iso-8859/1&quot;'&#10;&gt;&gt;&gt; join_header_words([[(&quot;text/plain&quot;, None)], [(&quot;charset&quot;, &quot;iso-8859/1&quot;)]])&#10;'text/plain, charset=&quot;iso-8859/1&quot;'">
				<Param name="lists" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.liberal_is_HDN" func="yes">
			<Overload retVal="" descr="Return True if text is a sort-of-like a host domain name.&#10;&#10;For accepting/blocking domains.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.lwp_cookie_str" func="yes">
			<Overload retVal="" descr="Return string representation of Cookie in the LWP cookie file format.&#10;&#10;Actually, the format is extended a bit -- see module docstring.">
				<Param name="cookie" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.month" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.offset_from_tz_string" />
		<KeyWord name="cookielib.parse_ns_headers" func="yes">
			<Overload retVal="" descr="Ad-hoc parser for Netscape protocol cookie-attributes.&#10;&#10;The old Netscape cookie format for Set-Cookie can for instance contain&#10;an unquoted &quot;,&quot; in the expires field, so we have to use this ad-hoc&#10;parser instead of split_header_words.&#10;&#10;XXX This may not make the best possible effort to parse all the crap&#10;that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient&#10;parser is probably better, so could do worse than following that if&#10;this ever gives any trouble.&#10;&#10;Currently, this is also used for parsing RFC 2109 cookies.">
				<Param name="ns_headers" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.reach" func="yes">
			<Overload retVal="" descr="Return reach of host h, as defined by RFC 2965, section 1.&#10;&#10;The reach R of a host name H is defined as follows:&#10;&#10;   *  If&#10;&#10;      -  H is the host domain name of a host; and,&#10;&#10;      -  H has the form A.B; and&#10;&#10;      -  A has no embedded (that is, interior) dots; and&#10;&#10;      -  B has at least one embedded dot, or B is the string &quot;local&quot;.&#10;         then the reach of H is .B.&#10;&#10;   *  Otherwise, the reach of H is H.&#10;&#10;&gt;&gt;&gt; reach(&quot;www.acme.com&quot;)&#10;'.acme.com'&#10;&gt;&gt;&gt; reach(&quot;acme.com&quot;)&#10;'acme.com'&#10;&gt;&gt;&gt; reach(&quot;acme.local&quot;)&#10;'.local'">
				<Param name="h" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.request_host" func="yes">
			<Overload retVal="" descr="Return request-host, as defined by RFC 2965.&#10;&#10;Variation from RFC: returned value is lowercased, for convenient&#10;comparison.">
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.request_path" func="yes">
			<Overload retVal="" descr="Path component of request-URI, as defined by RFC 2965.">
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.request_port" />
		<KeyWord name="cookielib.split_header_words" func="yes">
			<Overload retVal="" descr="Parse header values into a list of lists containing key,value pairs.&#10;&#10;The function knows how to deal with &quot;,&quot;, &quot;;&quot; and &quot;=&quot; as well as quoted&#10;values after &quot;=&quot;.  A list of space separated tokens are parsed as if they&#10;were separated by &quot;;&quot;.&#10;&#10;If the header_values passed as argument contains multiple values, then they&#10;are treated as if they were a single value separated by comma &quot;,&quot;.&#10;&#10;This means that this function is useful for parsing header fields that&#10;follow this syntax (BNF as from the HTTP/1.1 specification, but we relax&#10;the requirement for tokens).&#10;&#10;  headers           = #header&#10;  header            = (token | parameter) *( [&quot;;&quot;] (token | parameter))&#10;&#10;  token             = 1*&lt;any CHAR except CTLs or separators&gt;&#10;  separators        = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;&#10;                    | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;&#10;                    | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;&#10;                    | &quot;{&quot; | &quot;}&quot; | SP | HT&#10;&#10;  quoted-string     = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )&#10;  qdtext            = &lt;any TEXT except &lt;&quot;&gt;&gt;&#10;  quoted-pair       = &quot;\&quot; CHAR&#10;&#10;  parameter         = attribute &quot;=&quot; value&#10;  attribute         = token&#10;  value             = token | quoted-string&#10;&#10;Each header is represented by a list of key/value pairs.  The value for a&#10;simple token (not part of a parameter) is None.  Syntactically incorrect&#10;headers will not necessarily be parsed as you would want.&#10;&#10;This is easier to describe with some examples:&#10;&#10;&gt;&gt;&gt; split_header_words(['foo=&quot;bar&quot;; port=&quot;80,81&quot;; discard, bar=baz'])&#10;[[('foo', 'bar'), ('port', '80,81'), ('discard', None)], [('bar', 'baz')]]&#10;&gt;&gt;&gt; split_header_words(['text/html; charset=&quot;iso-8859-1&quot;'])&#10;[[('text/html', None), ('charset', 'iso-8859-1')]]&#10;&gt;&gt;&gt; split_header_words([r'Basic realm=&quot;\&quot;foo\bar\&quot;&quot;'])&#10;[[('Basic', None), ('realm', '&quot;foobar&quot;')]]">
				<Param name="header_values" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.time2isoz" func="yes">
			<Overload retVal="" descr='Return a string representing time in seconds since epoch, t.&#10;&#10;If the function is called without an argument, it will use the current&#10;time.&#10;&#10;The format of the returned string is like "YYYY-MM-DD hh:mm:ssZ",&#10;representing Universal Time (UTC, aka GMT).  An example of this format is:&#10;&#10;1994-11-24 08:49:37Z'>
				<Param name="[t=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.time2netscape" func="yes">
			<Overload retVal="" descr="Return a string representing time in seconds since epoch, t.&#10;&#10;If the function is called without an argument, it will use the current&#10;time.&#10;&#10;The format of the returned string is like this:&#10;&#10;Wed, DD-Mon-YYYY HH:MM:SS GMT">
				<Param name="[t=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.unmatched" func="yes">
			<Overload retVal="" descr="Return unmatched part of re.Match object.">
				<Param name="match" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.uppercase_escaped_char" />
		<KeyWord name="cookielib.user_domain_match" func="yes">
			<Overload retVal="" descr="For blocking/accepting domains.&#10;&#10;A and B may be host domain names or IP addresses.">
				<Param name="A" />
				<Param name="B" />
			</Overload>
		</KeyWord>
		<KeyWord name="cookielib.vals_sorted_by_key" />
		<KeyWord name="copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.Error" />
		<KeyWord name="copy.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.copy" func="yes">
			<Overload retVal="" descr="Shallow copy operation on arbitrary Python objects.&#10;&#10;See the module's __doc__ string for more info.">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy.deepcopy" func="yes">
			<Overload retVal="" descr="Deep copy operation on arbitrary Python objects.&#10;&#10;See the module's __doc__ string for more info.">
				<Param name="x" />
				<Param name="[memo=None" />
				<Param name="[_nil=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy.dispatch_table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.error" />
		<KeyWord name="copy.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t" func="yes">
			<Overload retVal="" descr="set() -&gt; new empty set object&#10;set(iterable) -&gt; new set object&#10;&#10;Build an unordered collection of unique elements.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.add" func="yes">
			<Overload retVal="" descr="Add an element to a set.&#10;&#10;This has no effect if the element is already present.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.difference" func="yes">
			<Overload retVal="" descr="Return the difference of two or more sets as a new set.&#10;&#10;(i.e. all elements that are in this set but not the others.)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.difference_update" func="yes">
			<Overload retVal="" descr="Remove all elements of another set from this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.discard" func="yes">
			<Overload retVal="" descr="Remove an element from a set if it is a member.&#10;&#10;If the element is not a member, do nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.intersection" func="yes">
			<Overload retVal="" descr="Return the intersection of two or more sets as a new set.&#10;&#10;(i.e. elements that are common to all of the sets.)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.intersection_update" func="yes">
			<Overload retVal="" descr="Update a set with the intersection of itself and another.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.isdisjoint" func="yes">
			<Overload retVal="" descr="Return True if two sets have a null intersection.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.issubset" func="yes">
			<Overload retVal="" descr="Report whether another set contains this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.issuperset" func="yes">
			<Overload retVal="" descr="Report whether this set contains another set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.pop" func="yes">
			<Overload retVal="" descr="Remove and return an arbitrary set element.&#10;Raises KeyError if the set is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.remove" func="yes">
			<Overload retVal="" descr="Remove an element from a set; it must be a member.&#10;&#10;If the element is not a member, raise a KeyError.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.symmetric_difference" func="yes">
			<Overload retVal="" descr="Return the symmetric difference of two sets as a new set.&#10;&#10;(i.e. all elements that are in exactly one of the sets.)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.symmetric_difference_update" func="yes">
			<Overload retVal="" descr="Update a set with the symmetric difference of itself and another.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.union" func="yes">
			<Overload retVal="" descr="Return the union of sets as a new set.&#10;&#10;(i.e. all elements that are in either set.)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.t.update" func="yes">
			<Overload retVal="" descr="Update a set with the union of itself and others.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy2" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_abs" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_decimal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_location" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_negate" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_reg" func="yes">
			<Overload retVal="" descr="Helper to provide extensibility for pickle/cPickle.&#10;&#10;This is only useful to add pickle support for extension types defined in&#10;C, not for instances of user-defined classes.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_reg.add_extension" func="yes">
			<Overload retVal="" descr="Register an extension code.">
				<Param name="module" />
				<Param name="name" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy_reg.clear_extension_cache" />
		<KeyWord name="copy_reg.constructor" />
		<KeyWord name="copy_reg.dispatch_table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_reg.pickle" func="yes">
			<Overload retVal="" descr=>
				<Param name="ob_type" />
				<Param name="pickle_function" />
				<Param name="[constructor_ob=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy_reg.pickle_complex" />
		<KeyWord name="copy_reg.remove_extension" func="yes">
			<Overload retVal="" descr="Unregister an extension code.  For testing only.">
				<Param name="module" />
				<Param name="name" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy_sign" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="copybinary" func="yes">
			<Overload retVal="" descr="Function of mimetools">
			</Overload>
		</KeyWord>
		<KeyWord name="copyfile" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copyfileobj" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copyliteral" func="yes">
			<Overload retVal="" descr="Function of mimetools">
			</Overload>
		</KeyWord>
		<KeyWord name="copymode" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copysign" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="copystat" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copytree" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="cos" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="cosh" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="countTestCases" func="yes">
			<Overload retVal="" descr="Function of unittest.BaseTestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="count_calls" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="cpu_count" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="cram" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="crc32" func="yes">
			<Overload retVal="" descr="Function of zipfile">
			</Overload>
		</KeyWord>
		<KeyWord name="createLock" func="yes">
			<Overload retVal="" descr="Function of logging.NullHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="createTests" func="yes">
			<Overload retVal="" descr="Function of unittest.main">
			</Overload>
		</KeyWord>
		<KeyWord name="create_aggregate" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="create_collation" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="create_connection" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="create_decimal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="create_decimal_from_float" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="create_default_context" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="create_function" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="create_gnu_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="create_pax_global_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="create_pax_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="create_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="create_string_buffer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="create_unicode_buffer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="create_ustar_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="critical" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="csv" func="yes">
			<Overload retVal="" descr="CSV parsing and writing.&#10;&#10;This module provides classes that assist in the reading and writing&#10;of Comma Separated Value (CSV) files, and implements the interface&#10;described by PEP 305.  Although many CSV files are simple to parse,&#10;the format is not formally defined by a stable specification and&#10;is subtle enough that parsing lines of a CSV file with something&#10;like line.split(&quot;,&quot;) is bound to fail.  The module supports three&#10;basic APIs: reading, writing, and registration of dialects.&#10;&#10;&#10;DIALECT REGISTRATION:&#10;&#10;Readers and writers support a dialect argument, which is a convenient&#10;handle on a group of settings.  When the dialect argument is a string,&#10;it identifies one of the dialects previously registered with the module.&#10;If it is a class or instance, the attributes of the argument are used as&#10;the settings for the reader or writer:&#10;&#10;    class excel:&#10;        delimiter = ','&#10;        quotechar = '&quot;'&#10;        escapechar = None&#10;        doublequote = True&#10;        skipinitialspace = False&#10;        lineterminator = '\r\n'&#10;        quoting = QUOTE_MINIMAL&#10;&#10;SETTINGS:&#10;&#10;    * quotechar - specifies a one-character string to use as the &#10;        quoting character.  It defaults to '&quot;'.&#10;    * delimiter - specifies a one-character string to use as the &#10;        field separator.  It defaults to ','.&#10;    * skipinitialspace - specifies how to interpret whitespace which&#10;        immediately follows a delimiter.  It defaults to False, which&#10;        means that whitespace immediately following a delimiter is part&#10;        of the following field.&#10;    * lineterminator -  specifies the character sequence which should &#10;        terminate rows.&#10;    * quoting - controls when quotes should be generated by the writer.&#10;        It can take on any of the following module constants:&#10;&#10;        csv.QUOTE_MINIMAL means only when required, for example, when a&#10;            field contains either the quotechar or the delimiter&#10;        csv.QUOTE_ALL means that quotes are always placed around fields.&#10;        csv.QUOTE_NONNUMERIC means that quotes are always placed around&#10;            fields which do not parse as integers or floating point&#10;            numbers.&#10;        csv.QUOTE_NONE means that quotes are never placed around fields.&#10;    * escapechar - specifies a one-character string used to escape &#10;        the delimiter when quoting is set to QUOTE_NONE.&#10;    * doublequote - controls the handling of quotes inside fields.  When&#10;        True, two consecutive quotes are interpreted as one during read,&#10;        and when writing, each quote character embedded in the data is&#10;        written as two quotes">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Dialect" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.DictReader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.DictWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Error" />
		<KeyWord name="csv.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.QUOTE_ALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.QUOTE_NONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.QUOTE_NONNUMERIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Sniffer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel_tab" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.field_size_limit" func="yes">
			<Overload retVal="" descr="Sets an upper limit on parsed fields.&#10;    csv.field_size_limit([limit])&#10;&#10;Returns old limit. If limit is not given, no new limit is set and&#10;the old limit is returned">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.get_dialect" func="yes">
			<Overload retVal="" descr="Return the dialect instance associated with name.&#10;dialect = csv.get_dialect(name)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.list_dialects" func="yes">
			<Overload retVal="" descr="Return a list of all know dialect names.&#10;names = csv.list_dialects()">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.reader" func="yes">
			<Overload retVal="" descr="csv_reader = reader(iterable [, dialect='excel']&#10;                        [optional keyword args])&#10;    for row in csv_reader:&#10;        process(row)&#10;&#10;The &quot;iterable&quot; argument can be any object that returns a line&#10;of input for each iteration, such as a file object or a list.  The&#10;optional &quot;dialect&quot; parameter is discussed below.  The function&#10;also accepts optional keyword arguments which override settings&#10;provided by the dialect.&#10;&#10;The returned object is an iterator.  Each iteration returns a row&#10;of the CSV file (which can span multiple input lines):">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.reduce" func="yes">
			<Overload retVal="" descr="reduce(function, sequence[, initial]) -&gt; value&#10;&#10;Apply a function of two arguments cumulatively to the items of a sequence,&#10;from left to right, so as to reduce the sequence to a single value.&#10;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#10;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#10;of the sequence in the calculation, and serves as a default when the&#10;sequence is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.register_dialect" func="yes">
			<Overload retVal="" descr="Create a mapping from a string name to a dialect class.&#10;dialect = csv.register_dialect(name, dialect)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unregister_dialect" func="yes">
			<Overload retVal="" descr="Delete the name/dialect mapping associated with a string name.&#10;csv.unregister_dialect(name)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.writer" func="yes">
			<Overload retVal="" descr="csv_writer = csv.writer(fileobj [, dialect='excel']&#10;                            [optional keyword args])&#10;    for row in sequence:&#10;        csv_writer.writerow(row)&#10;&#10;    [or]&#10;&#10;    csv_writer = csv.writer(fileobj [, dialect='excel']&#10;                            [optional keyword args])&#10;    csv_writer.writerows(rows)&#10;&#10;The &quot;fileobj&quot; argument can be any object that supports the file API.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctime" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes" func="yes">
			<Overload retVal="" descr="create and manipulate C data types in Python">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.ARRAY" />
		<KeyWord name="ctypes.ArgumentError" />
		<KeyWord name="ctypes.ArgumentError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.ArgumentError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.Array" func="yes">
			<Overload retVal="" descr="(PyCArrayType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.BigEndianStructure" func="yes">
			<Overload retVal="" descr="(_swapped_meta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.CDLL" func="yes">
			<Overload retVal="" descr="An instance of this class represents a loaded dll/shared&#10;library, exporting functions using the standard C calling&#10;convention (named 'cdecl' on Windows).&#10;&#10;The exported functions can be accessed as attributes, or by&#10;indexing with the function name.  Examples:&#10;&#10;&lt;obj&gt;.qsort -&gt; callable object&#10;&lt;obj&gt;['qsort'] -&gt; callable object&#10;&#10;Calling the functions releases the Python GIL during the call and&#10;reacquires it afterwards.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.CFUNCTYPE" func="yes">
			<Overload retVal="" descr="CFUNCTYPE(restype, *argtypes,&#10;             use_errno=False, use_last_error=False) -&gt; function prototype.&#10;&#10;restype: the result type&#10;argtypes: a sequence specifying the argument types&#10;&#10;The function prototype can be called in different ways to create a&#10;callable object:&#10;&#10;prototype(integer address) -&gt; foreign function&#10;prototype(callable) -&gt; create and return a C callable function from callable&#10;prototype(integer index, method name[, paramflags]) -&gt; foreign function calling a COM method&#10;prototype((ordinal number, dll object)[, paramflags]) -&gt; foreign function exported by ordinal&#10;prototype((function name, dll object)[, paramflags]) -&gt; foreign function exported by name">
				<Param name="restype" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.DllCanUnloadNow" />
		<KeyWord name="ctypes.DllGetClassObject" />
		<KeyWord name="ctypes.FormatError" func="yes">
			<Overload retVal="" descr="FormatError([integer]) -&gt; string&#10;&#10;Convert a win32 error code into a string. If the error code is not&#10;given, the return value of a call to GetLastError() is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.GetLastError" func="yes">
			<Overload retVal="" descr="(_FuncPtr)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.HRESULT" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.LibraryLoader" />
		<KeyWord name="ctypes.LibraryLoader.LoadLibrary" />
		<KeyWord name="ctypes.LittleEndianStructure" func="yes">
			<Overload retVal="" descr="(PyCStructType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.OleDLL" func="yes">
			<Overload retVal="" descr="This class represents a dll exporting functions using the&#10;Windows stdcall calling convention, and returning HRESULT.&#10;HRESULT error values are automatically raised as WindowsError&#10;exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.POINTER" />
		<KeyWord name="ctypes.PYFUNCTYPE" />
		<KeyWord name="ctypes.PyDLL" func="yes">
			<Overload retVal="" descr="This class represents the Python library itself.  It allows to&#10;access Python API functions.  The GIL is not released, and&#10;Python exceptions are handled correctly.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.SetPointerType" />
		<KeyWord name="ctypes.Structure" func="yes">
			<Overload retVal="" descr="(PyCStructType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.Union" func="yes">
			<Overload retVal="" descr="(UnionType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.WINFUNCTYPE" func="yes">
			<Overload retVal="" descr=>
				<Param name="restype" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.WinDLL" func="yes">
			<Overload retVal="" descr="This class represents a dll exporting functions using the&#10;Windows stdcall calling convention.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.WinError" func="yes">
			<Overload retVal="" descr=>
				<Param name="[code=None" />
				<Param name="[descr=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.addressof" func="yes">
			<Overload retVal="" descr="addressof(C instance) -&gt; integer&#10;Return the address of the C instance internal buffer">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.alignment" func="yes">
			<Overload retVal="" descr="alignment(C type) -&gt; integer&#10;alignment(C instance) -&gt; integer&#10;Return the alignment requirements of a C instance">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.byref" func="yes">
			<Overload retVal="" descr="byref(C instance[, offset=0]) -&gt; byref-object&#10;Return a pointer lookalike to a C instance, only usable&#10;as function argument">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_bool" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_buffer" func="yes">
			<Overload retVal="" descr=>
				<Param name="init" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_byte" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_char" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_char_p" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_double" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_float" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int16" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int32" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int64" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int8" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_long" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_longdouble" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_longlong" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_short" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_size_t" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ssize_t" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ubyte" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint16" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint32" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint64" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint8" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ulong" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ulonglong" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ushort" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_void_p" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_voidp" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_wchar" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_wchar_p" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.cast" />
		<KeyWord name="ctypes.cdll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.create_string_buffer" func="yes">
			<Overload retVal="" descr="create_string_buffer(aString) -&gt; character array&#10;create_string_buffer(anInteger) -&gt; character array&#10;create_string_buffer(aString, anInteger) -&gt; character array">
				<Param name="init" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.create_unicode_buffer" func="yes">
			<Overload retVal="" descr="create_unicode_buffer(aString) -&gt; character array&#10;create_unicode_buffer(anInteger) -&gt; character array&#10;create_unicode_buffer(aString, anInteger) -&gt; character array">
				<Param name="init" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.get_errno" />
		<KeyWord name="ctypes.get_last_error" />
		<KeyWord name="ctypes.memmove" func="yes">
			<Overload retVal="" descr="(CFunctionType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.memset" func="yes">
			<Overload retVal="" descr="(CFunctionType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.oledll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.pointer" />
		<KeyWord name="ctypes.py_object" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.pydll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.pythonapi" func="yes">
			<Overload retVal="" descr="(PyDLL)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.resize" func="yes">
			<Overload retVal="" descr="Resize the memory buffer of a ctypes instance">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.set_conversion_mode" func="yes">
			<Overload retVal="" descr="set_conversion_mode(encoding, errors) -&gt; (previous-encoding, previous-errors)&#10;&#10;Set the encoding and error handling ctypes uses when converting&#10;between unicode and strings.  Returns the previous values.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.set_errno" />
		<KeyWord name="ctypes.set_last_error" />
		<KeyWord name="ctypes.sizeof" func="yes">
			<Overload retVal="" descr="sizeof(C type) -&gt; integer&#10;sizeof(C instance) -&gt; integer&#10;Return the size in bytes of a C instance">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.string_at" func="yes">
			<Overload retVal="" descr="string_at(addr[, size]) -&gt; string&#10;&#10;Return the string at addr.">
				<Param name="ptr" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.windll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.wstring_at" func="yes">
			<Overload retVal="" descr="wstring_at(addr[, size]) -&gt; string&#10;&#10;Return the string at addr.">
				<Param name="ptr" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="currency" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="currentThread" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="current_process" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="current_thread" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="currentframe" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="cursor" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="date" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="dbhash" func="yes">
			<Overload retVal="" descr="Provide a (g)dbm-compatible interface to bsddb.hashopen.">
			</Overload>
		</KeyWord>
		<KeyWord name="dbhash.error" />
		<KeyWord name="dbhash.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dbhash.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dbhash.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="[flag=r" />
				<Param name="[mode=438]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="debug" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="debug_script" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="debug_src" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal" func="yes">
			<Overload retVal="" descr="This is a Py2.3 implementation of decimal floating point arithmetic based on&#10;the General Decimal Arithmetic Specification:&#10;&#10;    http://speleotrove.com/decimal/decarith.html&#10;&#10;and IEEE standard 854-1987:&#10;&#10;    http://en.wikipedia.org/wiki/IEEE_854-1987&#10;&#10;Decimal floating point has finite precision with arbitrarily large bounds.&#10;&#10;The purpose of this module is to support arithmetic using familiar&#10;&quot;schoolhouse&quot; rules and to avoid some of the tricky representation&#10;issues associated with binary floating point.  The package is especially&#10;useful for financial applications or for contexts where users have&#10;expectations that are at odds with binary floating point (for instance,&#10;in binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead&#10;of the expected Decimal('0.00') returned by decimal floating point).&#10;&#10;Here are some examples of using the decimal module:&#10;&#10;&gt;&gt;&gt; from decimal import *&#10;&gt;&gt;&gt; setcontext(ExtendedContext)&#10;&gt;&gt;&gt; Decimal(0)&#10;Decimal('0')&#10;&gt;&gt;&gt; Decimal('1')&#10;Decimal('1')&#10;&gt;&gt;&gt; Decimal('-.0123')&#10;Decimal('-0.0123')&#10;&gt;&gt;&gt; Decimal(123456)&#10;Decimal('123456')&#10;&gt;&gt;&gt; Decimal('123.45e12345678901234567890')&#10;Decimal('1.2345E+12345678901234567892')&#10;&gt;&gt;&gt; Decimal('1.33') + Decimal('1.27')&#10;Decimal('2.60')&#10;&gt;&gt;&gt; Decimal('12.34') + Decimal('3.87') - Decimal('18.41')&#10;Decimal('-2.20')&#10;&gt;&gt;&gt; dig = Decimal(1)&#10;&gt;&gt;&gt; print dig / Decimal(3)&#10;0.333333333&#10;&gt;&gt;&gt; getcontext().prec = 18&#10;&gt;&gt;&gt; print dig / Decimal(3)&#10;0.333333333333333333&#10;&gt;&gt;&gt; print dig.sqrt()&#10;1&#10;&gt;&gt;&gt; print Decimal(3).sqrt()&#10;1.73205080756887729&#10;&gt;&gt;&gt; print Decimal(3) ** 123&#10;4.85192780976896427E+58&#10;&gt;&gt;&gt; inf = Decimal(1) / Decimal(0)&#10;&gt;&gt;&gt; print inf&#10;Infinity&#10;&gt;&gt;&gt; neginf = Decimal(-1) / Decimal(0)&#10;&gt;&gt;&gt; print neginf&#10;-Infinity&#10;&gt;&gt;&gt; print neginf + inf&#10;NaN&#10;&gt;&gt;&gt; print neginf * inf&#10;-Infinity&#10;&gt;&gt;&gt; print dig / 0&#10;Infinity&#10;&gt;&gt;&gt; getcontext().traps[DivisionByZero] = 1&#10;&gt;&gt;&gt; print dig / 0&#10;Traceback (most recent call last):&#10;  ...&#10;  ...&#10;  ...&#10;DivisionByZero: x / 0&#10;&gt;&gt;&gt; c = Context()&#10;&gt;&gt;&gt; c.traps[InvalidOperation] = 0&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;0&#10;&gt;&gt;&gt; c.divide(Decimal(0), Decimal(0))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; c.traps[InvalidOperation] = 1&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;1&#10;&gt;&gt;&gt; c.flags[InvalidOperation] = 0&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;0&#10;&gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))&#10;Traceback (most recent call last):&#10;  ...&#10;  ...&#10;  ...&#10;InvalidOperation: 0 / 0&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;1&#10;&gt;&gt;&gt; c.flags[InvalidOperation] = 0&#10;&gt;&gt;&gt; c.traps[InvalidOperation] = 0&#10;&gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))&#10;NaN&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;1&#10;&gt;&gt;&gt;">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.BasicContext" func="yes">
			<Overload retVal="" descr="(Context)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Clamped" func="yes">
			<Overload retVal="" descr='Exponent of a 0 changed to fit bounds.&#10;&#10;This occurs and signals clamped if the exponent of a result has been&#10;altered in order to fit the constraints of a specific concrete&#10;representation.  This may occur when the exponent of a zero result would&#10;be outside the bounds of a representation, or when a large normal&#10;number would have an encoded exponent that cannot be represented.  In&#10;this latter case, the exponent is reduced to fit and the corresponding&#10;number of zero digits are appended to the coefficient ("fold-down").'>
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Clamped.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Clamped.handle" />
		<KeyWord name="decimal.Clamped.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context" func="yes">
			<Overload retVal="" descr="Contains the context for a Decimal instance.&#10;&#10;Contains:&#10;prec - precision (for use in rounding, division, square roots..)&#10;rounding - rounding type (how you round)&#10;traps - If traps[exception] = 1, then the exception is&#10;                raised when it is caused.  Otherwise, a value is&#10;                substituted in.&#10;flags  - When an exception is caused, flags[exception] is set.&#10;         (Whether or not the trap_enabler is set)&#10;         Should be reset by user of Decimal instance.&#10;Emin -   Minimum exponent&#10;Emax -   Maximum exponent&#10;capitals -      If 1, 1*10^1 is printed as 1E+1.&#10;                If 0, printed as 1e1&#10;_clamp - If 1, change exponents if too high (Default 0)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.Etiny" func="yes">
			<Overload retVal="" descr="Returns Etiny (= Emin - prec + 1)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.Etop" func="yes">
			<Overload retVal="" descr="Returns maximum exponent (= Emax - prec + 1)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.abs" func="yes">
			<Overload retVal="" descr="Returns the absolute value of the operand.&#10;&#10;If the operand is negative, the result is the same as using the minus&#10;operation on the operand.  Otherwise, the result is the same as using&#10;the plus operation on the operand.&#10;&#10;&gt;&gt;&gt; ExtendedContext.abs(Decimal('2.1'))&#10;Decimal('2.1')&#10;&gt;&gt;&gt; ExtendedContext.abs(Decimal('-100'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.abs(Decimal('101.5'))&#10;Decimal('101.5')&#10;&gt;&gt;&gt; ExtendedContext.abs(Decimal('-101.5'))&#10;Decimal('101.5')&#10;&gt;&gt;&gt; ExtendedContext.abs(-1)&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.add" func="yes">
			<Overload retVal="" descr="Return the sum of the two operands.&#10;&#10;&gt;&gt;&gt; ExtendedContext.add(Decimal('12'), Decimal('7.00'))&#10;Decimal('19.00')&#10;&gt;&gt;&gt; ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))&#10;Decimal('1.02E+4')&#10;&gt;&gt;&gt; ExtendedContext.add(1, Decimal(2))&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.add(Decimal(8), 5)&#10;Decimal('13')&#10;&gt;&gt;&gt; ExtendedContext.add(5, 5)&#10;Decimal('10')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.canonical" func="yes">
			<Overload retVal="" descr="Returns the same Decimal object.&#10;&#10;As we do not have different encodings for the same number, the&#10;received object already is in its canonical form.&#10;&#10;&gt;&gt;&gt; ExtendedContext.canonical(Decimal('2.50'))&#10;Decimal('2.50')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.clear_flags" func="yes">
			<Overload retVal="" descr="Reset all flags to zero">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare" func="yes">
			<Overload retVal="" descr="Compares values numerically.&#10;&#10;If the signs of the operands differ, a value representing each operand&#10;('-1' if the operand is less than zero, '0' if the operand is zero or&#10;negative zero, or '1' if the operand is greater than zero) is used in&#10;place of that operand for the comparison instead of the actual&#10;operand.&#10;&#10;The comparison is then effected by subtracting the second operand from&#10;the first and then returning a value according to the result of the&#10;subtraction: '-1' if the result is less than zero, '0' if the result is&#10;zero or negative zero, or '1' if the result is greater than zero.&#10;&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('3'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal('3'), Decimal('2.1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare(1, 2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare(Decimal(1), 2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare(1, Decimal(2))&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare_signal" func="yes">
			<Overload retVal="" descr="Compares the values of the two operands numerically.&#10;&#10;It's pretty much like compare(), but all NaNs signal, with signaling&#10;NaNs taking precedence over quiet NaNs.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext&#10;&gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('3'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('2.1'))&#10;Decimal('0')&#10;&gt;&gt;&gt; c.flags[InvalidOperation] = 0&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;0&#10;&gt;&gt;&gt; c.compare_signal(Decimal('NaN'), Decimal('2.1'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;1&#10;&gt;&gt;&gt; c.flags[InvalidOperation] = 0&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;0&#10;&gt;&gt;&gt; c.compare_signal(Decimal('sNaN'), Decimal('2.1'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; print c.flags[InvalidOperation]&#10;1&#10;&gt;&gt;&gt; c.compare_signal(-1, 2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; c.compare_signal(Decimal(-1), 2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; c.compare_signal(-1, Decimal(2))&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare_total" func="yes">
			<Overload retVal="" descr="Compares two operands using their abstract representation.&#10;&#10;This is not like the standard compare, which use their numerical&#10;value. Note that a total ordering is defined for all possible abstract&#10;representations.&#10;&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(1, 2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(Decimal(1), 2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.compare_total(1, Decimal(2))&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compares two operands using their abstract representation ignoring sign.&#10;&#10;Like compare_total, but with operand's sign ignored and assumed to be 0.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy" func="yes">
			<Overload retVal="" descr="Returns a deep copy from self.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_abs" func="yes">
			<Overload retVal="" descr="Returns a copy of the operand with the sign set to 0.&#10;&#10;&gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('2.1'))&#10;Decimal('2.1')&#10;&gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('-100'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.copy_abs(-1)&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_decimal" func="yes">
			<Overload retVal="" descr="Returns a copy of the decimal object.&#10;&#10;&gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('2.1'))&#10;Decimal('2.1')&#10;&gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('-1.00'))&#10;Decimal('-1.00')&#10;&gt;&gt;&gt; ExtendedContext.copy_decimal(1)&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_negate" func="yes">
			<Overload retVal="" descr="Returns a copy of the operand with the sign inverted.&#10;&#10;&gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('101.5'))&#10;Decimal('-101.5')&#10;&gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('-101.5'))&#10;Decimal('101.5')&#10;&gt;&gt;&gt; ExtendedContext.copy_negate(1)&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_sign" func="yes">
			<Overload retVal="" descr="Copies the second operand's sign to the first one.&#10;&#10;In detail, it returns a copy of the first operand with the sign&#10;equal to the sign of the second operand.&#10;&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))&#10;Decimal('1.50')&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))&#10;Decimal('1.50')&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))&#10;Decimal('-1.50')&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))&#10;Decimal('-1.50')&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(1, -2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(1), -2)&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.copy_sign(1, Decimal(-2))&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.create_decimal" func="yes">
			<Overload retVal="" descr="Creates a new Decimal instance but using self as context.&#10;&#10;This method implements the to-number operation of the&#10;IBM Decimal specification.">
				<Param name="self" />
				<Param name="[num=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.create_decimal_from_float" func="yes">
			<Overload retVal="" descr="Creates a new Decimal instance from a float but rounding using self&#10;as the context.&#10;&#10;&gt;&gt;&gt; context = Context(prec=5, rounding=ROUND_DOWN)&#10;&gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)&#10;Decimal('3.1415')&#10;&gt;&gt;&gt; context = Context(prec=5, traps=[Inexact])&#10;&gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)&#10;Traceback (most recent call last):&#10;    ...&#10;Inexact: None">
				<Param name="self" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.divide" func="yes">
			<Overload retVal="" descr="Decimal division in a specified context.&#10;&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('3'))&#10;Decimal('0.333333333')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('2'), Decimal('3'))&#10;Decimal('0.666666667')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('5'), Decimal('2'))&#10;Decimal('2.5')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('10'))&#10;Decimal('0.1')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('12'), Decimal('12'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('8.00'), Decimal('2'))&#10;Decimal('4.00')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))&#10;Decimal('1.20')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('100'))&#10;Decimal('10')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('1'))&#10;Decimal('1000')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))&#10;Decimal('1.20E+6')&#10;&gt;&gt;&gt; ExtendedContext.divide(5, 5)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.divide(Decimal(5), 5)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.divide(5, Decimal(5))&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.divide_int" func="yes">
			<Overload retVal="" descr="Divides two numbers and returns the integer part of the result.&#10;&#10;&gt;&gt;&gt; ExtendedContext.divide_int(Decimal('2'), Decimal('3'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.divide_int(Decimal('10'), Decimal('3'))&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.divide_int(10, 3)&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.divide_int(Decimal(10), 3)&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.divide_int(10, Decimal(3))&#10;Decimal('3')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.divmod" func="yes">
			<Overload retVal="" descr="Return (a // b, a % b).&#10;&#10;&gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(3))&#10;(Decimal('2'), Decimal('2'))&#10;&gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(4))&#10;(Decimal('2'), Decimal('0'))&#10;&gt;&gt;&gt; ExtendedContext.divmod(8, 4)&#10;(Decimal('2'), Decimal('0'))&#10;&gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), 4)&#10;(Decimal('2'), Decimal('0'))&#10;&gt;&gt;&gt; ExtendedContext.divmod(8, Decimal(4))&#10;(Decimal('2'), Decimal('0'))">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.exp" func="yes">
			<Overload retVal="" descr="Returns e ** a.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.exp(Decimal('-Infinity'))&#10;Decimal('0')&#10;&gt;&gt;&gt; c.exp(Decimal('-1'))&#10;Decimal('0.367879441')&#10;&gt;&gt;&gt; c.exp(Decimal('0'))&#10;Decimal('1')&#10;&gt;&gt;&gt; c.exp(Decimal('1'))&#10;Decimal('2.71828183')&#10;&gt;&gt;&gt; c.exp(Decimal('0.693147181'))&#10;Decimal('2.00000000')&#10;&gt;&gt;&gt; c.exp(Decimal('+Infinity'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; c.exp(10)&#10;Decimal('22026.4658')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.fma" func="yes">
			<Overload retVal="" descr="Returns a multiplied by b, plus c.&#10;&#10;The first two operands are multiplied together, using multiply,&#10;the third operand is then added to the result of that&#10;multiplication, using add, all with only one final rounding.&#10;&#10;&gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))&#10;Decimal('22')&#10;&gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))&#10;Decimal('-8')&#10;&gt;&gt;&gt; ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))&#10;Decimal('1.38435736E+12')&#10;&gt;&gt;&gt; ExtendedContext.fma(1, 3, 4)&#10;Decimal('7')&#10;&gt;&gt;&gt; ExtendedContext.fma(1, Decimal(3), 4)&#10;Decimal('7')&#10;&gt;&gt;&gt; ExtendedContext.fma(1, 3, Decimal(4))&#10;Decimal('7')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="c" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if the operand is canonical; otherwise return False.&#10;&#10;Currently, the encoding of a Decimal instance is always&#10;canonical, so this method returns True for any Decimal.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_canonical(Decimal('2.50'))&#10;True">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_finite" func="yes">
			<Overload retVal="" descr="Return True if the operand is finite; otherwise return False.&#10;&#10;A Decimal instance is considered finite if it is neither&#10;infinite nor a NaN.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('2.50'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('-0.3'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('0'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('Inf'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('NaN'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_finite(1)&#10;True">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if the operand is infinite; otherwise return False.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('-Inf'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('NaN'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_infinite(1)&#10;False">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_nan" func="yes">
			<Overload retVal="" descr="Return True if the operand is a qNaN or sNaN;&#10;otherwise return False.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_nan(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_nan(Decimal('NaN'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_nan(Decimal('-sNaN'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_nan(1)&#10;False">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_normal" func="yes">
			<Overload retVal="" descr="Return True if the operand is a normal number;&#10;otherwise return False.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.is_normal(Decimal('2.50'))&#10;True&#10;&gt;&gt;&gt; c.is_normal(Decimal('0.1E-999'))&#10;False&#10;&gt;&gt;&gt; c.is_normal(Decimal('0.00'))&#10;False&#10;&gt;&gt;&gt; c.is_normal(Decimal('-Inf'))&#10;False&#10;&gt;&gt;&gt; c.is_normal(Decimal('NaN'))&#10;False&#10;&gt;&gt;&gt; c.is_normal(1)&#10;True">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if the operand is a quiet NaN; otherwise return False.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('NaN'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('sNaN'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_qnan(1)&#10;False">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_signed" func="yes">
			<Overload retVal="" descr="Return True if the operand is negative; otherwise return False.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_signed(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-12'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-0'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_signed(8)&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_signed(-8)&#10;True">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_snan" func="yes">
			<Overload retVal="" descr="Return True if the operand is a signaling NaN;&#10;otherwise return False.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_snan(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_snan(Decimal('NaN'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_snan(Decimal('sNaN'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_snan(1)&#10;False">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if the operand is subnormal; otherwise return False.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.is_subnormal(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; c.is_subnormal(Decimal('0.1E-999'))&#10;True&#10;&gt;&gt;&gt; c.is_subnormal(Decimal('0.00'))&#10;False&#10;&gt;&gt;&gt; c.is_subnormal(Decimal('-Inf'))&#10;False&#10;&gt;&gt;&gt; c.is_subnormal(Decimal('NaN'))&#10;False&#10;&gt;&gt;&gt; c.is_subnormal(1)&#10;False">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_zero" func="yes">
			<Overload retVal="" descr="Return True if the operand is a zero; otherwise return False.&#10;&#10;&gt;&gt;&gt; ExtendedContext.is_zero(Decimal('0'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_zero(Decimal('2.50'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_zero(Decimal('-0E+2'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.is_zero(1)&#10;False&#10;&gt;&gt;&gt; ExtendedContext.is_zero(0)&#10;True">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.ln" func="yes">
			<Overload retVal="" descr="Returns the natural (base e) logarithm of the operand.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.ln(Decimal('0'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; c.ln(Decimal('1.000'))&#10;Decimal('0')&#10;&gt;&gt;&gt; c.ln(Decimal('2.71828183'))&#10;Decimal('1.00000000')&#10;&gt;&gt;&gt; c.ln(Decimal('10'))&#10;Decimal('2.30258509')&#10;&gt;&gt;&gt; c.ln(Decimal('+Infinity'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; c.ln(1)&#10;Decimal('0')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.log10" func="yes">
			<Overload retVal="" descr="Returns the base 10 logarithm of the operand.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.log10(Decimal('0'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; c.log10(Decimal('0.001'))&#10;Decimal('-3')&#10;&gt;&gt;&gt; c.log10(Decimal('1.000'))&#10;Decimal('0')&#10;&gt;&gt;&gt; c.log10(Decimal('2'))&#10;Decimal('0.301029996')&#10;&gt;&gt;&gt; c.log10(Decimal('10'))&#10;Decimal('1')&#10;&gt;&gt;&gt; c.log10(Decimal('70'))&#10;Decimal('1.84509804')&#10;&gt;&gt;&gt; c.log10(Decimal('+Infinity'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; c.log10(0)&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; c.log10(1)&#10;Decimal('0')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logb" func="yes">
			<Overload retVal="" descr="Returns the exponent of the magnitude of the operand's MSD.&#10;&#10;The result is the integer which is the exponent of the magnitude&#10;of the most significant digit of the operand (as though the&#10;operand were truncated to a single digit while maintaining the&#10;value of that digit and without limiting the resulting exponent).&#10;&#10;&gt;&gt;&gt; ExtendedContext.logb(Decimal('250'))&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.logb(Decimal('2.50'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logb(Decimal('0.03'))&#10;Decimal('-2')&#10;&gt;&gt;&gt; ExtendedContext.logb(Decimal('0'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; ExtendedContext.logb(1)&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logb(10)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logb(100)&#10;Decimal('2')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_and" func="yes">
			<Overload retVal="" descr="Applies the logical operation 'and' between each operand's digits.&#10;&#10;The operands must be both logical numbers.&#10;&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('0'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('1'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('0'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))&#10;Decimal('1000')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))&#10;Decimal('10')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(110, 1101)&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(Decimal(110), 1101)&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.logical_and(110, Decimal(1101))&#10;Decimal('100')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_invert" func="yes">
			<Overload retVal="" descr="Invert all the digits in the operand.&#10;&#10;The operand must be a logical number.&#10;&#10;&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('0'))&#10;Decimal('111111111')&#10;&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('1'))&#10;Decimal('111111110')&#10;&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('111111111'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('101010101'))&#10;Decimal('10101010')&#10;&gt;&gt;&gt; ExtendedContext.logical_invert(1101)&#10;Decimal('111110010')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_or" func="yes">
			<Overload retVal="" descr="Applies the logical operation 'or' between each operand's digits.&#10;&#10;The operands must be both logical numbers.&#10;&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('0'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('0'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))&#10;Decimal('1110')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))&#10;Decimal('1110')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(110, 1101)&#10;Decimal('1111')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(Decimal(110), 1101)&#10;Decimal('1111')&#10;&gt;&gt;&gt; ExtendedContext.logical_or(110, Decimal(1101))&#10;Decimal('1111')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_xor" func="yes">
			<Overload retVal="" descr="Applies the logical operation 'xor' between each operand's digits.&#10;&#10;The operands must be both logical numbers.&#10;&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))&#10;Decimal('110')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))&#10;Decimal('1101')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(110, 1101)&#10;Decimal('1011')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(110), 1101)&#10;Decimal('1011')&#10;&gt;&gt;&gt; ExtendedContext.logical_xor(110, Decimal(1101))&#10;Decimal('1011')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.max" func="yes">
			<Overload retVal="" descr="max compares two values numerically and returns the maximum.&#10;&#10;If either operand is a NaN then the general rules apply.&#10;Otherwise, the operands are compared as though by the compare&#10;operation.  If they are numerically equal then the left-hand operand&#10;is chosen as the result.  Otherwise the maximum (closer to positive&#10;infinity) of the two operands is chosen as the result.&#10;&#10;&gt;&gt;&gt; ExtendedContext.max(Decimal('3'), Decimal('2'))&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.max(Decimal('-10'), Decimal('3'))&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.max(Decimal('1.0'), Decimal('1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.max(Decimal('7'), Decimal('NaN'))&#10;Decimal('7')&#10;&gt;&gt;&gt; ExtendedContext.max(1, 2)&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.max(Decimal(1), 2)&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.max(1, Decimal(2))&#10;Decimal('2')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.max_mag" func="yes">
			<Overload retVal="" descr="Compares the values numerically with their sign ignored.&#10;&#10;&gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))&#10;Decimal('7')&#10;&gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))&#10;Decimal('-10')&#10;&gt;&gt;&gt; ExtendedContext.max_mag(1, -2)&#10;Decimal('-2')&#10;&gt;&gt;&gt; ExtendedContext.max_mag(Decimal(1), -2)&#10;Decimal('-2')&#10;&gt;&gt;&gt; ExtendedContext.max_mag(1, Decimal(-2))&#10;Decimal('-2')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.min" func="yes">
			<Overload retVal="" descr="min compares two values numerically and returns the minimum.&#10;&#10;If either operand is a NaN then the general rules apply.&#10;Otherwise, the operands are compared as though by the compare&#10;operation.  If they are numerically equal then the left-hand operand&#10;is chosen as the result.  Otherwise the minimum (closer to negative&#10;infinity) of the two operands is chosen as the result.&#10;&#10;&gt;&gt;&gt; ExtendedContext.min(Decimal('3'), Decimal('2'))&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.min(Decimal('-10'), Decimal('3'))&#10;Decimal('-10')&#10;&gt;&gt;&gt; ExtendedContext.min(Decimal('1.0'), Decimal('1'))&#10;Decimal('1.0')&#10;&gt;&gt;&gt; ExtendedContext.min(Decimal('7'), Decimal('NaN'))&#10;Decimal('7')&#10;&gt;&gt;&gt; ExtendedContext.min(1, 2)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.min(Decimal(1), 2)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.min(1, Decimal(29))&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.min_mag" func="yes">
			<Overload retVal="" descr="Compares the values numerically with their sign ignored.&#10;&#10;&gt;&gt;&gt; ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))&#10;Decimal('-2')&#10;&gt;&gt;&gt; ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))&#10;Decimal('-3')&#10;&gt;&gt;&gt; ExtendedContext.min_mag(1, -2)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.min_mag(Decimal(1), -2)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.min_mag(1, Decimal(-2))&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.minus" func="yes">
			<Overload retVal="" descr="Minus corresponds to unary prefix minus in Python.&#10;&#10;The operation is evaluated using the same rules as subtract; the&#10;operation minus(a) is calculated as subtract('0', a) where the '0'&#10;has the same exponent as the operand.&#10;&#10;&gt;&gt;&gt; ExtendedContext.minus(Decimal('1.3'))&#10;Decimal('-1.3')&#10;&gt;&gt;&gt; ExtendedContext.minus(Decimal('-1.3'))&#10;Decimal('1.3')&#10;&gt;&gt;&gt; ExtendedContext.minus(1)&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.multiply" func="yes">
			<Overload retVal="" descr="multiply multiplies two operands.&#10;&#10;If either operand is a special value then the general rules apply.&#10;Otherwise, the operands are multiplied together&#10;('long multiplication'), resulting in a number which may be as long as&#10;the sum of the lengths of the two operands.&#10;&#10;&gt;&gt;&gt; ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))&#10;Decimal('3.60')&#10;&gt;&gt;&gt; ExtendedContext.multiply(Decimal('7'), Decimal('3'))&#10;Decimal('21')&#10;&gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))&#10;Decimal('0.72')&#10;&gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))&#10;Decimal('-0.0')&#10;&gt;&gt;&gt; ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))&#10;Decimal('4.28135971E+11')&#10;&gt;&gt;&gt; ExtendedContext.multiply(7, 7)&#10;Decimal('49')&#10;&gt;&gt;&gt; ExtendedContext.multiply(Decimal(7), 7)&#10;Decimal('49')&#10;&gt;&gt;&gt; ExtendedContext.multiply(7, Decimal(7))&#10;Decimal('49')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.next_minus" func="yes">
			<Overload retVal="" descr="Returns the largest representable number smaller than a.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; ExtendedContext.next_minus(Decimal('1'))&#10;Decimal('0.999999999')&#10;&gt;&gt;&gt; c.next_minus(Decimal('1E-1007'))&#10;Decimal('0E-1007')&#10;&gt;&gt;&gt; ExtendedContext.next_minus(Decimal('-1.00000003'))&#10;Decimal('-1.00000004')&#10;&gt;&gt;&gt; c.next_minus(Decimal('Infinity'))&#10;Decimal('9.99999999E+999')&#10;&gt;&gt;&gt; c.next_minus(1)&#10;Decimal('0.999999999')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.next_plus" func="yes">
			<Overload retVal="" descr="Returns the smallest representable number larger than a.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; ExtendedContext.next_plus(Decimal('1'))&#10;Decimal('1.00000001')&#10;&gt;&gt;&gt; c.next_plus(Decimal('-1E-1007'))&#10;Decimal('-0E-1007')&#10;&gt;&gt;&gt; ExtendedContext.next_plus(Decimal('-1.00000003'))&#10;Decimal('-1.00000002')&#10;&gt;&gt;&gt; c.next_plus(Decimal('-Infinity'))&#10;Decimal('-9.99999999E+999')&#10;&gt;&gt;&gt; c.next_plus(1)&#10;Decimal('1.00000001')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.next_toward" func="yes">
			<Overload retVal="" descr="Returns the number closest to a, in direction towards b.&#10;&#10;The result is the closest representable number from the first&#10;operand (but not the first operand) that is in the direction&#10;towards the second operand, unless the operands have the same&#10;value.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('2'))&#10;Decimal('1.00000001')&#10;&gt;&gt;&gt; c.next_toward(Decimal('-1E-1007'), Decimal('1'))&#10;Decimal('-0E-1007')&#10;&gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('0'))&#10;Decimal('-1.00000002')&#10;&gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('0'))&#10;Decimal('0.999999999')&#10;&gt;&gt;&gt; c.next_toward(Decimal('1E-1007'), Decimal('-100'))&#10;Decimal('0E-1007')&#10;&gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('-10'))&#10;Decimal('-1.00000004')&#10;&gt;&gt;&gt; c.next_toward(Decimal('0.00'), Decimal('-0.0000'))&#10;Decimal('-0.00')&#10;&gt;&gt;&gt; c.next_toward(0, 1)&#10;Decimal('1E-1007')&#10;&gt;&gt;&gt; c.next_toward(Decimal(0), 1)&#10;Decimal('1E-1007')&#10;&gt;&gt;&gt; c.next_toward(0, Decimal(1))&#10;Decimal('1E-1007')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.normalize" func="yes">
			<Overload retVal="" descr="normalize reduces an operand to its simplest form.&#10;&#10;Essentially a plus operation with all trailing zeros removed from the&#10;result.&#10;&#10;&gt;&gt;&gt; ExtendedContext.normalize(Decimal('2.1'))&#10;Decimal('2.1')&#10;&gt;&gt;&gt; ExtendedContext.normalize(Decimal('-2.0'))&#10;Decimal('-2')&#10;&gt;&gt;&gt; ExtendedContext.normalize(Decimal('1.200'))&#10;Decimal('1.2')&#10;&gt;&gt;&gt; ExtendedContext.normalize(Decimal('-120'))&#10;Decimal('-1.2E+2')&#10;&gt;&gt;&gt; ExtendedContext.normalize(Decimal('120.00'))&#10;Decimal('1.2E+2')&#10;&gt;&gt;&gt; ExtendedContext.normalize(Decimal('0.00'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.normalize(6)&#10;Decimal('6')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.number_class" func="yes">
			<Overload retVal="" descr="Returns an indication of the class of the operand.&#10;&#10;The class is one of the following strings:&#10;  -sNaN&#10;  -NaN&#10;  -Infinity&#10;  -Normal&#10;  -Subnormal&#10;  -Zero&#10;  +Zero&#10;  +Subnormal&#10;  +Normal&#10;  +Infinity&#10;&#10;&gt;&gt;&gt; c = Context(ExtendedContext)&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.number_class(Decimal('Infinity'))&#10;'+Infinity'&#10;&gt;&gt;&gt; c.number_class(Decimal('1E-10'))&#10;'+Normal'&#10;&gt;&gt;&gt; c.number_class(Decimal('2.50'))&#10;'+Normal'&#10;&gt;&gt;&gt; c.number_class(Decimal('0.1E-999'))&#10;'+Subnormal'&#10;&gt;&gt;&gt; c.number_class(Decimal('0'))&#10;'+Zero'&#10;&gt;&gt;&gt; c.number_class(Decimal('-0'))&#10;'-Zero'&#10;&gt;&gt;&gt; c.number_class(Decimal('-0.1E-999'))&#10;'-Subnormal'&#10;&gt;&gt;&gt; c.number_class(Decimal('-1E-10'))&#10;'-Normal'&#10;&gt;&gt;&gt; c.number_class(Decimal('-2.50'))&#10;'-Normal'&#10;&gt;&gt;&gt; c.number_class(Decimal('-Infinity'))&#10;'-Infinity'&#10;&gt;&gt;&gt; c.number_class(Decimal('NaN'))&#10;'NaN'&#10;&gt;&gt;&gt; c.number_class(Decimal('-NaN'))&#10;'NaN'&#10;&gt;&gt;&gt; c.number_class(Decimal('sNaN'))&#10;'sNaN'&#10;&gt;&gt;&gt; c.number_class(123)&#10;'+Normal'">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.plus" func="yes">
			<Overload retVal="" descr="Plus corresponds to unary prefix plus in Python.&#10;&#10;The operation is evaluated using the same rules as add; the&#10;operation plus(a) is calculated as add('0', a) where the '0'&#10;has the same exponent as the operand.&#10;&#10;&gt;&gt;&gt; ExtendedContext.plus(Decimal('1.3'))&#10;Decimal('1.3')&#10;&gt;&gt;&gt; ExtendedContext.plus(Decimal('-1.3'))&#10;Decimal('-1.3')&#10;&gt;&gt;&gt; ExtendedContext.plus(-1)&#10;Decimal('-1')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.power" func="yes">
			<Overload retVal="" descr="Raises a to the power of b, to modulo if given.&#10;&#10;With two arguments, compute a**b.  If a is negative then b&#10;must be integral.  The result will be inexact unless b is&#10;integral and the result is finite and can be expressed exactly&#10;in 'precision' digits.&#10;&#10;With three arguments, compute (a**b) % modulo.  For the&#10;three argument form, the following restrictions on the&#10;arguments hold:&#10;&#10; - all three arguments must be integral&#10; - b must be nonnegative&#10; - at least one of a or b must be nonzero&#10; - modulo must be nonzero and have at most 'precision' digits&#10;&#10;The result of pow(a, b, modulo) is identical to the result&#10;that would be obtained by computing (a**b) % modulo with&#10;unbounded precision, but is computed more efficiently.  It is&#10;always exact.&#10;&#10;&gt;&gt;&gt; c = ExtendedContext.copy()&#10;&gt;&gt;&gt; c.Emin = -999&#10;&gt;&gt;&gt; c.Emax = 999&#10;&gt;&gt;&gt; c.power(Decimal('2'), Decimal('3'))&#10;Decimal('8')&#10;&gt;&gt;&gt; c.power(Decimal('-2'), Decimal('3'))&#10;Decimal('-8')&#10;&gt;&gt;&gt; c.power(Decimal('2'), Decimal('-3'))&#10;Decimal('0.125')&#10;&gt;&gt;&gt; c.power(Decimal('1.7'), Decimal('8'))&#10;Decimal('69.7575744')&#10;&gt;&gt;&gt; c.power(Decimal('10'), Decimal('0.301029996'))&#10;Decimal('2.00000000')&#10;&gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('-1'))&#10;Decimal('0')&#10;&gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('0'))&#10;Decimal('1')&#10;&gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('1'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('-1'))&#10;Decimal('-0')&#10;&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('0'))&#10;Decimal('1')&#10;&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('1'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('2'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; c.power(Decimal('0'), Decimal('0'))&#10;Decimal('NaN')&#10;&#10;&gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('16'))&#10;Decimal('11')&#10;&gt;&gt;&gt; c.power(Decimal('-3'), Decimal('7'), Decimal('16'))&#10;Decimal('-11')&#10;&gt;&gt;&gt; c.power(Decimal('-3'), Decimal('8'), Decimal('16'))&#10;Decimal('1')&#10;&gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('-16'))&#10;Decimal('11')&#10;&gt;&gt;&gt; c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))&#10;Decimal('11729830')&#10;&gt;&gt;&gt; c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))&#10;Decimal('-0')&#10;&gt;&gt;&gt; c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.power(7, 7)&#10;Decimal('823543')&#10;&gt;&gt;&gt; ExtendedContext.power(Decimal(7), 7)&#10;Decimal('823543')&#10;&gt;&gt;&gt; ExtendedContext.power(7, Decimal(7), 2)&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[modulo=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.quantize" func="yes">
			<Overload retVal="" descr="Returns a value equal to 'a' (rounded), having the exponent of 'b'.&#10;&#10;The coefficient of the result is derived from that of the left-hand&#10;operand.  It may be rounded using the current rounding setting (if the&#10;exponent is being increased), multiplied by a positive power of ten (if&#10;the exponent is being decreased), or is unchanged (if the exponent is&#10;already equal to that of the right-hand operand).&#10;&#10;Unlike other operations, if the length of the coefficient after the&#10;quantize operation would be greater than precision then an Invalid&#10;operation condition is raised.  This guarantees that, unless there is&#10;an error condition, the exponent of the result of a quantize is always&#10;equal to that of the right-hand operand.&#10;&#10;Also unlike other operations, quantize will never raise Underflow, even&#10;if the result is subnormal and inexact.&#10;&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))&#10;Decimal('2.170')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))&#10;Decimal('2.17')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))&#10;Decimal('2.2')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))&#10;Decimal('0E+1')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))&#10;Decimal('-0')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))&#10;Decimal('-0E+5')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))&#10;Decimal('217.0')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))&#10;Decimal('217')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))&#10;Decimal('2.2E+2')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))&#10;Decimal('2E+2')&#10;&gt;&gt;&gt; ExtendedContext.quantize(1, 2)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.quantize(Decimal(1), 2)&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.quantize(1, Decimal(2))&#10;Decimal('1')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.radix" func="yes">
			<Overload retVal="" descr="Just returns 10, as this is Decimal, :)&#10;&#10;&gt;&gt;&gt; ExtendedContext.radix()&#10;Decimal('10')">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.remainder" func="yes">
			<Overload retVal="" descr="Returns the remainder from integer division.&#10;&#10;The result is the residue of the dividend after the operation of&#10;calculating integer division as described for divide-integer, rounded&#10;to precision digits if necessary.  The sign of the result, if&#10;non-zero, is the same as that of the original dividend.&#10;&#10;This operation will fail under the same conditions as integer division&#10;(that is, if integer division on the same two operands would fail, the&#10;remainder cannot be calculated).&#10;&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))&#10;Decimal('2.1')&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('3'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal('-10'), Decimal('3'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))&#10;Decimal('0.2')&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))&#10;Decimal('0.1')&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))&#10;Decimal('1.0')&#10;&gt;&gt;&gt; ExtendedContext.remainder(22, 6)&#10;Decimal('4')&#10;&gt;&gt;&gt; ExtendedContext.remainder(Decimal(22), 6)&#10;Decimal('4')&#10;&gt;&gt;&gt; ExtendedContext.remainder(22, Decimal(6))&#10;Decimal('4')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.remainder_near" func="yes">
			<Overload retVal="" descr="Returns to be &quot;a - b * n&quot;, where n is the integer nearest the exact&#10;value of &quot;x / b&quot; (if two integers are equally near then the even one&#10;is chosen).  If the result is equal to 0 then its sign will be the&#10;sign of a.&#10;&#10;This operation will fail under the same conditions as integer division&#10;(that is, if integer division on the same two operands would fail, the&#10;remainder cannot be calculated).&#10;&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))&#10;Decimal('-0.9')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))&#10;Decimal('-2')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))&#10;Decimal('-1')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))&#10;Decimal('0.2')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))&#10;Decimal('0.1')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))&#10;Decimal('-0.3')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(3, 11)&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(3), 11)&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.remainder_near(3, Decimal(11))&#10;Decimal('3')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.rotate" func="yes">
			<Overload retVal="" descr="Returns a rotated copy of a, b times.&#10;&#10;The coefficient of the result is a rotated copy of the digits in&#10;the coefficient of the first operand.  The number of places of&#10;rotation is taken from the absolute value of the second operand,&#10;with the rotation being to the left if the second operand is&#10;positive or to the right otherwise.&#10;&#10;&gt;&gt;&gt; ExtendedContext.rotate(Decimal('34'), Decimal('8'))&#10;Decimal('400000003')&#10;&gt;&gt;&gt; ExtendedContext.rotate(Decimal('12'), Decimal('9'))&#10;Decimal('12')&#10;&gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))&#10;Decimal('891234567')&#10;&gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))&#10;Decimal('123456789')&#10;&gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))&#10;Decimal('345678912')&#10;&gt;&gt;&gt; ExtendedContext.rotate(1333333, 1)&#10;Decimal('13333330')&#10;&gt;&gt;&gt; ExtendedContext.rotate(Decimal(1333333), 1)&#10;Decimal('13333330')&#10;&gt;&gt;&gt; ExtendedContext.rotate(1333333, Decimal(1))&#10;Decimal('13333330')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.same_quantum" func="yes">
			<Overload retVal="" descr="Returns True if the two operands have the same exponent.&#10;&#10;The result is never affected by either the sign or the coefficient of&#10;either operand.&#10;&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))&#10;False&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))&#10;True&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(10000, -1)&#10;True&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(10000), -1)&#10;True&#10;&gt;&gt;&gt; ExtendedContext.same_quantum(10000, Decimal(-1))&#10;True">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.scaleb" func="yes">
			<Overload retVal="" descr="Returns the first operand after adding the second value its exp.&#10;&#10;&gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))&#10;Decimal('0.0750')&#10;&gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))&#10;Decimal('7.50')&#10;&gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))&#10;Decimal('7.50E+3')&#10;&gt;&gt;&gt; ExtendedContext.scaleb(1, 4)&#10;Decimal('1E+4')&#10;&gt;&gt;&gt; ExtendedContext.scaleb(Decimal(1), 4)&#10;Decimal('1E+4')&#10;&gt;&gt;&gt; ExtendedContext.scaleb(1, Decimal(4))&#10;Decimal('1E+4')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.shift" func="yes">
			<Overload retVal="" descr="Returns a shifted copy of a, b times.&#10;&#10;The coefficient of the result is a shifted copy of the digits&#10;in the coefficient of the first operand.  The number of places&#10;to shift is taken from the absolute value of the second operand,&#10;with the shift being to the left if the second operand is&#10;positive or to the right otherwise.  Digits shifted into the&#10;coefficient are zeros.&#10;&#10;&gt;&gt;&gt; ExtendedContext.shift(Decimal('34'), Decimal('8'))&#10;Decimal('400000000')&#10;&gt;&gt;&gt; ExtendedContext.shift(Decimal('12'), Decimal('9'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))&#10;Decimal('1234567')&#10;&gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('0'))&#10;Decimal('123456789')&#10;&gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))&#10;Decimal('345678900')&#10;&gt;&gt;&gt; ExtendedContext.shift(88888888, 2)&#10;Decimal('888888800')&#10;&gt;&gt;&gt; ExtendedContext.shift(Decimal(88888888), 2)&#10;Decimal('888888800')&#10;&gt;&gt;&gt; ExtendedContext.shift(88888888, Decimal(2))&#10;Decimal('888888800')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.sqrt" func="yes">
			<Overload retVal="" descr="Square root of a non-negative number to context precision.&#10;&#10;If the result must be inexact, it is rounded using the round-half-even&#10;algorithm.&#10;&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0'))&#10;Decimal('0')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('-0'))&#10;Decimal('-0')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0.39'))&#10;Decimal('0.624499800')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('100'))&#10;Decimal('10')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1'))&#10;Decimal('1')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.0'))&#10;Decimal('1.0')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.00'))&#10;Decimal('1.0')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('7'))&#10;Decimal('2.64575131')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('10'))&#10;Decimal('3.16227766')&#10;&gt;&gt;&gt; ExtendedContext.sqrt(2)&#10;Decimal('1.41421356')&#10;&gt;&gt;&gt; ExtendedContext.prec&#10;9">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.subtract" func="yes">
			<Overload retVal="" descr="Return the difference between the two operands.&#10;&#10;&gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))&#10;Decimal('0.23')&#10;&gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))&#10;Decimal('0.00')&#10;&gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))&#10;Decimal('-0.77')&#10;&gt;&gt;&gt; ExtendedContext.subtract(8, 5)&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.subtract(Decimal(8), 5)&#10;Decimal('3')&#10;&gt;&gt;&gt; ExtendedContext.subtract(8, Decimal(5))&#10;Decimal('3')">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_eng_string" func="yes">
			<Overload retVal="" descr="Converts a number to a string, using scientific notation.&#10;&#10;The operation is not affected by the context.">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_integral" func="yes">
			<Overload retVal="" descr="Rounds to an integer.&#10;&#10;When the operand has a negative exponent, the result is the same&#10;as using the quantize() operation using the given operand as the&#10;left-hand-operand, 1E+0 as the right-hand-operand, and the precision&#10;of the operand as the precision setting, except that no flags will&#10;be set.  The rounding mode is taken from the context.&#10;&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('2.1'))&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100.0'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('101.5'))&#10;Decimal('102')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-101.5'))&#10;Decimal('-102')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('10E+5'))&#10;Decimal('1.0E+6')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('7.89E+77'))&#10;Decimal('7.89E+77')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-Inf'))&#10;Decimal('-Infinity')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_integral_exact" func="yes">
			<Overload retVal="" descr="Rounds to an integer.&#10;&#10;When the operand has a negative exponent, the result is the same&#10;as using the quantize() operation using the given operand as the&#10;left-hand-operand, 1E+0 as the right-hand-operand, and the precision&#10;of the operand as the precision setting; Inexact and Rounded flags&#10;are allowed in this operation.  The rounding mode is taken from the&#10;context.&#10;&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('2.1'))&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100.0'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('101.5'))&#10;Decimal('102')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-101.5'))&#10;Decimal('-102')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('10E+5'))&#10;Decimal('1.0E+6')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('7.89E+77'))&#10;Decimal('7.89E+77')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-Inf'))&#10;Decimal('-Infinity')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_integral_value" func="yes">
			<Overload retVal="" descr="Rounds to an integer.&#10;&#10;When the operand has a negative exponent, the result is the same&#10;as using the quantize() operation using the given operand as the&#10;left-hand-operand, 1E+0 as the right-hand-operand, and the precision&#10;of the operand as the precision setting, except that no flags will&#10;be set.  The rounding mode is taken from the context.&#10;&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('2.1'))&#10;Decimal('2')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100.0'))&#10;Decimal('100')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('101.5'))&#10;Decimal('102')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-101.5'))&#10;Decimal('-102')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('10E+5'))&#10;Decimal('1.0E+6')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('7.89E+77'))&#10;Decimal('7.89E+77')&#10;&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-Inf'))&#10;Decimal('-Infinity')">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_sci_string" func="yes">
			<Overload retVal="" descr="Converts a number to a string, using scientific notation.&#10;&#10;The operation is not affected by the context.">
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ConversionSyntax" func="yes">
			<Overload retVal="" descr="Trying to convert badly formed string.&#10;&#10;This occurs and signals invalid-operation if an string is being&#10;converted to a number and it does not conform to the numeric string&#10;syntax.  The result is [0,qNaN].">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ConversionSyntax.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ConversionSyntax.handle" />
		<KeyWord name="decimal.ConversionSyntax.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal" func="yes">
			<Overload retVal="" descr="Floating point class for decimal arithmetic.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.adjusted" func="yes">
			<Overload retVal="" descr="Return the adjusted exponent of self">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.as_tuple" func="yes">
			<Overload retVal="" descr="Represents the number as a triple tuple.&#10;&#10;To show the internals exactly as they are.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.canonical" func="yes">
			<Overload retVal="" descr="Returns the same Decimal object.&#10;&#10;As we do not have different encodings for the same number, the&#10;received object already is in its canonical form.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare" func="yes">
			<Overload retVal="" descr="Compares one to another.&#10;&#10;-1 =&gt; a &lt; b&#10;0  =&gt; a = b&#10;1  =&gt; a &gt; b&#10;NaN =&gt; one is NaN&#10;Like __cmp__, but returns Decimal instances.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare_signal" func="yes">
			<Overload retVal="" descr="Compares self to the other operand numerically.&#10;&#10;It's pretty much like compare(), but all NaNs signal, with signaling&#10;NaNs taking precedence over quiet NaNs.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare_total" func="yes">
			<Overload retVal="" descr="Compares self to other using the abstract representations.&#10;&#10;This is not like the standard compare, which use their numerical&#10;value. Note that a total ordering is defined for all possible abstract&#10;representations.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compares self to other using abstract repr., ignoring sign.&#10;&#10;Like compare_total, but with operand's sign ignored and assumed to be 0.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.conjugate" />
		<KeyWord name="decimal.Decimal.copy_abs" func="yes">
			<Overload retVal="" descr="Returns a copy with the sign set to 0.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.copy_negate" func="yes">
			<Overload retVal="" descr="Returns a copy with the sign inverted.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.copy_sign" func="yes">
			<Overload retVal="" descr="Returns self with the sign of other.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.exp" func="yes">
			<Overload retVal="" descr="Returns e ** self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.fma" func="yes">
			<Overload retVal="" descr="Fused multiply-add.&#10;&#10;Returns self*other+third with no rounding of the intermediate&#10;product self*other.&#10;&#10;self and other are multiplied together, with no rounding of&#10;the result.  The third operand is then added to the result,&#10;and a single final rounding is performed.">
				<Param name="self" />
				<Param name="other" />
				<Param name="third" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.from_float" func="yes">
			<Overload retVal="" descr="Converts a float to a decimal number, exactly.&#10;&#10;Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').&#10;Since 0.1 is not exactly representable in binary floating point, the&#10;value is stored as the nearest representable value which is&#10;0x1.999999999999ap-4.  The exact equivalent of the value in decimal&#10;is 0.1000000000000000055511151231257827021181583404541015625.&#10;&#10;&gt;&gt;&gt; Decimal.from_float(0.1)&#10;Decimal('0.1000000000000000055511151231257827021181583404541015625')&#10;&gt;&gt;&gt; Decimal.from_float(float('nan'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; Decimal.from_float(float('inf'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; Decimal.from_float(-float('inf'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; Decimal.from_float(-0.0)&#10;Decimal('-0')">
				<Param name="cls" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.imag" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if self is canonical; otherwise return False.&#10;&#10;Currently, the encoding of a Decimal instance is always&#10;canonical, so this method returns True for any Decimal.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_finite" func="yes">
			<Overload retVal="" descr="Return True if self is finite; otherwise return False.&#10;&#10;A Decimal instance is considered finite if it is neither&#10;infinite nor a NaN.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if self is infinite; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_nan" func="yes">
			<Overload retVal="" descr="Return True if self is a qNaN or sNaN; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_normal" func="yes">
			<Overload retVal="" descr="Return True if self is a normal number; otherwise return False.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if self is a quiet NaN; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_signed" func="yes">
			<Overload retVal="" descr="Return True if self is negative; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_snan" func="yes">
			<Overload retVal="" descr="Return True if self is a signaling NaN; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if self is subnormal; otherwise return False.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_zero" func="yes">
			<Overload retVal="" descr="Return True if self is a zero; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.ln" func="yes">
			<Overload retVal="" descr="Returns the natural (base e) logarithm of self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.log10" func="yes">
			<Overload retVal="" descr="Returns the base 10 logarithm of self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logb" func="yes">
			<Overload retVal="" descr="Returns the exponent of the magnitude of self's MSD.&#10;&#10;The result is the integer which is the exponent of the magnitude&#10;of the most significant digit of self (as though it were truncated&#10;to a single digit while maintaining the value of that digit and&#10;without limiting the resulting exponent).">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_and" func="yes">
			<Overload retVal="" descr="Applies an 'and' operation between self and other's digits.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_invert" func="yes">
			<Overload retVal="" descr="Invert all its digits.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_or" func="yes">
			<Overload retVal="" descr="Applies an 'or' operation between self and other's digits.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_xor" func="yes">
			<Overload retVal="" descr="Applies an 'xor' operation between self and other's digits.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.max" func="yes">
			<Overload retVal="" descr="Returns the larger value.&#10;&#10;Like max(self, other) except if one is not a number, returns&#10;NaN (and signals if one is sNaN).  Also rounds.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.max_mag" func="yes">
			<Overload retVal="" descr="Compares the values numerically with their sign ignored.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.min" func="yes">
			<Overload retVal="" descr="Returns the smaller value.&#10;&#10;Like min(self, other) except if one is not a number, returns&#10;NaN (and signals if one is sNaN).  Also rounds.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.min_mag" func="yes">
			<Overload retVal="" descr="Compares the values numerically with their sign ignored.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.next_minus" func="yes">
			<Overload retVal="" descr="Returns the largest representable number smaller than itself.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.next_plus" func="yes">
			<Overload retVal="" descr="Returns the smallest representable number larger than itself.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.next_toward" func="yes">
			<Overload retVal="" descr="Returns the number closest to self, in the direction towards other.&#10;&#10;The result is the closest representable number to self&#10;(excluding self) that is in the direction towards other,&#10;unless both have the same value.  If the two operands are&#10;numerically equal, then the result is a copy of self with the&#10;sign set to be the same as the sign of other.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.normalize" func="yes">
			<Overload retVal="" descr="Normalize- strip trailing 0s, change anything equal to 0 to 0e0">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.number_class" func="yes">
			<Overload retVal="" descr="Returns an indication of the class of self.&#10;&#10;The class is one of the following strings:&#10;  sNaN&#10;  NaN&#10;  -Infinity&#10;  -Normal&#10;  -Subnormal&#10;  -Zero&#10;  +Zero&#10;  +Subnormal&#10;  +Normal&#10;  +Infinity">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.quantize" func="yes">
			<Overload retVal="" descr="Quantize self so its exponent is the same as that of exp.&#10;&#10;Similar to self._rescale(exp._exp) but with error checking.">
				<Param name="self" />
				<Param name="exp" />
				<Param name="[rounding=None" />
				<Param name="[context=None" />
				<Param name="[watchexp=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.radix" func="yes">
			<Overload retVal="" descr="Just returns 10, as this is Decimal, :)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.real" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.remainder_near" func="yes">
			<Overload retVal="" descr="Remainder nearest to 0-  abs(remainder-near) &lt;= other/2">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.rotate" func="yes">
			<Overload retVal="" descr="Returns a rotated copy of self, value-of-other times.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.same_quantum" func="yes">
			<Overload retVal="" descr="Return True if self and other have the same exponent; otherwise&#10;return False.&#10;&#10;If either operand is a special value, the following rules are used:&#10;   * return True if both operands are infinities&#10;   * return True if both operands are NaNs&#10;   * otherwise, return False.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.scaleb" func="yes">
			<Overload retVal="" descr="Returns self operand after adding the second value to its exp.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.shift" func="yes">
			<Overload retVal="" descr="Returns a shifted copy of self, value-of-other times.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.sqrt" func="yes">
			<Overload retVal="" descr="Return the square root of self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_eng_string" func="yes">
			<Overload retVal="" descr="Convert to engineering-type string.&#10;&#10;Engineering notation has an exponent which is a multiple of 3, so there&#10;are up to 3 digits left of the decimal place.&#10;&#10;Same rules for when in exponential and when as a value as in __str__.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_integral" func="yes">
			<Overload retVal="" descr="Rounds to the nearest integer, without raising inexact, rounded.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_integral_exact" func="yes">
			<Overload retVal="" descr="Rounds to a nearby integer.&#10;&#10;If no rounding mode is specified, take the rounding mode from&#10;the context.  This method raises the Rounded and Inexact flags&#10;when appropriate.&#10;&#10;See also: to_integral_value, which does exactly the same as&#10;this method except that it doesn't raise Inexact or Rounded.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_integral_value" func="yes">
			<Overload retVal="" descr="Rounds to the nearest integer, without raising inexact, rounded.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalException" func="yes">
			<Overload retVal="" descr="Base exception class.&#10;&#10;Used exceptions derive from this.&#10;If an exception derives from another exception besides this (such as&#10;Underflow (Inexact, Rounded, Subnormal) that indicates that it is only&#10;called if the others are present.  This isn't actually used for&#10;anything, though.&#10;&#10;handle  -- Called when context._raise_error is called and the&#10;           trap_enabler is not set.  First argument is self, second is the&#10;           context.  More arguments can be given, those being after&#10;           the explanation in _raise_error (For example,&#10;           context._raise_error(NewError, '(-x)!', self._sign) would&#10;           call NewError().handle(context, self._sign).)&#10;&#10;To define a new exception, it should be sufficient to have it derive&#10;from DecimalException.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalException.handle" />
		<KeyWord name="decimal.DecimalException.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple" func="yes">
			<Overload retVal="" descr="DecimalTuple(sign, digits, exponent)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.digits" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.exponent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.sign" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DefaultContext" func="yes">
			<Overload retVal="" descr="(Context)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionByZero" func="yes">
			<Overload retVal="" descr="Division by 0.&#10;&#10;This occurs and signals division-by-zero if division of a finite number&#10;by zero was attempted (during a divide-integer or divide operation, or a&#10;power operation with negative right-hand operand), and the dividend was&#10;not zero.&#10;&#10;The result of the operation is [sign,inf], where sign is the exclusive&#10;or of the signs of the operands for divide, or is 1 for an odd power of&#10;-0, for power.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionByZero.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionByZero.handle" />
		<KeyWord name="decimal.DivisionByZero.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionImpossible" func="yes">
			<Overload retVal="" descr="Cannot perform the division adequately.&#10;&#10;This occurs and signals invalid-operation if the integer result of a&#10;divide-integer or remainder operation had too many digits (would be&#10;longer than precision).  The result is [0,qNaN].">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionImpossible.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionImpossible.handle" />
		<KeyWord name="decimal.DivisionImpossible.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionUndefined" func="yes">
			<Overload retVal="" descr="Undefined result of division.&#10;&#10;This occurs and signals invalid-operation if division by zero was&#10;attempted (during a divide-integer, divide, or remainder operation), and&#10;the dividend is also zero.  The result is [0,qNaN].">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionUndefined.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionUndefined.handle" />
		<KeyWord name="decimal.DivisionUndefined.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ExtendedContext" func="yes">
			<Overload retVal="" descr="(Context)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Inexact" func="yes">
			<Overload retVal="" descr="Had to round, losing information.&#10;&#10;This occurs and signals inexact whenever the result of an operation is&#10;not exact (that is, it needed to be rounded and any discarded digits&#10;were non-zero), or if an overflow or underflow condition occurs.  The&#10;result in all cases is unchanged.&#10;&#10;The inexact signal may be tested (or trapped) to determine if a given&#10;operation (or sequence of operations) was inexact.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Inexact.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Inexact.handle" />
		<KeyWord name="decimal.Inexact.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidContext" func="yes">
			<Overload retVal="" descr="Invalid context.  Unknown rounding, for example.&#10;&#10;This occurs and signals invalid-operation if an invalid context was&#10;detected during an operation.  This can occur if contexts are not checked&#10;on creation and either the precision exceeds the capability of the&#10;underlying concrete representation or an unknown or unsupported rounding&#10;was specified.  These aspects of the context need only be checked when&#10;the values are required to be used.  The result is [0,qNaN].">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidContext.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidContext.handle" />
		<KeyWord name="decimal.InvalidContext.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidOperation" func="yes">
			<Overload retVal="" descr="An invalid operation was performed.&#10;&#10;Various bad things cause this:&#10;&#10;Something creates a signaling NaN&#10;-INF + INF&#10;0 * (+-)INF&#10;(+-)INF / (+-)INF&#10;x % 0&#10;(+-)INF % x&#10;x._rescale( non-integer )&#10;sqrt(-x) , x &gt; 0&#10;0 ** 0&#10;x ** (non-integer)&#10;x ** (+-)INF&#10;An operand is invalid&#10;&#10;The result of the operation after these is a quiet positive NaN,&#10;except when the cause is a signaling NaN, in which case the result is&#10;also a quiet NaN, but with the original sign, and an optional&#10;diagnostic information.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidOperation.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidOperation.handle" />
		<KeyWord name="decimal.InvalidOperation.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Overflow" func="yes">
			<Overload retVal="" descr="Numerical overflow.&#10;&#10;This occurs and signals overflow if the adjusted exponent of a result&#10;(from a conversion or from an operation that is not an attempt to divide&#10;by zero), after rounding, would be greater than the largest value that&#10;can be handled by the implementation (the value Emax).&#10;&#10;The result depends on the rounding mode:&#10;&#10;For round-half-up and round-half-even (and for round-half-down and&#10;round-up, if implemented), the result of the operation is [sign,inf],&#10;where sign is the sign of the intermediate result.  For round-down, the&#10;result is the largest finite number that can be represented in the&#10;current precision, with the sign of the intermediate result.  For&#10;round-ceiling, the result is the same as for round-down if the sign of&#10;the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,&#10;the result is the same as for round-down if the sign of the intermediate&#10;result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded&#10;will also be raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Overflow.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Overflow.handle" />
		<KeyWord name="decimal.Overflow.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_05UP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_CEILING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_DOWN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_FLOOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_HALF_DOWN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_HALF_EVEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_HALF_UP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_UP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Rounded" func="yes">
			<Overload retVal="" descr="Number got rounded (not  necessarily changed during rounding).&#10;&#10;This occurs and signals rounded whenever the result of an operation is&#10;rounded (that is, some zero or non-zero digits were discarded from the&#10;coefficient), or if an overflow or underflow condition occurs.  The&#10;result in all cases is unchanged.&#10;&#10;The rounded signal may be tested (or trapped) to determine if a given&#10;operation (or sequence of operations) caused a loss of precision.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Rounded.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Rounded.handle" />
		<KeyWord name="decimal.Rounded.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Subnormal" func="yes">
			<Overload retVal="" descr="Exponent &lt; Emin before rounding.&#10;&#10;This occurs and signals subnormal whenever the result of a conversion or&#10;operation is subnormal (that is, its adjusted exponent is less than&#10;Emin, before any rounding).  The result in all cases is unchanged.&#10;&#10;The subnormal signal may be tested (or trapped) to determine if a given&#10;or operation (or sequence of operations) yielded a subnormal result.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Subnormal.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Subnormal.handle" />
		<KeyWord name="decimal.Subnormal.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Underflow" func="yes">
			<Overload retVal="" descr="Numerical underflow with result rounded to 0.&#10;&#10;This occurs and signals underflow if a result is inexact and the&#10;adjusted exponent of the result would be smaller (more negative) than&#10;the smallest value that can be handled by the implementation (the value&#10;Emin).  That is, the result is both inexact and subnormal.&#10;&#10;The result after an underflow will be a subnormal number rounded, if&#10;necessary, so that its exponent is not less than Etiny.  This may result&#10;in 0 with the sign of the intermediate result and an exponent of Etiny.&#10;&#10;In all cases, Inexact, Rounded, and Subnormal will also be raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Underflow.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Underflow.handle" />
		<KeyWord name="decimal.Underflow.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.getcontext" func="yes">
			<Overload retVal="" descr="Returns this thread's context.&#10;&#10;If this thread does not yet have a context, returns&#10;a new context and sets this thread's context.&#10;New contexts are copies of DefaultContext.">
				<Param name="[_local=<thread._local object at 0x00000000038C0D58>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.localcontext" func="yes">
			<Overload retVal="" descr="Return a context manager for a copy of the supplied context&#10;&#10;Uses a copy of the current context if no context is specified&#10;The returned context manager creates a local decimal context&#10;in a with statement:&#10;    def sin(x):&#10;         with localcontext() as ctx:&#10;             ctx.prec += 2&#10;             # Rest of sin calculation algorithm&#10;             # uses a precision 2 greater than normal&#10;         return +s  # Convert result to normal precision&#10;&#10;     def sin(x):&#10;         with localcontext(ExtendedContext):&#10;             # Rest of sin calculation algorithm&#10;             # uses the Extended Context from the&#10;             # General Decimal Arithmetic Specification&#10;         return +s  # Convert result to normal context&#10;&#10;&gt;&gt;&gt; setcontext(DefaultContext)&#10;&gt;&gt;&gt; print getcontext().prec&#10;28&#10;&gt;&gt;&gt; with localcontext():&#10;...     ctx = getcontext()&#10;...     ctx.prec += 2&#10;...     print ctx.prec&#10;...&#10;30&#10;&gt;&gt;&gt; with localcontext(ExtendedContext):&#10;...     print getcontext().prec&#10;...&#10;9&#10;&gt;&gt;&gt; print getcontext().prec&#10;28">
				<Param name="[ctx=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.setcontext" func="yes">
			<Overload retVal="" descr="Set this thread's context to context.">
				<Param name="context" />
				<Param name="[_local=<thread._local object at 0x00000000038C0D58>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decode_long" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="decodestring" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="decomposition" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="decompress" func="yes">
			<Overload retVal="" descr="Function of bz2">
			</Overload>
		</KeyWord>
		<KeyWord name="dedent" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="deepcopy" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="deepvalues" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="def" />
		<KeyWord name="default" func="yes">
			<Overload retVal="" descr="Function of json.JSONEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="defaultTestResult" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="default_timer" func="yes">
			<Overload retVal="" descr="Function of timeit">
			</Overload>
		</KeyWord>
		<KeyWord name="defaultdict" func="yes">
			<Overload retVal="" descr="Function of collections.defaultdict">
			</Overload>
		</KeyWord>
		<KeyWord name="degrees" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="del" />
		<KeyWord name="delattr" func="yes">
			<Overload retVal="" descr="delattr(object, name)&#10;&#10;Delete a named attribute on an object; delattr(x, 'y') is equivalent to&#10;``del x.y''.">
			</Overload>
		</KeyWord>
		<KeyWord name="delay" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="deletecommand" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="deleter" func="yes">
			<Overload retVal="" descr="Descriptor to change the deleter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="demo" func="yes">
			<Overload retVal="" descr="Function of filecmp">
			</Overload>
		</KeyWord>
		<KeyWord name="deque" func="yes">
			<Overload retVal="" descr="Function of Queue.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="describe" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="destroy" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="detach" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRandom">
			</Overload>
		</KeyWord>
		<KeyWord name="dgettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="dict" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="difference" func="yes">
			<Overload retVal="" descr="Return the difference of two or more sets as a new set.&#10;&#10;(i.e. all elements that are in this set but not the others.)">
			</Overload>
		</KeyWord>
		<KeyWord name="difference_update" func="yes">
			<Overload retVal="" descr="Remove all elements of another set from this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib" func="yes">
			<Overload retVal="" descr='Module difflib -- helpers for computing deltas between objects.&#10;&#10;Function get_close_matches(word, possibilities, n=3, cutoff=0.6):&#10;    Use SequenceMatcher to return list of the best "good enough" matches.&#10;&#10;Function context_diff(a, b):&#10;    For two lists of strings, return a delta in context diff format.&#10;&#10;Function ndiff(a, b):&#10;    Return a delta: the difference between `a` and `b` (lists of strings).&#10;&#10;Function restore(delta, which):&#10;    Return one of the two sequences that generated an ndiff delta.&#10;&#10;Function unified_diff(a, b):&#10;    For two lists of strings, return a delta in unified diff format.&#10;&#10;Class SequenceMatcher:&#10;    A flexible class for comparing pairs of sequences of any type.&#10;&#10;Class Differ:&#10;    For producing human-readable deltas from sequences of lines of text.&#10;&#10;Class HtmlDiff:&#10;    For producing HTML side by side comparison with change highlights.'>
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Differ" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.HtmlDiff" func="yes">
			<Overload retVal="" descr="For producing HTML side by side comparison with change highlights.&#10;&#10;This class can be used to create an HTML table (or a complete HTML file&#10;containing the table) showing a side by side, line by line comparison&#10;of text with inter-line and intra-line change highlights.  The table can&#10;be generated in either full or contextual difference mode.&#10;&#10;The following methods are provided for HTML generation:&#10;&#10;make_table -- generates HTML for a single side by side table&#10;make_file -- generates complete HTML file with a single side by side table&#10;&#10;See tools/scripts/diff.py for an example usage of this class.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.HtmlDiff.make_file" func="yes">
			<Overload retVal="" descr='Returns HTML file of side by side comparison with change highlights&#10;&#10;Arguments:&#10;fromlines -- list of "from" lines&#10;tolines -- list of "to" lines&#10;fromdesc -- "from" file column header string&#10;todesc -- "to" file column header string&#10;context -- set to True for contextual differences (defaults to False&#10;    which shows full differences).&#10;numlines -- number of context lines.  When context is set True,&#10;    controls number of lines displayed before and after the change.&#10;    When context is False, controls the number of lines to place&#10;    the "next" link anchors before the next change (so click of&#10;    "next" link jumps to just before the change).'>
				<Param name="self" />
				<Param name="fromlines" />
				<Param name="tolines" />
				<Param name="[fromdesc" />
				<Param name="[todesc" />
				<Param name="[context=False" />
				<Param name="[numlines=5]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.HtmlDiff.make_table" func="yes">
			<Overload retVal="" descr='Returns HTML table of side by side comparison with change highlights&#10;&#10;Arguments:&#10;fromlines -- list of "from" lines&#10;tolines -- list of "to" lines&#10;fromdesc -- "from" file column header string&#10;todesc -- "to" file column header string&#10;context -- set to True for contextual differences (defaults to False&#10;    which shows full differences).&#10;numlines -- number of context lines.  When context is set True,&#10;    controls number of lines displayed before and after the change.&#10;    When context is False, controls the number of lines to place&#10;    the "next" link anchors before the next change (so click of&#10;    "next" link jumps to just before the change).'>
				<Param name="self" />
				<Param name="fromlines" />
				<Param name="tolines" />
				<Param name="[fromdesc" />
				<Param name="[todesc" />
				<Param name="[context=False" />
				<Param name="[numlines=5]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.IS_CHARACTER_JUNK" func="yes">
			<Overload retVal="" descr="Return 1 for ignorable character: iff `ch` is a space or tab.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK(' ')&#10;True&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK('\t')&#10;True&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK('\n')&#10;False&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK('x')&#10;False">
				<Param name="ch" />
				<Param name="[ws= 	]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.IS_LINE_JUNK" func="yes">
			<Overload retVal="" descr="Return 1 for ignorable line: iff `line` is blank or contains a single '#'.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; IS_LINE_JUNK('\n')&#10;True&#10;&gt;&gt;&gt; IS_LINE_JUNK('  #   \n')&#10;True&#10;&gt;&gt;&gt; IS_LINE_JUNK('hello\n')&#10;False">
				<Param name="line" />
				<Param name="[pat=<built-in method match of _sre.SRE_Pattern object at 0x000000000385A6B0>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match" func="yes">
			<Overload retVal="" descr="Match(a, b, size)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.a" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.b" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.size" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.context_diff" func="yes">
			<Overload retVal="" descr="Compare two sequences of lines; generate the delta as a context diff.&#10;&#10;Context diffs are a compact way of showing line changes and a few&#10;lines of context.  The number of context lines is set by 'n' which&#10;defaults to three.&#10;&#10;By default, the diff control lines (those with *** or ---) are&#10;created with a trailing newline.  This is helpful so that inputs&#10;created from file.readlines() result in diffs that are suitable for&#10;file.writelines() since both the inputs and outputs have trailing&#10;newlines.&#10;&#10;For inputs that do not have trailing newlines, set the lineterm&#10;argument to &quot;&quot; so that the output will be uniformly newline free.&#10;&#10;The context diff format normally has a header for filenames and&#10;modification times.  Any or all of these may be specified using&#10;strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.&#10;The modification times are normally expressed in the ISO 8601 format.&#10;If not specified, the strings default to blanks.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; print ''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(1),&#10;...       'zero\none\ntree\nfour\n'.splitlines(1), 'Original', 'Current')),&#10;*** Original&#10;--- Current&#10;***************&#10;*** 1,4 ****&#10;  one&#10;! two&#10;! three&#10;  four&#10;--- 1,4 ----&#10;+ zero&#10;  one&#10;! tree&#10;  four">
				<Param name="a" />
				<Param name="b" />
				<Param name="[fromfile" />
				<Param name="[tofile" />
				<Param name="[fromfiledate" />
				<Param name="[tofiledate" />
				<Param name="[n=3" />
				<Param name="[lineterm=
]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.get_close_matches" func="yes">
			<Overload retVal="" descr="Use SequenceMatcher to return list of the best &quot;good enough&quot; matches.&#10;&#10;word is a sequence for which close matches are desired (typically a&#10;string).&#10;&#10;possibilities is a list of sequences against which to match word&#10;(typically a list of strings).&#10;&#10;Optional arg n (default 3) is the maximum number of close matches to&#10;return.  n must be &gt; 0.&#10;&#10;Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities&#10;that don't score at least that similar to word are ignored.&#10;&#10;The best (no more than n) matches among the possibilities are returned&#10;in a list, sorted by similarity score, most similar first.&#10;&#10;&gt;&gt;&gt; get_close_matches(&quot;appel&quot;, [&quot;ape&quot;, &quot;apple&quot;, &quot;peach&quot;, &quot;puppy&quot;])&#10;['apple', 'ape']&#10;&gt;&gt;&gt; import keyword as _keyword&#10;&gt;&gt;&gt; get_close_matches(&quot;wheel&quot;, _keyword.kwlist)&#10;['while']&#10;&gt;&gt;&gt; get_close_matches(&quot;apple&quot;, _keyword.kwlist)&#10;[]&#10;&gt;&gt;&gt; get_close_matches(&quot;accept&quot;, _keyword.kwlist)&#10;['except']">
				<Param name="word" />
				<Param name="possibilities" />
				<Param name="[n=3" />
				<Param name="[cutoff=0.6]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.ndiff" func="yes">
			<Overload retVal="" descr="Compare `a` and `b` (lists of strings); return a `Differ`-style delta.&#10;&#10;Optional keyword parameters `linejunk` and `charjunk` are for filter&#10;functions (or None):&#10;&#10;- linejunk: A function that should accept a single string argument, and&#10;  return true iff the string is junk.  The default is None, and is&#10;  recommended; as of Python 2.3, an adaptive notion of &quot;noise&quot; lines is&#10;  used that does a good job on its own.&#10;&#10;- charjunk: A function that should accept a string of length 1. The&#10;  default is module-level function IS_CHARACTER_JUNK, which filters out&#10;  whitespace characters (a blank or tab; note: bad idea to include newline&#10;  in this!).&#10;&#10;Tools/scripts/ndiff.py is a command-line front-end to this function.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(1),&#10;...              'ore\ntree\nemu\n'.splitlines(1))&#10;&gt;&gt;&gt; print ''.join(diff),&#10;- one&#10;?  ^&#10;+ ore&#10;?  ^&#10;- two&#10;- three&#10;?  -&#10;+ tree&#10;+ emu">
				<Param name="a" />
				<Param name="b" />
				<Param name="[linejunk=None" />
				<Param name="[charjunk=<function IS_CHARACTER_JUNK at 0x000000000391F518>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.reduce" func="yes">
			<Overload retVal="" descr="reduce(function, sequence[, initial]) -&gt; value&#10;&#10;Apply a function of two arguments cumulatively to the items of a sequence,&#10;from left to right, so as to reduce the sequence to a single value.&#10;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#10;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#10;of the sequence in the calculation, and serves as a default when the&#10;sequence is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.restore" func="yes">
			<Overload retVal="" descr="Generate one of the two sequences that generated a delta.&#10;&#10;Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract&#10;lines originating from file 1 or 2 (parameter `which`), stripping off line&#10;prefixes.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(1),&#10;...              'ore\ntree\nemu\n'.splitlines(1))&#10;&gt;&gt;&gt; diff = list(diff)&#10;&gt;&gt;&gt; print ''.join(restore(diff, 1)),&#10;one&#10;two&#10;three&#10;&gt;&gt;&gt; print ''.join(restore(diff, 2)),&#10;ore&#10;tree&#10;emu">
				<Param name="delta" />
				<Param name="which" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.unified_diff" func="yes">
			<Overload retVal="" descr="Compare two sequences of lines; generate the delta as a unified diff.&#10;&#10;Unified diffs are a compact way of showing line changes and a few&#10;lines of context.  The number of context lines is set by 'n' which&#10;defaults to three.&#10;&#10;By default, the diff control lines (those with ---, +++, or @@) are&#10;created with a trailing newline.  This is helpful so that inputs&#10;created from file.readlines() result in diffs that are suitable for&#10;file.writelines() since both the inputs and outputs have trailing&#10;newlines.&#10;&#10;For inputs that do not have trailing newlines, set the lineterm&#10;argument to &quot;&quot; so that the output will be uniformly newline free.&#10;&#10;The unidiff format normally has a header for filenames and modification&#10;times.  Any or all of these may be specified using strings for&#10;'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.&#10;The modification times are normally expressed in the ISO 8601 format.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; for line in unified_diff('one two three four'.split(),&#10;...             'zero one tree four'.split(), 'Original', 'Current',&#10;...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',&#10;...             lineterm=''):&#10;...     print line                  # doctest: +NORMALIZE_WHITESPACE&#10;--- Original        2005-01-26 23:30:50&#10;+++ Current         2010-04-02 10:20:52&#10;@@ -1,4 +1,4 @@&#10;+zero&#10; one&#10;-two&#10;-three&#10;+tree&#10; four">
				<Param name="a" />
				<Param name="b" />
				<Param name="[fromfile" />
				<Param name="[tofile" />
				<Param name="[fromfiledate" />
				<Param name="[tofiledate" />
				<Param name="[n=3" />
				<Param name="[lineterm=
]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="digit" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="dir" func="yes">
			<Overload retVal="" descr="dir([object]) -&gt; list of strings&#10;&#10;If called without an argument, return the names in the current scope.&#10;Else, return an alphabetized list of names comprising (some of) the attributes&#10;of the given object, and of attributes reachable from it.&#10;If the object supplies a method named __dir__, it will be used; otherwise&#10;the default dir() logic is used and returns:&#10;  for a module object: the module's attributes.&#10;  for a class object:  its attributes, and recursively the attributes&#10;    of its bases.&#10;  for any other object: its attributes, its class's attributes, and&#10;    recursively the attributes of its class's base classes.">
			</Overload>
		</KeyWord>
		<KeyWord name="dircache" func="yes">
			<Overload retVal="" descr="Read and cache directory listings.&#10;&#10;The listdir() routine returns a sorted list of the files in a directory,&#10;using a cache to avoid reading the directory more often than necessary.&#10;The annotate() routine appends slashes to directories.">
			</Overload>
		</KeyWord>
		<KeyWord name="dircache.annotate" func="yes">
			<Overload retVal="" descr="Add '/' suffixes to directories.">
				<Param name="head" />
				<Param name="list" />
			</Overload>
		</KeyWord>
		<KeyWord name="dircache.listdir" func="yes">
			<Overload retVal="" descr="List directory contents, using cache.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="dircache.opendir" func="yes">
			<Overload retVal="" descr="List directory contents, using cache.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="dircache.reset" func="yes">
			<Overload retVal="" descr="Reset the cache completely.">
			</Overload>
		</KeyWord>
		<KeyWord name="dirname" func="yes">
			<Overload retVal="" descr="Function of os2emxpath">
			</Overload>
		</KeyWord>
		<KeyWord name="dis" func="yes">
			<Overload retVal="" descr="Disassembler of Python byte code into mnemonics.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.EXTENDED_ARG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.HAVE_ARGUMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.cmp_op" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.dis" func="yes">
			<Overload retVal="" descr="Disassemble classes, methods, functions, or code.&#10;&#10;With no argument, disassemble the last traceback.">
				<Param name="[x=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.disassemble" func="yes">
			<Overload retVal="" descr="Disassemble a code object.">
				<Param name="co" />
				<Param name="[lasti=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.disassemble_string" func="yes">
			<Overload retVal="" descr=>
				<Param name="code" />
				<Param name="[lasti=-1" />
				<Param name="[varnames=None" />
				<Param name="[names=None" />
				<Param name="[constants=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.disco" func="yes">
			<Overload retVal="" descr="Disassemble a code object.">
				<Param name="co" />
				<Param name="[lasti=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.distb" func="yes">
			<Overload retVal="" descr="Disassemble a traceback (default: last traceback).">
				<Param name="[tb=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.findlabels" func="yes">
			<Overload retVal="" descr="Detect all offsets in a byte code which are jump targets.&#10;&#10;Return the list of offsets.">
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.findlinestarts" func="yes">
			<Overload retVal="" descr="Find the offsets in a byte code which are start of lines in the source.&#10;&#10;Generate pairs (offset, lineno) as described in Python/compile.c.">
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hascompare" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasconst" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasfree" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasjabs" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasjrel" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.haslocal" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.opmap" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.opname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="disable" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="disassemble" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="disassemble_string" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="discard" func="yes">
			<Overload retVal="" descr="Remove an element from a set if it is a member.&#10;&#10;If the element is not a member, do nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="disco" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="discover" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="display" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cache">
			</Overload>
		</KeyWord>
		<KeyWord name="dist" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="distance" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="distb" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="distutils" func="yes">
			<Overload retVal="" descr="distutils&#10;&#10;The main package for the Python Module Distribution Utilities.  Normally&#10;used from a setup script as&#10;&#10;   from distutils.core import setup&#10;&#10;   setup (...)">
			</Overload>
		</KeyWord>
		<KeyWord name="divide" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="divide_int" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="divmod" func="yes">
			<Overload retVal="" descr="divmod(x, y) -&gt; (quotient, remainder)&#10;&#10;Return the tuple ((x-x%y)/y, x%y).  Invariant: div*y + mod == x.">
			</Overload>
		</KeyWord>
		<KeyWord name="dnd_start" func="yes">
			<Overload retVal="" descr="Function of Tkdnd">
			</Overload>
		</KeyWord>
		<KeyWord name="dngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="doCleanups" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="do_handshake" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="do_longs" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="do_shorts" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="doc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest" func="yes">
			<Overload retVal="" descr="Module doctest -- a framework for running examples in docstrings.&#10;&#10;In simplest use, end each module M to be tested with:&#10;&#10;def _test():&#10;    import doctest&#10;    doctest.testmod()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    _test()&#10;&#10;Then running the module as a script will cause the examples in the&#10;docstrings to get executed and verified:&#10;&#10;python M.py&#10;&#10;This won't display anything unless an example fails, in which case the&#10;failing example(s) and the cause(s) of the failure(s) are printed to stdout&#10;(why not stderr? because stderr is a lame hack &lt;0.2 wink&gt;), and the final&#10;line of output is &quot;Test failed.&quot;.&#10;&#10;Run it with the -v switch instead:&#10;&#10;python M.py -v&#10;&#10;and a detailed report of all examples tried is printed to stdout, along&#10;with assorted summaries at the end.&#10;&#10;You can force verbose mode by passing &quot;verbose=True&quot; to testmod, or prohibit&#10;it by passing &quot;verbose=False&quot;.  In either of those cases, sys.argv is not&#10;examined by testmod.&#10;&#10;There are a variety of other ways to run doctests, including integration&#10;with the unittest framework, and support for running non-Python text&#10;files containing doctests.  There are also many ways to override parts&#10;of doctest's default behaviors.  See the Library Reference Manual for&#10;details.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.BLANKLINE_MARKER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.COMPARISON_FLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DONT_ACCEPT_BLANKLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DONT_ACCEPT_TRUE_FOR_1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase" />
		<KeyWord name="doctest.DocFileCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether actual is a superset of expected.">
				<Param name="self" />
				<Param name="expected" />
				<Param name="actual" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertItemsEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence specific comparison. It asserts that&#10;actual_seq and expected_seq have the same element counts.&#10;Equivalent to::&#10;&#10;    self.assertEqual(Counter(iter(actual_seq)),&#10;                     Counter(iter(expected_seq)))&#10;&#10;Asserts that each element has the same count in both sequences.&#10;Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="expected_seq" />
				<Param name="actual_seq" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class excClass is raised&#10;by callableObj when invoked with arguments args and keyword&#10;arguments kwargs. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with callableObj omitted or None, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="excClass" />
				<Param name="[callableObj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regexp.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regexp: Regexp (re pattern object or string) expected&#10;            to be found in error message.&#10;    callable_obj: Function to be called.&#10;    args: Extra args.&#10;    kwargs: Extra kwargs.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regexp" />
				<Param name="[callable_obj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.countTestCases" />
		<KeyWord name="doctest.DocFileCase.debug" func="yes">
			<Overload retVal="" descr="Run the test case without results and without catching exceptions&#10;&#10;The unit test framework includes a debug method on test cases&#10;and test suites to support post-mortem debugging.  The test code&#10;is run in such a way that errors are not caught.  This way a&#10;caller can catch the errors and initiate post-mortem debugging.&#10;&#10;The DocTestCase provides a debug method that raises&#10;UnexpectedException errors if there is an unexpected&#10;exception:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;  &gt;&gt;&gt; try:&#10;  ...     case.debug()&#10;  ... except UnexpectedException, failure:&#10;  ...     pass&#10;&#10;The UnexpectedException contains the test, the example, and&#10;the original exception:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[0], exc_info[1], exc_info[2]&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    case.debug()&#10;  ... except DocTestFailure, failure:&#10;  ...    pass&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.defaultTestResult" />
		<KeyWord name="doctest.DocFileCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.format_failure" />
		<KeyWord name="doctest.DocFileCase.id" />
		<KeyWord name="doctest.DocFileCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.runTest" />
		<KeyWord name="doctest.DocFileCase.setUp" />
		<KeyWord name="doctest.DocFileCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.shortDescription" />
		<KeyWord name="doctest.DocFileCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.tearDown" />
		<KeyWord name="doctest.DocFileCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileSuite" func="yes">
			<Overload retVal="" descr="A unittest suite for one or more doctest files.&#10;&#10;The path to each doctest file is given as a string; the&#10;interpretation of that string depends on the keyword argument&#10;&quot;module_relative&quot;.&#10;&#10;A number of options may be provided as keyword arguments:&#10;&#10;module_relative&#10;  If &quot;module_relative&quot; is True, then the given file paths are&#10;  interpreted as os-independent module-relative paths.  By&#10;  default, these paths are relative to the calling module's&#10;  directory; but if the &quot;package&quot; argument is specified, then&#10;  they are relative to that package.  To ensure os-independence,&#10;  &quot;filename&quot; should use &quot;/&quot; characters to separate path&#10;  segments, and may not be an absolute path (i.e., it may not&#10;  begin with &quot;/&quot;).&#10;&#10;  If &quot;module_relative&quot; is False, then the given file paths are&#10;  interpreted as os-specific paths.  These paths may be absolute&#10;  or relative (to the current working directory).&#10;&#10;package&#10;  A Python package or the name of a Python package whose directory&#10;  should be used as the base directory for module relative paths.&#10;  If &quot;package&quot; is not specified, then the calling module's&#10;  directory is used as the base directory for module relative&#10;  filenames.  It is an error to specify &quot;package&quot; if&#10;  &quot;module_relative&quot; is False.&#10;&#10;setUp&#10;  A set-up function.  This is called before running the&#10;  tests in each file. The setUp function will be passed a DocTest&#10;  object.  The setUp function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;tearDown&#10;  A tear-down function.  This is called after running the&#10;  tests in each file.  The tearDown function will be passed a DocTest&#10;  object.  The tearDown function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;globs&#10;  A dictionary containing initial global variables for the tests.&#10;&#10;optionflags&#10;  A set of doctest option flags expressed as an integer.&#10;&#10;parser&#10;  A DocTestParser (or subclass) that should be used to extract&#10;  tests from the files.&#10;&#10;encoding&#10;  An encoding that will be used to convert the files to unicode.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileTest" func="yes">
			<Overload retVal="" descr=>
				<Param name="path" />
				<Param name="[module_relative=True" />
				<Param name="[package=None" />
				<Param name="[globs=None" />
				<Param name="[parser=<doctest.DocTestParser instance at 0x00000000039B2748>" />
				<Param name="[encoding=None" />
				<Param name="[**]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTest" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase" />
		<KeyWord name="doctest.DocTestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether actual is a superset of expected.">
				<Param name="self" />
				<Param name="expected" />
				<Param name="actual" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertItemsEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence specific comparison. It asserts that&#10;actual_seq and expected_seq have the same element counts.&#10;Equivalent to::&#10;&#10;    self.assertEqual(Counter(iter(actual_seq)),&#10;                     Counter(iter(expected_seq)))&#10;&#10;Asserts that each element has the same count in both sequences.&#10;Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="expected_seq" />
				<Param name="actual_seq" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class excClass is raised&#10;by callableObj when invoked with arguments args and keyword&#10;arguments kwargs. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with callableObj omitted or None, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="excClass" />
				<Param name="[callableObj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regexp.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regexp: Regexp (re pattern object or string) expected&#10;            to be found in error message.&#10;    callable_obj: Function to be called.&#10;    args: Extra args.&#10;    kwargs: Extra kwargs.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regexp" />
				<Param name="[callable_obj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.countTestCases" />
		<KeyWord name="doctest.DocTestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test case without results and without catching exceptions&#10;&#10;The unit test framework includes a debug method on test cases&#10;and test suites to support post-mortem debugging.  The test code&#10;is run in such a way that errors are not caught.  This way a&#10;caller can catch the errors and initiate post-mortem debugging.&#10;&#10;The DocTestCase provides a debug method that raises&#10;UnexpectedException errors if there is an unexpected&#10;exception:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;  &gt;&gt;&gt; try:&#10;  ...     case.debug()&#10;  ... except UnexpectedException, failure:&#10;  ...     pass&#10;&#10;The UnexpectedException contains the test, the example, and&#10;the original exception:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[0], exc_info[1], exc_info[2]&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    case.debug()&#10;  ... except DocTestFailure, failure:&#10;  ...    pass&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.defaultTestResult" />
		<KeyWord name="doctest.DocTestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.format_failure" />
		<KeyWord name="doctest.DocTestCase.id" />
		<KeyWord name="doctest.DocTestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.runTest" />
		<KeyWord name="doctest.DocTestCase.setUp" />
		<KeyWord name="doctest.DocTestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.shortDescription" />
		<KeyWord name="doctest.DocTestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.tearDown" />
		<KeyWord name="doctest.DocTestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFailure" func="yes">
			<Overload retVal="" descr="A DocTest example has failed in debugging mode.&#10;&#10;The exception instance has variables:&#10;&#10;- test: the DocTest object being run&#10;&#10;- example: the Example object that failed&#10;&#10;- got: the actual output">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFailure.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFailure.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFinder" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestSuite" func="yes">
			<Overload retVal="" descr="Convert doctest tests for a module to a unittest test suite.&#10;&#10;This converts each documentation string in a module that&#10;contains doctest tests to a unittest test case.  If any of the&#10;tests in a doc string fail, then the test case fails.  An exception&#10;is raised showing the name of the file containing the test and a&#10;(sometimes approximate) line number.&#10;&#10;The `module` argument provides the module to be tested.  The argument&#10;can be either a module or a module name.&#10;&#10;If no argument is given, the calling module is used.&#10;&#10;A number of options may be provided as keyword arguments:&#10;&#10;setUp&#10;  A set-up function.  This is called before running the&#10;  tests in each file. The setUp function will be passed a DocTest&#10;  object.  The setUp function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;tearDown&#10;  A tear-down function.  This is called after running the&#10;  tests in each file.  The tearDown function will be passed a DocTest&#10;  object.  The tearDown function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;globs&#10;  A dictionary containing initial global variables for the tests.&#10;&#10;optionflags&#10;   A set of doctest option flags expressed as an integer.">
				<Param name="[module=None" />
				<Param name="[globs=None" />
				<Param name="[extraglobs=None" />
				<Param name="[test_finder=None" />
				<Param name="[**]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.ELLIPSIS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.ELLIPSIS_MARKER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.Example" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.IGNORE_EXCEPTION_DETAIL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.NORMALIZE_WHITESPACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.OPTIONFLAGS_BY_NAME" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.OutputChecker" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORTING_FLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_CDIFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_NDIFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_ONLY_FIRST_FAILURE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_UDIFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SKIP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase" />
		<KeyWord name="doctest.SkipDocTestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether actual is a superset of expected.">
				<Param name="self" />
				<Param name="expected" />
				<Param name="actual" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertItemsEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence specific comparison. It asserts that&#10;actual_seq and expected_seq have the same element counts.&#10;Equivalent to::&#10;&#10;    self.assertEqual(Counter(iter(actual_seq)),&#10;                     Counter(iter(expected_seq)))&#10;&#10;Asserts that each element has the same count in both sequences.&#10;Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="expected_seq" />
				<Param name="actual_seq" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class excClass is raised&#10;by callableObj when invoked with arguments args and keyword&#10;arguments kwargs. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with callableObj omitted or None, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="excClass" />
				<Param name="[callableObj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regexp.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regexp: Regexp (re pattern object or string) expected&#10;            to be found in error message.&#10;    callable_obj: Function to be called.&#10;    args: Extra args.&#10;    kwargs: Extra kwargs.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regexp" />
				<Param name="[callable_obj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.countTestCases" />
		<KeyWord name="doctest.SkipDocTestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test case without results and without catching exceptions&#10;&#10;The unit test framework includes a debug method on test cases&#10;and test suites to support post-mortem debugging.  The test code&#10;is run in such a way that errors are not caught.  This way a&#10;caller can catch the errors and initiate post-mortem debugging.&#10;&#10;The DocTestCase provides a debug method that raises&#10;UnexpectedException errors if there is an unexpected&#10;exception:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;  &gt;&gt;&gt; try:&#10;  ...     case.debug()&#10;  ... except UnexpectedException, failure:&#10;  ...     pass&#10;&#10;The UnexpectedException contains the test, the example, and&#10;the original exception:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[0], exc_info[1], exc_info[2]&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    case.debug()&#10;  ... except DocTestFailure, failure:&#10;  ...    pass&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.defaultTestResult" />
		<KeyWord name="doctest.SkipDocTestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.format_failure" />
		<KeyWord name="doctest.SkipDocTestCase.id" />
		<KeyWord name="doctest.SkipDocTestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.runTest" />
		<KeyWord name="doctest.SkipDocTestCase.setUp" />
		<KeyWord name="doctest.SkipDocTestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.shortDescription" />
		<KeyWord name="doctest.SkipDocTestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.tearDown" />
		<KeyWord name="doctest.SkipDocTestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.test_skip" />
		<KeyWord name="doctest.StringIO" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults" func="yes">
			<Overload retVal="" descr="TestResults(failed, attempted)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.attempted" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.failed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.Tester" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.UnexpectedException" func="yes">
			<Overload retVal="" descr="A DocTest example has encountered an unexpected exception&#10;&#10;The exception instance has variables:&#10;&#10;- test: the DocTest object being run&#10;&#10;- example: the Example object that failed&#10;&#10;- exc_info: the exception info">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.UnexpectedException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.UnexpectedException.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.debug" func="yes">
			<Overload retVal="" descr="Debug a single doctest docstring.&#10;&#10;Provide the module (or dotted name of the module) containing the&#10;test to be debugged and the name (within the module) of the object&#10;with the docstring with tests to be debugged.">
				<Param name="module" />
				<Param name="name" />
				<Param name="[pm=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.debug_script" func="yes">
			<Overload retVal="" descr="Debug a test script.  `src` is the script, as a string.">
				<Param name="src" />
				<Param name="[pm=False" />
				<Param name="[globs=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.debug_src" func="yes">
			<Overload retVal="" descr="Debug a single doctest docstring, in argument `src`'">
				<Param name="src" />
				<Param name="[pm=False" />
				<Param name="[globs=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
				<Param name="typename" />
				<Param name="field_names" />
				<Param name="[verbose=False" />
				<Param name="[rename=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.register_optionflag" />
		<KeyWord name="doctest.run_docstring_examples" func="yes">
			<Overload retVal="" descr="Test examples in the given object's docstring (`f`), using `globs`&#10;as globals.  Optional argument `name` is used in failure messages.&#10;If the optional argument `verbose` is true, then generate output&#10;even if there are no failures.&#10;&#10;`compileflags` gives the set of flags that should be used by the&#10;Python compiler when running the examples.  If not specified, then&#10;it will default to the set of future-import flags that apply to&#10;`globs`.&#10;&#10;Optional keyword arg `optionflags` specifies options for the&#10;testing and output.  See the documentation for `testmod` for more&#10;information.">
				<Param name="f" />
				<Param name="globs" />
				<Param name="[verbose=False" />
				<Param name="[name=NoName" />
				<Param name="[compileflags=None" />
				<Param name="[optionflags=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.script_from_examples" func="yes">
			<Overload retVal="" descr="Extract script from text with examples.&#10;&#10;Converts text with examples to a Python script.  Example input is&#10;converted to regular code.  Example output and all other words&#10;are converted to comments:&#10;&#10;&gt;&gt;&gt; text = '''&#10;...       Here are examples of simple math.&#10;...&#10;...           Python has super accurate integer addition&#10;...&#10;...           &gt;&gt;&gt; 2 + 2&#10;...           5&#10;...&#10;...           And very friendly error messages:&#10;...&#10;...           &gt;&gt;&gt; 1/0&#10;...           To Infinity&#10;...           And&#10;...           Beyond&#10;...&#10;...           You can use logic if you want:&#10;...&#10;...           &gt;&gt;&gt; if 0:&#10;...           ...    blah&#10;...           ...    blah&#10;...           ...&#10;...&#10;...           Ho hum&#10;...           '''&#10;&#10;&gt;&gt;&gt; print script_from_examples(text)&#10;# Here are examples of simple math.&#10;#&#10;#     Python has super accurate integer addition&#10;#&#10;2 + 2&#10;# Expected:&#10;## 5&#10;#&#10;#     And very friendly error messages:&#10;#&#10;1/0&#10;# Expected:&#10;## To Infinity&#10;## And&#10;## Beyond&#10;#&#10;#     You can use logic if you want:&#10;#&#10;if 0:&#10;   blah&#10;   blah&#10;#&#10;#     Ho hum&#10;&lt;BLANKLINE&gt;">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.set_unittest_reportflags" func="yes">
			<Overload retVal="" descr="Sets the unittest option flags.&#10;&#10;The old flag is returned so that a runner could restore the old&#10;value if it wished to:&#10;&#10;  &gt;&gt;&gt; import doctest&#10;  &gt;&gt;&gt; old = doctest._unittest_reportflags&#10;  &gt;&gt;&gt; doctest.set_unittest_reportflags(REPORT_NDIFF |&#10;  ...                          REPORT_ONLY_FIRST_FAILURE) == old&#10;  True&#10;&#10;  &gt;&gt;&gt; doctest._unittest_reportflags == (REPORT_NDIFF |&#10;  ...                                   REPORT_ONLY_FIRST_FAILURE)&#10;  True&#10;&#10;Only reporting flags can be set:&#10;&#10;  &gt;&gt;&gt; doctest.set_unittest_reportflags(ELLIPSIS)&#10;  Traceback (most recent call last):&#10;  ...&#10;  ValueError: ('Only reporting flags allowed', 8)&#10;&#10;  &gt;&gt;&gt; doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |&#10;  ...                                   REPORT_ONLY_FIRST_FAILURE)&#10;  True">
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.testfile" func="yes">
			<Overload retVal="" descr="Test examples in the given file.  Return (#failures, #tests).&#10;&#10;Optional keyword arg &quot;module_relative&quot; specifies how filenames&#10;should be interpreted:&#10;&#10;  - If &quot;module_relative&quot; is True (the default), then &quot;filename&quot;&#10;     specifies a module-relative path.  By default, this path is&#10;     relative to the calling module's directory; but if the&#10;     &quot;package&quot; argument is specified, then it is relative to that&#10;     package.  To ensure os-independence, &quot;filename&quot; should use&#10;     &quot;/&quot; characters to separate path segments, and should not&#10;     be an absolute path (i.e., it may not begin with &quot;/&quot;).&#10;&#10;  - If &quot;module_relative&quot; is False, then &quot;filename&quot; specifies an&#10;    os-specific path.  The path may be absolute or relative (to&#10;    the current working directory).&#10;&#10;Optional keyword arg &quot;name&quot; gives the name of the test; by default&#10;use the file's basename.&#10;&#10;Optional keyword argument &quot;package&quot; is a Python package or the&#10;name of a Python package whose directory should be used as the&#10;base directory for a module relative filename.  If no package is&#10;specified, then the calling module's directory is used as the base&#10;directory for module relative filenames.  It is an error to&#10;specify &quot;package&quot; if &quot;module_relative&quot; is False.&#10;&#10;Optional keyword arg &quot;globs&quot; gives a dict to be used as the globals&#10;when executing examples; by default, use {}.  A copy of this dict&#10;is actually used for each docstring, so that each docstring's&#10;examples start with a clean slate.&#10;&#10;Optional keyword arg &quot;extraglobs&quot; gives a dictionary that should be&#10;merged into the globals that are used to execute examples.  By&#10;default, no extra globals are used.&#10;&#10;Optional keyword arg &quot;verbose&quot; prints lots of stuff if true, prints&#10;only failures if false; by default, it's true iff &quot;-v&quot; is in sys.argv.&#10;&#10;Optional keyword arg &quot;report&quot; prints a summary at the end when true,&#10;else prints nothing at the end.  In verbose mode, the summary is&#10;detailed, else very brief (in fact, empty if all tests passed).&#10;&#10;Optional keyword arg &quot;optionflags&quot; or's together module constants,&#10;and defaults to 0.  Possible values (see the docs for details):&#10;&#10;    DONT_ACCEPT_TRUE_FOR_1&#10;    DONT_ACCEPT_BLANKLINE&#10;    NORMALIZE_WHITESPACE&#10;    ELLIPSIS&#10;    SKIP&#10;    IGNORE_EXCEPTION_DETAIL&#10;    REPORT_UDIFF&#10;    REPORT_CDIFF&#10;    REPORT_NDIFF&#10;    REPORT_ONLY_FIRST_FAILURE&#10;&#10;Optional keyword arg &quot;raise_on_error&quot; raises an exception on the&#10;first unexpected exception or failure. This allows failures to be&#10;post-mortem debugged.&#10;&#10;Optional keyword arg &quot;parser&quot; specifies a DocTestParser (or&#10;subclass) that should be used to extract tests from the files.&#10;&#10;Optional keyword arg &quot;encoding&quot; specifies an encoding that should&#10;be used to convert the file to unicode.&#10;&#10;Advanced tomfoolery:  testmod runs methods of a local instance of&#10;class doctest.Tester, then merges the results into (or creates)&#10;global Tester instance doctest.master.  Methods of doctest.master&#10;can be called directly too, if you want to do something unusual.&#10;Passing report=0 to testmod is especially useful then, to delay&#10;displaying a summary.  Invoke doctest.master.summarize(verbose)&#10;when you're done fiddling.">
				<Param name="filename" />
				<Param name="[module_relative=True" />
				<Param name="[name=None" />
				<Param name="[package=None" />
				<Param name="[globs=None" />
				<Param name="[verbose=None" />
				<Param name="[report=True" />
				<Param name="[optionflags=0" />
				<Param name="[extraglobs=None" />
				<Param name="[raise_on_error=False" />
				<Param name="[parser=<doctest.DocTestParser instance at 0x00000000039B2908>" />
				<Param name="[encoding=None]]]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.testmod" func="yes">
			<Overload retVal="" descr="m=None, name=None, globs=None, verbose=None, report=True,&#10;   optionflags=0, extraglobs=None, raise_on_error=False,&#10;   exclude_empty=False&#10;&#10;Test examples in docstrings in functions and classes reachable&#10;from module m (or the current module if m is not supplied), starting&#10;with m.__doc__.&#10;&#10;Also test examples reachable from dict m.__test__ if it exists and is&#10;not None.  m.__test__ maps names to functions, classes and strings;&#10;function and class docstrings are tested even if the name is private;&#10;strings are tested directly, as if they were docstrings.&#10;&#10;Return (#failures, #tests).&#10;&#10;See help(doctest) for an overview.&#10;&#10;Optional keyword arg &quot;name&quot; gives the name of the module; by default&#10;use m.__name__.&#10;&#10;Optional keyword arg &quot;globs&quot; gives a dict to be used as the globals&#10;when executing examples; by default, use m.__dict__.  A copy of this&#10;dict is actually used for each docstring, so that each docstring's&#10;examples start with a clean slate.&#10;&#10;Optional keyword arg &quot;extraglobs&quot; gives a dictionary that should be&#10;merged into the globals that are used to execute examples.  By&#10;default, no extra globals are used.  This is new in 2.4.&#10;&#10;Optional keyword arg &quot;verbose&quot; prints lots of stuff if true, prints&#10;only failures if false; by default, it's true iff &quot;-v&quot; is in sys.argv.&#10;&#10;Optional keyword arg &quot;report&quot; prints a summary at the end when true,&#10;else prints nothing at the end.  In verbose mode, the summary is&#10;detailed, else very brief (in fact, empty if all tests passed).&#10;&#10;Optional keyword arg &quot;optionflags&quot; or's together module constants,&#10;and defaults to 0.  This is new in 2.3.  Possible values (see the&#10;docs for details):&#10;&#10;    DONT_ACCEPT_TRUE_FOR_1&#10;    DONT_ACCEPT_BLANKLINE&#10;    NORMALIZE_WHITESPACE&#10;    ELLIPSIS&#10;    SKIP&#10;    IGNORE_EXCEPTION_DETAIL&#10;    REPORT_UDIFF&#10;    REPORT_CDIFF&#10;    REPORT_NDIFF&#10;    REPORT_ONLY_FIRST_FAILURE&#10;&#10;Optional keyword arg &quot;raise_on_error&quot; raises an exception on the&#10;first unexpected exception or failure. This allows failures to be&#10;post-mortem debugged.&#10;&#10;Advanced tomfoolery:  testmod runs methods of a local instance of&#10;class doctest.Tester, then merges the results into (or creates)&#10;global Tester instance doctest.master.  Methods of doctest.master&#10;can be called directly too, if you want to do something unusual.&#10;Passing report=0 to testmod is especially useful then, to delay&#10;displaying a summary.  Invoke doctest.master.summarize(verbose)&#10;when you're done fiddling.">
				<Param name="[m=None" />
				<Param name="[name=None" />
				<Param name="[globs=None" />
				<Param name="[verbose=None" />
				<Param name="[report=True" />
				<Param name="[optionflags=0" />
				<Param name="[extraglobs=None" />
				<Param name="[raise_on_error=False" />
				<Param name="[exclude_empty=False]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.testsource" func="yes">
			<Overload retVal="" descr="Extract the test sources from a doctest docstring as a script.&#10;&#10;Provide the module (or dotted name of the module) containing the&#10;test to be debugged and the name (within the module) of the object&#10;with the doc string with tests to be debugged.">
				<Param name="module" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="dolog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="domain_match" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="done" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="dot" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="down" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="dst" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm" func="yes">
			<Overload retVal="" descr="A dumb and slow but simple dbm clone.&#10;&#10;For database spam, spam.dir contains the index (a text file),&#10;spam.bak *may* contain a backup of the index (also a text file),&#10;while spam.dat contains the data (a binary file).&#10;&#10;XXX TO DO:&#10;&#10;- seems to contain a bug when updating...&#10;&#10;- reclaim free space (currently, space once occupied by deleted or expanded&#10;items is never reused)&#10;&#10;- support concurrent access (currently, if two processes take turns making&#10;updates, they can mess up the index)&#10;&#10;- support efficient access to large databases (currently, the whole index&#10;is read when the database is opened, and some updates rewrite the whole index)&#10;&#10;- support opening for read-only (flag = 'm')">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.error" func="yes">
			<Overload retVal="" descr="I/O operation failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dumbdbm.open" func="yes">
			<Overload retVal="" descr="Open the database file, filename, and return corresponding object.&#10;&#10;The flag argument, used to control how the database is opened in the&#10;other DBM implementations, is ignored in the dumbdbm module; the&#10;database is always opened for update, and will be created if it does&#10;not exist.&#10;&#10;The optional mode argument is the UNIX mode of the file, used only when&#10;the database has to be created.  It defaults to octal code 0666 (and&#10;will be modified by the prevailing umask).">
				<Param name="file" />
				<Param name="[flag=None" />
				<Param name="[mode=438]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread" func="yes">
			<Overload retVal="" descr="Drop-in replacement for the thread module.&#10;&#10;Meant to be used as a brain-dead substitute so that threaded code does&#10;not need to be rewritten for when the thread module is not present.&#10;&#10;Suggested usage is::&#10;&#10;    try:&#10;        import thread&#10;    except ImportError:&#10;        import dummy_thread as thread">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.LockType" func="yes">
			<Overload retVal="" descr="Class implementing dummy implementation of thread.LockType.&#10;&#10;Compatibility is maintained by maintaining self.locked_status&#10;which is a boolean that stores the state of the lock.  Pickling of&#10;the lock, though, should not be done since if the thread module is&#10;then used with an unpickled ``lock()`` from here problems could&#10;occur from this class not having atomic methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.LockType.acquire" func="yes">
			<Overload retVal="" descr="Dummy implementation of acquire().&#10;&#10;For blocking calls, self.locked_status is automatically set to&#10;True and returned appropriately based on value of&#10;``waitflag``.  If it is non-blocking, then the value is&#10;actually checked and not set if it is already acquired.  This&#10;is all done so that threading.Condition's assert statements&#10;aren't triggered and throw a little fit.">
				<Param name="self" />
				<Param name="[waitflag=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.LockType.locked" />
		<KeyWord name="dummy_thread.LockType.release" func="yes">
			<Overload retVal="" descr="Release the dummy lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.allocate_lock" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.allocate_lock().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.error" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.error.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.exit" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.exit().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.get_ident" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.get_ident().&#10;&#10;Since this module should only be used when threadmodule is not&#10;available, it is safe to assume that the current process is the&#10;only thread.  Thus a constant can be safely returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.interrupt_main" func="yes">
			<Overload retVal="" descr="Set _interrupt flag to True to have start_new_thread raise&#10;KeyboardInterrupt upon exiting.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.stack_size" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.stack_size().">
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_thread.start_new_thread" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.start_new_thread().&#10;&#10;Compatibility is maintained by making sure that ``args`` is a&#10;tuple and ``kwargs`` is a dictionary.  If an exception is raised&#10;and it is SystemExit (which can be done by thread.exit()) it is&#10;caught and nothing is done; all other exceptions are printed out&#10;by using traceback.print_exc().&#10;&#10;If the executed function calls interrupt_main the KeyboardInterrupt will be&#10;raised when the function returns.">
				<Param name="function" />
				<Param name="args" />
				<Param name="[kwargs={}]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading" func="yes">
			<Overload retVal="" descr="Faux ``threading`` version using ``dummy_thread`` instead of ``thread``.&#10;&#10;The module ``_dummy_threading`` is added to ``sys.modules`` in order&#10;to not have ``threading`` considered imported.  Had ``threading`` been&#10;directly imported it would have made all subsequent imports succeed&#10;regardless of whether ``thread`` was available which is not desired.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="A factory function that returns a new bounded semaphore.&#10;&#10;A bounded semaphore checks to make sure its current value doesn't exceed its&#10;initial value. If it does, ValueError is raised. In most situations&#10;semaphores are used to guard resources with limited capacity.&#10;&#10;If the semaphore is released too many times it's a sign of a bug. If not&#10;given, value defaults to 1.&#10;&#10;Like regular semaphores, bounded semaphores manage a counter representing&#10;the number of release() calls minus the number of acquire() calls, plus an&#10;initial value. The acquire() method blocks if necessary until it can return&#10;without making the counter negative. If not given, value defaults to 1.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition" func="yes">
			<Overload retVal="" descr="Factory function that returns a new condition variable object.&#10;&#10;A condition variable allows one or more threads to wait until they are&#10;notified by another thread.&#10;&#10;If the lock argument is given and not None, it must be a Lock or RLock&#10;object, and it is used as the underlying lock. Otherwise, a new RLock object&#10;is created and used as the underlying lock.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event" func="yes">
			<Overload retVal="" descr="A factory function that returns a new event.&#10;&#10;Events manage a flag that can be set to true with the set() method and reset&#10;to false with the clear() method. The wait() method blocks until the flag is&#10;true.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Lock" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.allocate_lock().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.RLock" func="yes">
			<Overload retVal="" descr="Factory function that returns a new reentrant lock.&#10;&#10;A reentrant lock must be released by the thread that acquired it. Once a&#10;thread has acquired a reentrant lock, the same thread may acquire it again&#10;without blocking; the thread must release it once for each time it has&#10;acquired it.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Semaphore" func="yes">
			<Overload retVal="" descr="A factory function that returns a new semaphore.&#10;&#10;Semaphores manage a counter representing the number of release() calls minus&#10;the number of acquire() calls, plus an initial value. The acquire() method&#10;blocks if necessary until it can return without making the counter&#10;negative. If not given, value defaults to 1.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread" func="yes">
			<Overload retVal="" descr="A class that represents a thread of control.&#10;&#10;This class can be safely subclassed in a limited fashion.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.getName" />
		<KeyWord name="dummy_threading.Thread.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.isAlive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.isDaemon" />
		<KeyWord name="dummy_threading.Thread.is_alive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.join" func="yes">
			<Overload retVal="" descr="Wait until the thread terminates.&#10;&#10;This blocks the calling thread until the thread whose join() method is&#10;called terminates -- either normally or through an unhandled exception&#10;or until the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof). As join() always returns None, you must call&#10;isAlive() after join() to decide whether a timeout happened -- if the&#10;thread is still alive, the join() call timed out.&#10;&#10;When the timeout argument is not present or None, the operation will&#10;block until the thread terminates.&#10;&#10;A thread can be join()ed many times.&#10;&#10;join() raises a RuntimeError if an attempt is made to join the current&#10;thread as that would cause a deadlock. It is also an error to join() a&#10;thread before it has been started and attempts to do so raises the same&#10;exception.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.run" func="yes">
			<Overload retVal="" descr="Method representing the thread's activity.&#10;&#10;You may override this method in a subclass. The standard run() method&#10;invokes the callable object passed to the object's constructor as the&#10;target argument, if any, with sequential and keyword arguments taken&#10;from the args and kwargs arguments, respectively.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.setDaemon" />
		<KeyWord name="dummy_threading.Thread.setName" />
		<KeyWord name="dummy_threading.Thread.start" func="yes">
			<Overload retVal="" descr="Start the thread's activity.&#10;&#10;It must be called at most once per thread object. It arranges for the&#10;object's run() method to be invoked in a separate thread of control.&#10;&#10;This method will raise a RuntimeError if called more than once on the&#10;same thread object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer" func="yes">
			<Overload retVal="" descr="Factory function to create a Timer object.&#10;&#10;Timers call a function after a specified number of seconds:&#10;&#10;    t = Timer(30.0, f, args=[], kwargs={})&#10;    t.start()&#10;    t.cancel()     # stop the timer's action if it's still waiting">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.activeCount" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.active_count" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.currentThread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.current_thread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.enumerate" func="yes">
			<Overload retVal="" descr="Return a list of all Thread objects currently alive.&#10;&#10;The list includes daemonic threads, dummy thread objects created by&#10;current_thread(), and the main thread. It excludes terminated threads and&#10;threads that have not yet been started.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.local" />
		<KeyWord name="dummy_threading.setprofile" func="yes">
			<Overload retVal="" descr="Set a profile function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.setprofile() for each thread, before its&#10;run() method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.settrace" func="yes">
			<Overload retVal="" descr="Set a trace function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.settrace() for each thread, before its run()&#10;method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.stack_size" func="yes">
			<Overload retVal="" descr="Dummy implementation of thread.stack_size().">
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dump" func="yes">
			<Overload retVal="" descr="Function of json">
			</Overload>
		</KeyWord>
		<KeyWord name="dump_address_pair" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="dump_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="dumps" func="yes">
			<Overload retVal="" descr="Function of Cookie">
			</Overload>
		</KeyWord>
		<KeyWord name="dup" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="dup2" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="east_asian_width" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="eff_request_host" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="effective" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="element_create" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="element_names" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="element_options" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="elements" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="elif" />
		<KeyWord name="else" />
		<KeyWord name="email" func="yes">
			<Overload retVal="" descr="A package for parsing, handling, and generating email messages.">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Charset" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Encoders" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Errors" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.FeedParser" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Generator" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Header" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Iterators" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.LazyImporter" />
		<KeyWord name="email.MIMEAudio" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.MIMEBase" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.MIMEImage" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.MIMEMessage" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.MIMEMultipart" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.MIMENonMultipart" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.MIMEText" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Message" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Parser" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.Utils" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.base64MIME" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.importer" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="email.message_from_file" func="yes">
			<Overload retVal="" descr="Read a file and parse its contents into a Message object model.&#10;&#10;Optional _class and strict are passed to the Parser constructor.">
				<Param name="fp" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="email.message_from_string" func="yes">
			<Overload retVal="" descr="Parse a string into a Message object model.&#10;&#10;Optional _class and strict are passed to the Parser constructor.">
				<Param name="s" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="email.quopriMIME" func="yes">
			<Overload retVal="" descr="(LazyImporter)">
			</Overload>
		</KeyWord>
		<KeyWord name="emit" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="enable" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_callback_tracebacks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_load_extension" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_shared_cache" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="encode_base64" func="yes">
			<Overload retVal="" descr="Function of smtplib">
			</Overload>
		</KeyWord>
		<KeyWord name="encode_long" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="encodestring" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings" func="yes">
			<Overload retVal="" descr="Standard &quot;encodings&quot; Package&#10;&#10;    Standard Python encoding modules are stored in this package&#10;    directory.&#10;&#10;    Codec modules must have names corresponding to normalized encoding&#10;    names as defined in the normalize_encoding() function below, e.g.&#10;    'utf-8' must be implemented by the module 'utf_8.py'.&#10;&#10;    Each codec module must export the following interface:&#10;&#10;    * getregentry() -&gt; codecs.CodecInfo object&#10;    The getregentry() API must a CodecInfo object with encoder, decoder,&#10;    incrementalencoder, incrementaldecoder, streamwriter and streamreader&#10;    atttributes which adhere to the Python Codec Interface Standard.&#10;&#10;    In addition, a module may optionally also define the following&#10;    APIs which are then used by the package's codec search function:&#10;&#10;    * getaliases() -&gt; sequence of encoding name strings to use as aliases&#10;&#10;    Alias names returned by getaliases() must be normalized encoding&#10;    names as defined by normalize_encoding().&#10;&#10;Written by Marc-Andre Lemburg (mal@lemburg.com).&#10;&#10;(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.CodecRegistryError" />
		<KeyWord name="encodings.CodecRegistryError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.CodecRegistryError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.normalize_encoding" func="yes">
			<Overload retVal="" descr="Normalize an encoding name.&#10;&#10;Normalization works as follows: all non-alphanumeric&#10;characters except the dot used for Python package names are&#10;collapsed and replaced with a single underscore, e.g. '  -;#'&#10;becomes '_'. Leading and trailing underscores are removed.&#10;&#10;Note that encoding names should be ASCII only; if they do use&#10;non-ASCII characters, these must be Latin-1 compatible.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.search_function" />
		<KeyWord name="end_fill" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="end_poly" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="end_section" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum_certificates" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="enum_crls" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="enumerate" func="yes">
			<Overload retVal="" descr="enumerate(iterable[, start]) -&gt; iterator for index, value of iterable&#10;&#10;Return an enumerate object.  iterable must be another object that supports&#10;iteration.  The enumerate object yields pairs containing a count (from&#10;start, which defaults to zero) and a value yielded by the iterable argument.&#10;enumerate is useful for obtaining an indexed list:&#10;    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...">
			</Overload>
		</KeyWord>
		<KeyWord name="erf" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="erfc" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="error" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="errprint" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="escape" func="yes">
			<Overload retVal="" descr="Function of sre">
			</Overload>
		</KeyWord>
		<KeyWord name="escape_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="escape_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="escape_path" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="eval" func="yes">
			<Overload retVal="" descr="eval(source[, globals[, locals]]) -&gt; value&#10;&#10;Evaluate the source in the context of globals and locals.&#10;The source may be a string representing a Python expression&#10;or a code object as returned by compile().&#10;The globals must be a dictionary and locals can be any mapping,&#10;defaulting to the current globals and locals.&#10;If only globals is given, locals defaults to it.">
			</Overload>
		</KeyWord>
		<KeyWord name="event_add" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="event_delete" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="event_generate" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="event_info" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="example" func="yes">
			<Overload retVal="" descr="Function of ScrolledText">
			</Overload>
		</KeyWord>
		<KeyWord name="except" />
		<KeyWord name="exception" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="exec" />
		<KeyWord name="execfile" func="yes">
			<Overload retVal="" descr="execfile(filename[, globals[, locals]])&#10;&#10;Read and execute a Python script from a file.&#10;The globals and locals are dictionaries, defaulting to the current&#10;globals and locals.  If only globals is given, locals defaults to it.">
			</Overload>
		</KeyWord>
		<KeyWord name="execl" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execle" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execlp" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execlpe" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execsitecustomize" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="execusercustomize" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="executable" func="yes">
			<Overload retVal="" descr="Function of CGIHTTPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="execute" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="executemany" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="executescript" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="execv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execve" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execvp" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execvpe" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="exists" func="yes">
			<Overload retVal="" descr="Function of os2emxpath">
			</Overload>
		</KeyWord>
		<KeyWord name="exit" func="yes">
			<Overload retVal="" descr="Function of dummy_thread">
			</Overload>
		</KeyWord>
		<KeyWord name="exitonclick" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="exp" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="expand_args" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="expand_template" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="expanduser" func="yes">
			<Overload retVal="" descr="Function of os2emxpath">
			</Overload>
		</KeyWord>
		<KeyWord name="expandvars" func="yes">
			<Overload retVal="" descr="Function of posixpath">
			</Overload>
		</KeyWord>
		<KeyWord name="expectedFailure" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="expm1" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="expovariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="extend" func="yes">
			<Overload retVal="" descr="B.extend(iterable int) -&gt; None&#10;&#10;Append all the elements from the iterator or sequence to the&#10;end of B.">
			</Overload>
		</KeyWord>
		<KeyWord name="extend_path" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="extendleft" func="yes">
			<Overload retVal="" descr="Function of shlex.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="extract" func="yes">
			<Overload retVal="" descr="Function of fpformat">
			</Overload>
		</KeyWord>
		<KeyWord name="extract_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="extract_tb" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="extractall" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="extractfile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="f8" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="fabs" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="factorial" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="fail" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failIf" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failIfAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failIfEqual" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnless" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnlessEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnlessRaises" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="fallback_getpass" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="families" func="yes">
			<Overload retVal="" descr="Function of tkFont">
			</Overload>
		</KeyWord>
		<KeyWord name="fatal" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="fd" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="fdopen" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="fetchall" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="fetchmany" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="fetchone" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="field_size_limit" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="file" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp" func="yes">
			<Overload retVal="" descr="Utilities for comparing files and directories.&#10;&#10;Classes:&#10;    dircmp&#10;&#10;Functions:&#10;    cmp(f1, f2, shallow=1) -&gt; int&#10;    cmpfiles(a, b, common) -&gt; ([], [], [])">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.BUFSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.cmp" func="yes">
			<Overload retVal="" descr="Compare two files.&#10;&#10;Arguments:&#10;&#10;f1 -- First file name&#10;&#10;f2 -- Second file name&#10;&#10;shallow -- Just check stat signature (do not read the files).&#10;           defaults to 1.&#10;&#10;Return value:&#10;&#10;True if the files are the same, False otherwise.&#10;&#10;This function uses a cache for past comparisons and the results,&#10;with a cache invalidation mechanism relying on stale signatures.">
				<Param name="f1" />
				<Param name="f2" />
				<Param name="[shallow=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.cmpfiles" func="yes">
			<Overload retVal="" descr="Compare common files in two directories.&#10;&#10;a, b -- directory names&#10;common -- list of file names found in both directories&#10;shallow -- if true, do comparison based solely on stat() information&#10;&#10;Returns a tuple of three lists:&#10;  files that compare equal&#10;  files that are different&#10;  filenames that aren't regular files.">
				<Param name="a" />
				<Param name="b" />
				<Param name="common" />
				<Param name="[shallow=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.demo" />
		<KeyWord name="filecmp.dircmp" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.ifilter" func="yes">
			<Overload retVal="" descr="ifilter(function or None, sequence) --&gt; ifilter object&#10;&#10;Return those items of sequence for which function(item) is true.&#10;If function is None, return the items that are true.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.ifilter.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.ifilterfalse" func="yes">
			<Overload retVal="" descr="ifilterfalse(function or None, sequence) --&gt; ifilterfalse object&#10;&#10;Return those items of sequence for which function(item) is false.&#10;If function is None, return the items that are false.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.ifilterfalse.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.imap" func="yes">
			<Overload retVal="" descr="imap(func, *iterables) --&gt; imap object&#10;&#10;Make an iterator that computes the function using arguments from&#10;each of the iterables.  Like map() except that it returns&#10;an iterator instead of a list and that it stops when the shortest&#10;iterable is exhausted instead of filling in None for shorter&#10;iterables.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.imap.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.izip" func="yes">
			<Overload retVal="" descr="izip(iter1 [,iter2 [...]]) --&gt; izip object&#10;&#10;Return a izip object whose .next() method returns a tuple where&#10;the i-th element comes from the i-th iterable argument.  The .next()&#10;method continues until the shortest iterable in the argument sequence&#10;is exhausted and then it raises StopIteration.  Works like the zip()&#10;function but consumes less memory by returning an iterator instead of&#10;a list.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.izip.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput" func="yes">
			<Overload retVal="" descr="Helper class to quickly write a loop over all standard input files.&#10;&#10;Typical use is:&#10;&#10;    import fileinput&#10;    for line in fileinput.input():&#10;        process(line)&#10;&#10;This iterates over the lines of all files listed in sys.argv[1:],&#10;defaulting to sys.stdin if the list is empty.  If a filename is '-' it&#10;is also replaced by sys.stdin.  To specify an alternative list of&#10;filenames, pass it as the argument to input().  A single file name is&#10;also allowed.&#10;&#10;Functions filename(), lineno() return the filename and cumulative line&#10;number of the line that has just been read; filelineno() returns its&#10;line number in the current file; isfirstline() returns true iff the&#10;line just read is the first line of its file; isstdin() returns true&#10;iff the line was read from sys.stdin.  Function nextfile() closes the&#10;current file so that the next iteration will read the first line from&#10;the next file (if any); lines not read from the file will not count&#10;towards the cumulative line count; the filename is not changed until&#10;after the first line of the next file has been read.  Function close()&#10;closes the sequence.&#10;&#10;Before any lines have been read, filename() returns None and both line&#10;numbers are zero; nextfile() has no effect.  After all lines have been&#10;read, filename() and the line number functions return the values&#10;pertaining to the last line read; nextfile() has no effect.&#10;&#10;All files are opened in text mode by default, you can override this by&#10;setting the mode parameter to input() or FileInput.__init__().&#10;If an I/O error occurs during opening or reading a file, the IOError&#10;exception is raised.&#10;&#10;If sys.stdin is used more than once, the second and further use will&#10;return no lines, except perhaps for interactive use, or if it has been&#10;explicitly reset (e.g. using sys.stdin.seek(0)).&#10;&#10;Empty files are opened and immediately closed; the only time their&#10;presence in the list of filenames is noticeable at all is when the&#10;last file opened is empty.&#10;&#10;It is possible that the last line of a file doesn't end in a newline&#10;character; otherwise lines are returned including the trailing&#10;newline.&#10;&#10;Class FileInput is the implementation; its methods filename(),&#10;lineno(), fileline(), isfirstline(), isstdin(), nextfile() and close()&#10;correspond to the functions in the module.  In addition it has a&#10;readline() method which returns the next input line, and a&#10;__getitem__() method which implements the sequence behavior.  The&#10;sequence must be accessed in strictly sequential order; sequence&#10;access and readline() cannot be mixed.&#10;&#10;Optional in-place filtering: if the keyword argument inplace=1 is&#10;passed to input() or to the FileInput constructor, the file is moved&#10;to a backup file and standard output is directed to the input file.&#10;This makes it possible to write a filter that rewrites its input file&#10;in place.  If the keyword argument backup=&quot;.&lt;some extension&gt;&quot; is also&#10;given, it specifies the extension for the backup file, and the backup&#10;file remains around; by default, the extension is &quot;.bak&quot; and it is&#10;deleted when the output file is closed.  In-place filtering is&#10;disabled when standard input is read.  XXX The current implementation&#10;does not work for MS-DOS 8+3 filesystems.&#10;&#10;Performance: this module is unfortunately one of the slower ways of&#10;processing large numbers of input lines.  Nevertheless, a significant&#10;speed-up has been obtained by using readlines(bufsize) instead of&#10;readline().  A new keyword argument, bufsize=N, is present on the&#10;input() function and the FileInput() class to override the default&#10;buffer size.&#10;&#10;XXX Possible additions:&#10;&#10;- optional getopt argument processing&#10;- isatty()&#10;- read(), read(size), even readlines()">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.DEFAULT_BUFSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.FileInput" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.close" func="yes">
			<Overload retVal="" descr="Close the sequence.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.filelineno" func="yes">
			<Overload retVal="" descr="Return the line number in the current file. Before the first line&#10;has been read, returns 0. After the last line of the last file has&#10;been read, returns the line number of that line within the file.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.filename" func="yes">
			<Overload retVal="" descr="Return the name of the file currently being read.&#10;Before the first line has been read, returns None.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.fileno" func="yes">
			<Overload retVal="" descr="Return the file number of the current file. When no file is currently&#10;opened, returns -1.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.hook_compressed" />
		<KeyWord name="fileinput.hook_encoded" />
		<KeyWord name="fileinput.input" func="yes">
			<Overload retVal="" descr="Return an instance of the FileInput class, which can be iterated.&#10;&#10;The parameters are passed to the constructor of the FileInput class.&#10;The returned instance, in addition to being an iterator,&#10;keeps global state for the functions of this module,.">
				<Param name="[files=None" />
				<Param name="[inplace=0" />
				<Param name="[backup" />
				<Param name="[bufsize=0" />
				<Param name="[mode=r" />
				<Param name="[openhook=None]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.isfirstline" func="yes">
			<Overload retVal="" descr="Returns true the line just read is the first line of its file,&#10;otherwise returns false.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.isstdin" func="yes">
			<Overload retVal="" descr="Returns true if the last line was read from sys.stdin,&#10;otherwise returns false.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.lineno" func="yes">
			<Overload retVal="" descr="Return the cumulative line number of the line that has just been read.&#10;Before the first line has been read, returns 0. After the last line&#10;of the last file has been read, returns the line number of that line.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.nextfile" func="yes">
			<Overload retVal="" descr="Close the current file so that the next iteration will read the first&#10;line from the next file (if any); lines not read from the file will&#10;not count towards the cumulative line count. The filename is not&#10;changed until after the first line of the next file has been read.&#10;Before the first line has been read, this function has no effect;&#10;it cannot be used to skip the first file. After the last line of the&#10;last file has been read, this function has no effect.">
			</Overload>
		</KeyWord>
		<KeyWord name="filelineno" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="filemode" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="filename" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="fileopen" func="yes">
			<Overload retVal="" descr="Function of posixfile">
			</Overload>
		</KeyWord>
		<KeyWord name="fill" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="fillcolor" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="filter" func="yes">
			<Overload retVal="" descr="filter(function or None, sequence) -&gt; list, tuple, or string&#10;&#10;Return those items of sequence for which function(item) is true.  If&#10;function is None, return the items that are true.  If sequence is a tuple&#10;or string, return the same type, else return a list.">
			</Overload>
		</KeyWord>
		<KeyWord name="filterwarnings" func="yes">
			<Overload retVal="" descr="Function of BaseHTTPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="finally" />
		<KeyWord name="find" func="yes">
			<Overload retVal="" descr="B.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in B where subsection sub is found,&#10;such that sub is contained within B[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="findCaller" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="findTestCases" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="find_executable_linenos" func="yes">
			<Overload retVal="" descr="Function of trace">
			</Overload>
		</KeyWord>
		<KeyWord name="find_function" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="find_lines" func="yes">
			<Overload retVal="" descr="Function of trace">
			</Overload>
		</KeyWord>
		<KeyWord name="find_lines_from_code" func="yes">
			<Overload retVal="" descr="Function of trace">
			</Overload>
		</KeyWord>
		<KeyWord name="find_loader" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="find_module" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
		<KeyWord name="find_prefix_at_end" func="yes">
			<Overload retVal="" descr="Function of asynchat">
			</Overload>
		</KeyWord>
		<KeyWord name="find_strings" func="yes">
			<Overload retVal="" descr="Function of trace">
			</Overload>
		</KeyWord>
		<KeyWord name="findall" func="yes">
			<Overload retVal="" descr="Function of sre">
			</Overload>
		</KeyWord>
		<KeyWord name="finditer" func="yes">
			<Overload retVal="" descr="Function of sre">
			</Overload>
		</KeyWord>
		<KeyWord name="findlabels" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="findlinestarts" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="findmatch" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="findparam" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="findsource" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="firstweekday" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="fix" func="yes">
			<Overload retVal="" descr="Function of fpformat">
			</Overload>
		</KeyWord>
		<KeyWord name="fix_missing_locations" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="float" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="floor" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="fma" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="fmod" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch" func="yes">
			<Overload retVal="" descr="Filename matching with shell patterns.&#10;&#10;fnmatch(FILENAME, PATTERN) matches according to the local convention.&#10;fnmatchcase(FILENAME, PATTERN) always takes case in account.&#10;&#10;The functions operate by translating the pattern into a regular&#10;expression.  They cache the compiled regular expressions for speed.&#10;&#10;The function translate(PATTERN) returns a regular expression&#10;corresponding to PATTERN.  (It does not compile it.)">
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.filter" func="yes">
			<Overload retVal="" descr="Return the subset of the list NAMES that match PAT">
				<Param name="names" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.fnmatch" func="yes">
			<Overload retVal="" descr="Test whether FILENAME matches PATTERN.&#10;&#10;Patterns are Unix shell style:&#10;&#10;*       matches everything&#10;?       matches any single character&#10;[seq]   matches any character in seq&#10;[!seq]  matches any char not in seq&#10;&#10;An initial period in FILENAME is not special.&#10;Both FILENAME and PATTERN are first case-normalized&#10;if the operating system requires it.&#10;If you don't want this, use fnmatchcase(FILENAME, PATTERN).">
				<Param name="name" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.fnmatchcase" func="yes">
			<Overload retVal="" descr="Test whether FILENAME matches PATTERN, including case.&#10;&#10;This is a version of fnmatch() which doesn't case-normalize&#10;its arguments.">
				<Param name="name" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.translate" func="yes">
			<Overload retVal="" descr="Translate a shell PATTERN to a regular expression.&#10;&#10;There is no way to quote meta-characters.">
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatchcase" func="yes">
			<Overload retVal="" descr="Function of fnmatch">
			</Overload>
		</KeyWord>
		<KeyWord name="focus" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="focus_displayof" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="focus_force" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="focus_get" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="focus_lastfor" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="focus_set" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="foo" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="for" />
		<KeyWord name="forget" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="form" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="formatException" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatFooter" func="yes">
			<Overload retVal="" descr="Function of logging.BufferingFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatHeader" func="yes">
			<Overload retVal="" descr="Function of logging.BufferingFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatTime" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_exc" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_exception" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_exception_only" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_failure" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="format_field" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_help" func="yes">
			<Overload retVal="" descr="Function of argparse.RawDescriptionHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_list" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_string" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="format_tb" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_usage" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="format_version" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="format_witnesses" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="formatargspec" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="formatargvalues" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="formatdate" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="formatday" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatmonth" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatmonthname" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatstring" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter" func="yes">
			<Overload retVal="" descr="Generic output formatting.&#10;&#10;Formatter objects transform an abstract flow of formatting events into&#10;specific output events on writer objects. Formatters manage several stack&#10;structures to allow various properties of a writer object to be changed and&#10;restored; writers need not be able to handle relative changes nor any sort&#10;of ``change back'' operation. Specific writer properties which may be&#10;controlled via formatter objects are horizontal alignment, font, and left&#10;margin indentations. A mechanism is provided which supports providing&#10;arbitrary, non-exclusive style settings to a writer as well. Additional&#10;interfaces facilitate formatting events which are not reversible, such as&#10;paragraph separation.&#10;&#10;Writer objects encapsulate device interfaces. Abstract devices, such as&#10;file formats, are supported as well as physical devices. The provided&#10;implementations all work with abstract devices. The interface makes&#10;available mechanisms for setting the properties which formatter objects&#10;manage and inserting data into the output.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.DumbWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullFormatter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatwarning" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="formatweek" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatweekday" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatweekheader" func="yes">
			<Overload retVal="" descr="Function of calendar.TextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatyear" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatyearpage" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="forward" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat" func="yes">
			<Overload retVal="" descr="General floating point formatting functions.&#10;&#10;Functions:&#10;fix(x, digits_behind)&#10;sci(x, digits_behind)&#10;&#10;Each takes a number or a string and a number of digits as arguments.&#10;&#10;Parameters:&#10;x:             number to be formatted; or a string resembling a number&#10;digits_behind: number of digits behind the decimal point">
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.NotANumber" />
		<KeyWord name="fpformat.NotANumber.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.NotANumber.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.decoder" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.extract" func="yes">
			<Overload retVal="" descr="Return (sign, intpart, fraction, expo) or raise an exception:&#10;sign is '+' or '-'&#10;intpart is 0 or more digits beginning with a nonzero&#10;fraction is 0 or more digits&#10;expo is an integer">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.fix" func="yes">
			<Overload retVal="" descr="Format x as [-]ddd.ddd with 'digs' digits after the point&#10;and at least one digit before.&#10;If digs &lt;= 0, the point is suppressed.">
				<Param name="x" />
				<Param name="digs" />
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.roundfrac" func="yes">
			<Overload retVal="" descr="Round or extend the fraction to size digs.">
				<Param name="intpart" />
				<Param name="fraction" />
				<Param name="digs" />
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.sci" func="yes">
			<Overload retVal="" descr="Format x as [-]d.dddE[+-]ddd with 'digs' digits after the point&#10;and exactly one digit before.&#10;If digs is &lt;= 0, one digit is kept and the point is suppressed.">
				<Param name="x" />
				<Param name="digs" />
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.test" func="yes">
			<Overload retVal="" descr="Interactive test run.">
			</Overload>
		</KeyWord>
		<KeyWord name="fpformat.unexpo" func="yes">
			<Overload retVal="" descr="Remove the exponent by changing intpart and fraction.">
				<Param name="intpart" />
				<Param name="fraction" />
				<Param name="expo" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions" func="yes">
			<Overload retVal="" descr="Rational, infinite-precision, real numbers.">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal" func="yes">
			<Overload retVal="" descr="Floating point class for decimal arithmetic.">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.adjusted" func="yes">
			<Overload retVal="" descr="Return the adjusted exponent of self">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.as_tuple" func="yes">
			<Overload retVal="" descr="Represents the number as a triple tuple.&#10;&#10;To show the internals exactly as they are.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.canonical" func="yes">
			<Overload retVal="" descr="Returns the same Decimal object.&#10;&#10;As we do not have different encodings for the same number, the&#10;received object already is in its canonical form.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare" func="yes">
			<Overload retVal="" descr="Compares one to another.&#10;&#10;-1 =&gt; a &lt; b&#10;0  =&gt; a = b&#10;1  =&gt; a &gt; b&#10;NaN =&gt; one is NaN&#10;Like __cmp__, but returns Decimal instances.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare_signal" func="yes">
			<Overload retVal="" descr="Compares self to the other operand numerically.&#10;&#10;It's pretty much like compare(), but all NaNs signal, with signaling&#10;NaNs taking precedence over quiet NaNs.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare_total" func="yes">
			<Overload retVal="" descr="Compares self to other using the abstract representations.&#10;&#10;This is not like the standard compare, which use their numerical&#10;value. Note that a total ordering is defined for all possible abstract&#10;representations.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compares self to other using abstract repr., ignoring sign.&#10;&#10;Like compare_total, but with operand's sign ignored and assumed to be 0.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.conjugate" />
		<KeyWord name="fractions.Decimal.copy_abs" func="yes">
			<Overload retVal="" descr="Returns a copy with the sign set to 0.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.copy_negate" func="yes">
			<Overload retVal="" descr="Returns a copy with the sign inverted.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.copy_sign" func="yes">
			<Overload retVal="" descr="Returns self with the sign of other.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.exp" func="yes">
			<Overload retVal="" descr="Returns e ** self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.fma" func="yes">
			<Overload retVal="" descr="Fused multiply-add.&#10;&#10;Returns self*other+third with no rounding of the intermediate&#10;product self*other.&#10;&#10;self and other are multiplied together, with no rounding of&#10;the result.  The third operand is then added to the result,&#10;and a single final rounding is performed.">
				<Param name="self" />
				<Param name="other" />
				<Param name="third" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.from_float" func="yes">
			<Overload retVal="" descr="Converts a float to a decimal number, exactly.&#10;&#10;Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').&#10;Since 0.1 is not exactly representable in binary floating point, the&#10;value is stored as the nearest representable value which is&#10;0x1.999999999999ap-4.  The exact equivalent of the value in decimal&#10;is 0.1000000000000000055511151231257827021181583404541015625.&#10;&#10;&gt;&gt;&gt; Decimal.from_float(0.1)&#10;Decimal('0.1000000000000000055511151231257827021181583404541015625')&#10;&gt;&gt;&gt; Decimal.from_float(float('nan'))&#10;Decimal('NaN')&#10;&gt;&gt;&gt; Decimal.from_float(float('inf'))&#10;Decimal('Infinity')&#10;&gt;&gt;&gt; Decimal.from_float(-float('inf'))&#10;Decimal('-Infinity')&#10;&gt;&gt;&gt; Decimal.from_float(-0.0)&#10;Decimal('-0')">
				<Param name="cls" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.imag" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if self is canonical; otherwise return False.&#10;&#10;Currently, the encoding of a Decimal instance is always&#10;canonical, so this method returns True for any Decimal.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_finite" func="yes">
			<Overload retVal="" descr="Return True if self is finite; otherwise return False.&#10;&#10;A Decimal instance is considered finite if it is neither&#10;infinite nor a NaN.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if self is infinite; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_nan" func="yes">
			<Overload retVal="" descr="Return True if self is a qNaN or sNaN; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_normal" func="yes">
			<Overload retVal="" descr="Return True if self is a normal number; otherwise return False.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if self is a quiet NaN; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_signed" func="yes">
			<Overload retVal="" descr="Return True if self is negative; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_snan" func="yes">
			<Overload retVal="" descr="Return True if self is a signaling NaN; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if self is subnormal; otherwise return False.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_zero" func="yes">
			<Overload retVal="" descr="Return True if self is a zero; otherwise return False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.ln" func="yes">
			<Overload retVal="" descr="Returns the natural (base e) logarithm of self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.log10" func="yes">
			<Overload retVal="" descr="Returns the base 10 logarithm of self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logb" func="yes">
			<Overload retVal="" descr="Returns the exponent of the magnitude of self's MSD.&#10;&#10;The result is the integer which is the exponent of the magnitude&#10;of the most significant digit of self (as though it were truncated&#10;to a single digit while maintaining the value of that digit and&#10;without limiting the resulting exponent).">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_and" func="yes">
			<Overload retVal="" descr="Applies an 'and' operation between self and other's digits.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_invert" func="yes">
			<Overload retVal="" descr="Invert all its digits.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_or" func="yes">
			<Overload retVal="" descr="Applies an 'or' operation between self and other's digits.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_xor" func="yes">
			<Overload retVal="" descr="Applies an 'xor' operation between self and other's digits.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.max" func="yes">
			<Overload retVal="" descr="Returns the larger value.&#10;&#10;Like max(self, other) except if one is not a number, returns&#10;NaN (and signals if one is sNaN).  Also rounds.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.max_mag" func="yes">
			<Overload retVal="" descr="Compares the values numerically with their sign ignored.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.min" func="yes">
			<Overload retVal="" descr="Returns the smaller value.&#10;&#10;Like min(self, other) except if one is not a number, returns&#10;NaN (and signals if one is sNaN).  Also rounds.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.min_mag" func="yes">
			<Overload retVal="" descr="Compares the values numerically with their sign ignored.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.next_minus" func="yes">
			<Overload retVal="" descr="Returns the largest representable number smaller than itself.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.next_plus" func="yes">
			<Overload retVal="" descr="Returns the smallest representable number larger than itself.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.next_toward" func="yes">
			<Overload retVal="" descr="Returns the number closest to self, in the direction towards other.&#10;&#10;The result is the closest representable number to self&#10;(excluding self) that is in the direction towards other,&#10;unless both have the same value.  If the two operands are&#10;numerically equal, then the result is a copy of self with the&#10;sign set to be the same as the sign of other.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.normalize" func="yes">
			<Overload retVal="" descr="Normalize- strip trailing 0s, change anything equal to 0 to 0e0">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.number_class" func="yes">
			<Overload retVal="" descr="Returns an indication of the class of self.&#10;&#10;The class is one of the following strings:&#10;  sNaN&#10;  NaN&#10;  -Infinity&#10;  -Normal&#10;  -Subnormal&#10;  -Zero&#10;  +Zero&#10;  +Subnormal&#10;  +Normal&#10;  +Infinity">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.quantize" func="yes">
			<Overload retVal="" descr="Quantize self so its exponent is the same as that of exp.&#10;&#10;Similar to self._rescale(exp._exp) but with error checking.">
				<Param name="self" />
				<Param name="exp" />
				<Param name="[rounding=None" />
				<Param name="[context=None" />
				<Param name="[watchexp=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.radix" func="yes">
			<Overload retVal="" descr="Just returns 10, as this is Decimal, :)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.real" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.remainder_near" func="yes">
			<Overload retVal="" descr="Remainder nearest to 0-  abs(remainder-near) &lt;= other/2">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.rotate" func="yes">
			<Overload retVal="" descr="Returns a rotated copy of self, value-of-other times.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.same_quantum" func="yes">
			<Overload retVal="" descr="Return True if self and other have the same exponent; otherwise&#10;return False.&#10;&#10;If either operand is a special value, the following rules are used:&#10;   * return True if both operands are infinities&#10;   * return True if both operands are NaNs&#10;   * otherwise, return False.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.scaleb" func="yes">
			<Overload retVal="" descr="Returns self operand after adding the second value to its exp.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.shift" func="yes">
			<Overload retVal="" descr="Returns a shifted copy of self, value-of-other times.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.sqrt" func="yes">
			<Overload retVal="" descr="Return the square root of self.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_eng_string" func="yes">
			<Overload retVal="" descr="Convert to engineering-type string.&#10;&#10;Engineering notation has an exponent which is a multiple of 3, so there&#10;are up to 3 digits left of the decimal place.&#10;&#10;Same rules for when in exponential and when as a value as in __str__.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_integral" func="yes">
			<Overload retVal="" descr="Rounds to the nearest integer, without raising inexact, rounded.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_integral_exact" func="yes">
			<Overload retVal="" descr="Rounds to a nearby integer.&#10;&#10;If no rounding mode is specified, take the rounding mode from&#10;the context.  This method raises the Rounded and Inexact flags&#10;when appropriate.&#10;&#10;See also: to_integral_value, which does exactly the same as&#10;this method except that it doesn't raise Inexact or Rounded.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_integral_value" func="yes">
			<Overload retVal="" descr="Rounds to the nearest integer, without raising inexact, rounded.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Fraction" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Rational" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.division" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.gcd" func="yes">
			<Overload retVal="" descr="Calculate the Greatest Common Divisor of a and b.&#10;&#10;Unless b==0, the result will have the same sign as b (so that when&#10;b is divided by it, the result comes out positive).">
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="freeze_support" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="frexp" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="from" />
		<KeyWord name="fromFile" func="yes">
			<Overload retVal="" descr="Function of plistlib.Plist">
			</Overload>
		</KeyWord>
		<KeyWord name="from_float" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="from_iterable" func="yes">
			<Overload retVal="" descr="Function of tokenize.chain">
			</Overload>
		</KeyWord>
		<KeyWord name="frombuf" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="fromfile" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="fromhex" func="yes">
			<Overload retVal="" descr="bytearray.fromhex(string) -&gt; bytearray&#10;&#10;Create a bytearray object from a string of hexadecimal numbers.&#10;Spaces between two numbers are accepted.&#10;Example: bytearray.fromhex('B9 01EF') -&gt; bytearray(b'\xb9\x01\xef').">
			</Overload>
		</KeyWord>
		<KeyWord name="fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="fromlist" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="fromname" func="yes">
			<Overload retVal="" descr="Function of ssl.Purpose">
			</Overload>
		</KeyWord>
		<KeyWord name="fromnid" func="yes">
			<Overload retVal="" descr="Function of ssl.Purpose">
			</Overload>
		</KeyWord>
		<KeyWord name="fromordinal" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="fromstring" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="fromtarfile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="fromtimestamp" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="fromunicode" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="frozenset" func="yes">
			<Overload retVal="" descr="frozenset() -&gt; empty frozenset object&#10;frozenset(iterable) -&gt; frozenset object&#10;&#10;Build an immutable unordered collection of unique elements.">
			</Overload>
		</KeyWord>
		<KeyWord name="fstat" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="fsum" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="fsync" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="ftpcp" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="ftperrors" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib" func="yes">
			<Overload retVal="" descr="An FTP client class and some helper functions.&#10;&#10;Based on RFC 959: File Transfer Protocol (FTP), by J. Postel and J. Reynolds&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; from ftplib import FTP&#10;&gt;&gt;&gt; ftp = FTP('ftp.python.org') # connect to host, default port&#10;&gt;&gt;&gt; ftp.login() # default, i.e.: user anonymous, passwd anonymous@&#10;'230 Guest login ok, access restrictions apply.'&#10;&gt;&gt;&gt; ftp.retrlines('LIST') # list directory contents&#10;total 9&#10;drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .&#10;drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..&#10;drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin&#10;drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc&#10;d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming&#10;drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib&#10;drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub&#10;drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr&#10;-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg&#10;'226 Transfer complete.'&#10;&gt;&gt;&gt; ftp.quit()&#10;'221 Goodbye.'&#10;&gt;&gt;&gt;&#10;&#10;A nice test that reveals some of the network dialogue would be:&#10;python ftplib.py -d localhost -l -p -l">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.Error" />
		<KeyWord name="ftplib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.MAXLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.MSG_OOB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.Netrc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.all_errors" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_perm" />
		<KeyWord name="ftplib.error_perm.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_perm.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_proto" />
		<KeyWord name="ftplib.error_proto.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_proto.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_reply" />
		<KeyWord name="ftplib.error_reply.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_reply.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_temp" />
		<KeyWord name="ftplib.error_temp.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_temp.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.ftpcp" func="yes">
			<Overload retVal="" descr="Copy file from one FTP-instance to another.">
				<Param name="source" />
				<Param name="sourcename" />
				<Param name="target" />
				<Param name="[targetname" />
				<Param name="[type=I]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse150" func="yes">
			<Overload retVal="" descr="Parse the '150' response for a RETR request.&#10;Returns the expected transfer size or None; size is not guaranteed to&#10;be present in the 150 message.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse227" func="yes">
			<Overload retVal="" descr="Parse the '227' response for a PASV request.&#10;Raises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'&#10;Return ('host.addr.as.numbers', port#) tuple.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse229" func="yes">
			<Overload retVal="" descr="Parse the '229' response for a EPSV request.&#10;Raises error_proto if it does not contain '(|||port|)'&#10;Return ('host.addr.as.numbers', port#) tuple.">
				<Param name="resp" />
				<Param name="peer" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse257" func="yes">
			<Overload retVal="" descr="Parse the '257' response for a MKD or PWD request.&#10;This is a response to a MKD or PWD request: a directory name.&#10;Returns the directoryname in the 257 reply.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.print_line" func="yes">
			<Overload retVal="" descr="Default retrlines callback to print a line.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.test" func="yes">
			<Overload retVal="" descr="Test program.&#10;Usage: ftp [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...&#10;&#10;-d dir&#10;-l list&#10;-p password">
			</Overload>
		</KeyWord>
		<KeyWord name="fullmodname" func="yes">
			<Overload retVal="" descr="Function of trace">
			</Overload>
		</KeyWord>
		<KeyWord name="func_get_function_name" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="func_std_string" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="func_strip_path" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="functools" func="yes">
			<Overload retVal="" descr="functools.py - Tools for working with functions and callable objects">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.WRAPPER_ASSIGNMENTS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.WRAPPER_UPDATES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.cmp_to_key" func="yes">
			<Overload retVal="" descr="Convert a cmp= function into a key= function">
				<Param name="mycmp" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial" func="yes">
			<Overload retVal="" descr="partial(func, *args, **keywords) - new function with partial application&#10;of the given arguments and keywords.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial.args" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial.func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial.keywords" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.reduce" func="yes">
			<Overload retVal="" descr="reduce(function, sequence[, initial]) -&gt; value&#10;&#10;Apply a function of two arguments cumulatively to the items of a sequence,&#10;from left to right, so as to reduce the sequence to a single value.&#10;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#10;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#10;of the sequence in the calculation, and serves as a default when the&#10;sequence is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.total_ordering" func="yes">
			<Overload retVal="" descr="Class decorator that fills in missing ordering methods">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.update_wrapper" func="yes">
			<Overload retVal="" descr="Update a wrapper function to look like the wrapped function&#10;&#10;wrapper is the function to be updated&#10;wrapped is the original function&#10;assigned is a tuple naming the attributes assigned directly&#10;from the wrapped function to the wrapper function (defaults to&#10;functools.WRAPPER_ASSIGNMENTS)&#10;updated is a tuple naming the attributes of the wrapper that&#10;are updated with the corresponding attribute from the wrapped&#10;function (defaults to functools.WRAPPER_UPDATES)">
				<Param name="wrapper" />
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__doc__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.wraps" func="yes">
			<Overload retVal="" descr="Decorator factory to apply update_wrapper() to a wrapper function&#10;&#10;Returns a decorator that invokes update_wrapper() with the decorated&#10;function as the wrapper argument and the arguments to wraps() as the&#10;remaining arguments. Default arguments are as for update_wrapper().&#10;This is a convenience function to simplify applying partial() to&#10;update_wrapper().">
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__doc__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gamma" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="gammavariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="gauss" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="gcd" func="yes">
			<Overload retVal="" descr="Function of fractions">
			</Overload>
		</KeyWord>
		<KeyWord name="gen_uuid" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="generate_tokens" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="generic_visit" func="yes">
			<Overload retVal="" descr="Function of ast.NodeVisitor">
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath" func="yes">
			<Overload retVal="" descr="Path operations common to more than one OS&#10;Do not use directly.  The OS specific modules import the appropriate&#10;functions from this module themselves.">
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="genops" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="getChild" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="getDescription" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="getLevelName" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getLogger" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getLoggerClass" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getMessage" func="yes">
			<Overload retVal="" descr="Function of logging.LogRecord">
			</Overload>
		</KeyWord>
		<KeyWord name="getName" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="getTestCaseNames" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="get_archive_formats" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_bytes" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_bytes_le" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_ca_certs" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="get_channel_binding" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="get_children" func="yes">
			<Overload retVal="" descr="Function of symtable.SymbolTable">
			</Overload>
		</KeyWord>
		<KeyWord name="get_class_members" func="yes">
			<Overload retVal="" descr="Function of rlcompleter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_clock_seq" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_clock_seq_hi_variant" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_clock_seq_low" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_close_matches" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="get_code" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_h_filename" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_var" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_vars" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_data" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default_verify_paths" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_dialect" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="get_docstring" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="get_errno" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="get_field" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_fields" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_filename" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_frees" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_globals" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_hex" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_id" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_ident" func="yes">
			<Overload retVal="" descr="Function of dummy_thread">
			</Overload>
		</KeyWord>
		<KeyWord name="get_identifiers" func="yes">
			<Overload retVal="" descr="Function of symtable.SymbolTable">
			</Overload>
		</KeyWord>
		<KeyWord name="get_importer" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_info" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="get_last_error" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="get_line" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="get_lineno" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="get_loader" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_locals" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_logger" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="get_long_be" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_long_le" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_makefile_filename" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_methods" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_msg" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="get_name" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="get_namespace" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="get_namespaces" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="get_node" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_parameters" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_path" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_path_names" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_paths" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_platform" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_poly" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="get_protocol_name" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_python_version" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_scheme_names" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_server_certificate" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_short_be" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_short_le" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_source" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_symbols" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_time" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_time_hi_version" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_time_low" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_time_mid" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_type" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_urn" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_value" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_variant" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="get_version" func="yes">
			<Overload retVal="" descr="Function of uuid.UUID">
			</Overload>
		</KeyWord>
		<KeyWord name="getabsfile" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getaddrinfo" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getargs" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getargspec" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getargvalues" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getatime" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getattr" func="yes">
			<Overload retVal="" descr="getattr(object, name[, default]) -&gt; value&#10;&#10;Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.&#10;When a default argument is given, it is returned when the attribute doesn't&#10;exist; without it, an exception is raised in that case.">
			</Overload>
		</KeyWord>
		<KeyWord name="getblock" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getboolean" func="yes">
			<Overload retVal="" descr="Function of tkCommonDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="getcallargs" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcanvas" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="getcaps" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="getclasstree" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcode" func="yes">
			<Overload retVal="" descr="Function of urllib2.HTTPError">
			</Overload>
		</KeyWord>
		<KeyWord name="getcomments" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcontext" func="yes">
			<Overload retVal="" descr="Function of decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="getctime" func="yes">
			<Overload retVal="" descr="Function of posixpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getcwd" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getcwdu" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getdecoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getdefaultlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="getdefaulttimeout" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getdoc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="getdouble" func="yes">
			<Overload retVal="" descr="Function of Dialog.getdouble">
			</Overload>
		</KeyWord>
		<KeyWord name="getencoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getenv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getfile" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getfileinfo" func="yes">
			<Overload retVal="" descr="Function of binhex">
			</Overload>
		</KeyWord>
		<KeyWord name="getfirstweekday" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="getfqdn" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getframeinfo" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="gethdr" func="yes">
			<Overload retVal="" descr="Function of sunaudio">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostbyaddr" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostbyname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostbyname_ex" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getincrementaldecoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getincrementalencoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getinfo" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="getinnerframes" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getint" func="yes">
			<Overload retVal="" descr="Function of Tix.getint">
			</Overload>
		</KeyWord>
		<KeyWord name="getline" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="getlineno" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getlines" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="getlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="getmember" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="getmembers" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmethparlist" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="getmodule" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmoduleinfo" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmodulename" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmro" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmtime" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getnameinfo" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getnames" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="getnode" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt" func="yes">
			<Overload retVal="" descr="Parser for command line options.&#10;&#10;This module helps scripts to parse the command line arguments in&#10;sys.argv.  It supports the same conventions as the Unix getopt()&#10;function (including the special meanings of arguments of the form `-'&#10;and `--').  Long options similar to those supported by GNU software&#10;may be used as well via an optional third argument.  This module&#10;provides two functions and an exception:&#10;&#10;getopt() -- Parse command line options&#10;gnu_getopt() -- Like getopt(), but allow option and non-option arguments&#10;to be intermixed.&#10;GetoptError -- exception (class) raised with 'opt' attribute, which is the&#10;option involved with the exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.GetoptError" />
		<KeyWord name="getopt.GetoptError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.GetoptError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.do_longs" />
		<KeyWord name="getopt.do_shorts" />
		<KeyWord name="getopt.error" />
		<KeyWord name="getopt.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.getopt" func="yes">
			<Overload retVal="" descr="getopt(args, options[, long_options]) -&gt; opts, args&#10;&#10;Parses command line options and parameter list.  args is the&#10;argument list to be parsed, without the leading reference to the&#10;running program.  Typically, this means &quot;sys.argv[1:]&quot;.  shortopts&#10;is the string of option letters that the script wants to&#10;recognize, with options that require an argument followed by a&#10;colon (i.e., the same format that Unix getopt() uses).  If&#10;specified, longopts is a list of strings with the names of the&#10;long options which should be supported.  The leading '--'&#10;characters should not be included in the option name.  Options&#10;which require an argument should be followed by an equal sign&#10;('=').&#10;&#10;The return value consists of two elements: the first is a list of&#10;(option, value) pairs; the second is the list of program arguments&#10;left after the option list was stripped (this is a trailing slice&#10;of the first argument).  Each option-and-value pair returned has&#10;the option as its first element, prefixed with a hyphen (e.g.,&#10;'-x'), and the option argument as its second element, or an empty&#10;string if the option has no argument.  The options occur in the&#10;list in the same order in which they were found, thus allowing&#10;multiple occurrences.  Long and short options may be mixed.">
				<Param name="args" />
				<Param name="shortopts" />
				<Param name="[longopts=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.gnu_getopt" func="yes">
			<Overload retVal="" descr="getopt(args, options[, long_options]) -&gt; opts, args&#10;&#10;This function works like getopt(), except that GNU style scanning&#10;mode is used by default. This means that option and non-option&#10;arguments may be intermixed. The getopt() function stops&#10;processing options as soon as a non-option argument is&#10;encountered.&#10;&#10;If the first character of the option string is `+', or if the&#10;environment variable POSIXLY_CORRECT is set, then option&#10;processing stops as soon as a non-option argument is encountered.">
				<Param name="args" />
				<Param name="shortopts" />
				<Param name="[longopts=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.long_has_args" />
		<KeyWord name="getopt.short_has_arg" />
		<KeyWord name="getouterframes" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getoutput" func="yes">
			<Overload retVal="" descr="Function of commands">
			</Overload>
		</KeyWord>
		<KeyWord name="getpager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="getparser" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass" func="yes">
			<Overload retVal="" descr="Utilities to get a password and/or the current user name.&#10;&#10;getpass(prompt[, stream]) - Prompt for a password, with echo turned off.&#10;getuser() - Get the user name from the environment or password database.&#10;&#10;GetPassWarning - This UserWarning is issued when getpass() cannot prevent&#10;                 echoing of the password contents while reading.&#10;&#10;On Windows, the msvcrt module will be used.&#10;On the Mac EasyDialogs.AskPassword is used, if available.">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.GetPassWarning" />
		<KeyWord name="getpass.GetPassWarning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.GetPassWarning.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.fallback_getpass" func="yes">
			<Overload retVal="" descr=>
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.getpass" func="yes">
			<Overload retVal="" descr="Prompt for password with echo off, using Windows getch().">
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.getuser" func="yes">
			<Overload retVal="" descr="Get the username from the environment or password database.&#10;&#10;First try various environment variables, then the password&#10;database.  This works on Windows as long as USERNAME is set.">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.unix_getpass" func="yes">
			<Overload retVal="" descr="Prompt for a password, with echo turned off.&#10;&#10;Args:&#10;  prompt: Written on stream to ask for the input.  Default: 'Password: '&#10;  stream: A writable file object to display the prompt.  Defaults to&#10;          the tty.  If no tty is available defaults to sys.stderr.&#10;Returns:&#10;  The seKr3t input.&#10;Raises:&#10;  EOFError: If our input tty or stdin was closed.&#10;  GetPassWarning: When we were unable to turn echo off on the input.&#10;&#10;Always restores terminal settings before returning.">
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.win_getpass" func="yes">
			<Overload retVal="" descr="Prompt for password with echo off, using Windows getch().">
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpeercert" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="getpeername" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="getpen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="getpid" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getpreferredencoding" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="getprotobyname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getproxies" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="getproxies_environment" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="getproxies_registry" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="getrandbits" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="getreader" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getscreen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="getservbyname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getservbyport" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getshapes" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="getsitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="getsize" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getsockname" func="yes">
			<Overload retVal="" descr="Function of ssl.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getsockopt" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="getsource" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getsourcefile" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getsourcelines" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getstate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="getstats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="getstatus" func="yes">
			<Overload retVal="" descr="Function of commands">
			</Overload>
		</KeyWord>
		<KeyWord name="getstatusoutput" func="yes">
			<Overload retVal="" descr="Function of commands">
			</Overload>
		</KeyWord>
		<KeyWord name="gettarinfo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="gettempdir" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="gettempprefix" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="getter" func="yes">
			<Overload retVal="" descr="Descriptor to change the getter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext" func="yes">
			<Overload retVal="" descr="Internationalization and localization support.&#10;&#10;This module provides internationalization (I18N) and localization (L10N)&#10;support for your Python programs by providing an interface to the GNU gettext&#10;message catalog library.&#10;&#10;I18N refers to the operation by which a program is made aware of multiple&#10;languages.  L10N refers to the adaptation of your program, once&#10;internationalized, to the local language and cultural habits.">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.Catalog" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[languages=None" />
				<Param name="[class_=None" />
				<Param name="[fallback=False" />
				<Param name="[codeset=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.ENOENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.GNUTranslations" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.NullTranslations" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.bind_textdomain_codeset" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[codeset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.bindtextdomain" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.c2py" func="yes">
			<Overload retVal="" descr="Gets a C expression as used in PO files for plural forms and returns a&#10;Python lambda function that implements an equivalent expression.">
				<Param name="plural" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.dgettext" />
		<KeyWord name="gettext.dngettext" />
		<KeyWord name="gettext.find" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[languages=None" />
				<Param name="[all=0]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.gettext" />
		<KeyWord name="gettext.install" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[unicode=False" />
				<Param name="[codeset=None" />
				<Param name="[names=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.ldgettext" />
		<KeyWord name="gettext.ldngettext" />
		<KeyWord name="gettext.lgettext" />
		<KeyWord name="gettext.lngettext" />
		<KeyWord name="gettext.ngettext" />
		<KeyWord name="gettext.test" func="yes">
			<Overload retVal="" descr="Implements the C expression:&#10;&#10;  condition ? true : false&#10;&#10;Required to correctly interpret plural forms.">
				<Param name="condition" />
				<Param name="true" />
				<Param name="false" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.textdomain" func="yes">
			<Overload retVal="" descr=>
				<Param name="[domain=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.translation" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[languages=None" />
				<Param name="[class_=None" />
				<Param name="[fallback=False" />
				<Param name="[codeset=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettimeout" func="yes">
			<Overload retVal="" descr="Function of socket.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getturtle" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="geturl" func="yes">
			<Overload retVal="" descr="Function of urllib2.HTTPError">
			</Overload>
		</KeyWord>
		<KeyWord name="getuser" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="getuserbase" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="getusersitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="getvalue" func="yes">
			<Overload retVal="" descr="Function of io.StringIO">
			</Overload>
		</KeyWord>
		<KeyWord name="getvar" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="getweakrefcount" func="yes">
			<Overload retVal="" descr="Function of weakref">
			</Overload>
		</KeyWord>
		<KeyWord name="getweakrefs" func="yes">
			<Overload retVal="" descr="Function of weakref">
			</Overload>
		</KeyWord>
		<KeyWord name="getwriter" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="glob" func="yes">
			<Overload retVal="" descr="Filename globbing utility.">
			</Overload>
		</KeyWord>
		<KeyWord name="glob.glob" func="yes">
			<Overload retVal="" descr="Return a list of paths matching a pathname pattern.&#10;&#10;The pattern may contain simple shell-style wildcards a la&#10;fnmatch. However, unlike fnmatch, filenames starting with a&#10;dot are special cases that are not matched by '*' and '?'&#10;patterns.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="glob.glob0" />
		<KeyWord name="glob.glob1" />
		<KeyWord name="glob.has_magic" />
		<KeyWord name="glob.iglob" func="yes">
			<Overload retVal="" descr="Return an iterator which yields the paths matching a pathname pattern.&#10;&#10;The pattern may contain simple shell-style wildcards a la&#10;fnmatch. However, unlike fnmatch, filenames starting with a&#10;dot are special cases that are not matched by '*' and '?'&#10;patterns.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="glob.magic_check" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="glob0" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="glob1" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="global" />
		<KeyWord name="globals" func="yes">
			<Overload retVal="" descr="globals() -&gt; dictionary&#10;&#10;Return the dictionary containing the current scope's global variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="gnu_getopt" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="goto" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="grab_current" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grab_release" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grab_set" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grab_set_global" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grab_status" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grey" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="grid" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_bbox" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_columnconfigure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_configure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_forget" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_info" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_location" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_propagate" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_remove" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_rowconfigure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_size" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="grid_slaves" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="group" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="guess_all_extensions" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="guess_extension" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="guess_type" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="gui" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip" func="yes">
			<Overload retVal="" descr="Functions that read and write gzipped files.&#10;&#10;The user of the file doesn't have to worry about the compression,&#10;but random access is not allowed.">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FCOMMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FEXTRA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FHCRC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FNAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FTEXT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.GzipFile" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.WRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.open" func="yes">
			<Overload retVal="" descr="Shorthand for GzipFile(filename, mode, compresslevel).&#10;&#10;The filename argument is required; mode defaults to 'rb'&#10;and compresslevel defaults to 9.">
				<Param name="filename" />
				<Param name="[mode=rb" />
				<Param name="[compresslevel=9]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.read32" />
		<KeyWord name="gzip.write32u" />
		<KeyWord name="gzip_decode" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip_encode" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib">
			</Overload>
		</KeyWord>
		<KeyWord name="gzopen" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="handle" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionImpossible">
			</Overload>
		</KeyWord>
		<KeyWord name="handleError" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="handler" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="has_children" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="has_exec" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="has_import_star" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="has_magic" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="hasattr" func="yes">
			<Overload retVal="" descr="hasattr(object, name) -&gt; bool&#10;&#10;Return whether the object has an attribute with the given name.&#10;(This is done by calling getattr(object, name) and catching exceptions.)">
			</Overload>
		</KeyWord>
		<KeyWord name="hash" func="yes">
			<Overload retVal="" descr="hash(object) -&gt; integer&#10;&#10;Return a hash value for the object.  Two objects with the same value have&#10;the same hash value.  The reverse is not necessarily true, but likely.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib" func="yes">
			<Overload retVal="" descr="hashlib module - A common interface to many hash functions.&#10;&#10;new(name, string='') - returns a new hash object implementing the&#10;                       given hash function; initializing the hash&#10;                       using the given string data.&#10;&#10;Named constructor functions are also available, these are much faster&#10;than using new():&#10;&#10;md5(), sha1(), sha224(), sha256(), sha384(), and sha512()&#10;&#10;More algorithms may be available on your platform but the above are guaranteed&#10;to exist.  See the algorithms_guaranteed and algorithms_available attributes&#10;to find out what algorithm names can be passed to new().&#10;&#10;NOTE: If you want the adler32 or crc32 hash functions they are available in&#10;the zlib module.&#10;&#10;Choose your hash function wisely.  Some have known collision weaknesses.&#10;sha384 and sha512 will be slow on 32 bit platforms.&#10;&#10;Hash objects have these methods:&#10; - update(arg): Update the hash object with the string arg. Repeated calls&#10;                are equivalent to a single call with the concatenation of all&#10;                the arguments.&#10; - digest():    Return the digest of the strings passed to the update() method&#10;                so far. This may contain non-ASCII characters, including&#10;                NUL bytes.&#10; - hexdigest(): Like digest() except the digest is returned as a string of&#10;                double length, containing only hexadecimal digits.&#10; - copy():      Return a copy (clone) of the hash object. This can be used to&#10;                efficiently compute the digests of strings that share a common&#10;                initial substring.&#10;&#10;For example, to obtain the digest of the string 'Nobody inspects the&#10;spammish repetition':&#10;&#10;    &gt;&gt;&gt; import hashlib&#10;    &gt;&gt;&gt; m = hashlib.md5()&#10;    &gt;&gt;&gt; m.update(&quot;Nobody inspects&quot;)&#10;    &gt;&gt;&gt; m.update(&quot; the spammish repetition&quot;)&#10;    &gt;&gt;&gt; m.digest()&#10;    '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'&#10;&#10;More condensed:&#10;&#10;    &gt;&gt;&gt; hashlib.sha224(&quot;Nobody inspects the spammish repetition&quot;).hexdigest()&#10;    'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.algorithms" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.algorithms_available" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.algorithms_guaranteed" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.md5" func="yes">
			<Overload retVal="" descr="Returns a md5 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.new" func="yes">
			<Overload retVal="" descr="new(name, string='') - Return a new hashing object using the named algorithm;&#10;optionally initialized with a string.">
				<Param name="name" />
				<Param name="[string]" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.pbkdf2_hmac" func="yes">
			<Overload retVal="" descr="pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None) -&gt; key&#10;&#10;Password based key derivation function 2 (PKCS #5 v2.0) with HMAC as&#10;pseudorandom function.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha1" func="yes">
			<Overload retVal="" descr="Returns a sha1 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha224" func="yes">
			<Overload retVal="" descr="Returns a sha224 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha256" func="yes">
			<Overload retVal="" descr="Returns a sha256 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha384" func="yes">
			<Overload retVal="" descr="Returns a sha384 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha512" func="yes">
			<Overload retVal="" descr="Returns a sha512 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashopen" func="yes">
			<Overload retVal="" descr="Function of bsddb">
			</Overload>
		</KeyWord>
		<KeyWord name="heading" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="heapify" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heappop" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heappush" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heappushpop" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq" func="yes">
			<Overload retVal="" descr="Heap queue algorithm (a.k.a. priority queue).&#10;&#10;Heaps are arrays for which a[k] &lt;= a[2*k+1] and a[k] &lt;= a[2*k+2] for&#10;all k, counting elements from 0.  For the sake of comparison,&#10;non-existing elements are considered to be infinite.  The interesting&#10;property of a heap is that a[0] is always its smallest element.&#10;&#10;Usage:&#10;&#10;heap = []            # creates an empty heap&#10;heappush(heap, item) # pushes a new item on the heap&#10;item = heappop(heap) # pops the smallest item from the heap&#10;item = heap[0]       # smallest item on the heap without popping it&#10;heapify(x)           # transforms list into a heap, in-place, in linear time&#10;item = heapreplace(heap, item) # pops and returns smallest item, and adds&#10;                               # new item; the heap size is unchanged&#10;&#10;Our API differs from textbook heap algorithms as follows:&#10;&#10;- We use 0-based indexing.  This makes the relationship between the&#10;  index for a node and the indexes for its children slightly less&#10;  obvious, but is more suitable since Python uses 0-based indexing.&#10;&#10;- Our heappop() method returns the smallest item, not the largest.&#10;&#10;These two make it possible to view the heap as a regular Python list&#10;without surprises: heap[0] is the smallest item, and heap.sort()&#10;maintains the heap invariant!">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.chain" func="yes">
			<Overload retVal="" descr="chain(*iterables) --&gt; chain object&#10;&#10;Return a chain object whose .next() method returns elements from the&#10;first iterable until it is exhausted, then elements from the next&#10;iterable, until all of the iterables are exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.chain.from_iterable" func="yes">
			<Overload retVal="" descr="chain.from_iterable(iterable) --&gt; chain object&#10;&#10;Alternate chain() contructor taking a single iterable argument&#10;that evaluates lazily.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.chain.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.cmp_lt" />
		<KeyWord name="heapq.count" func="yes">
			<Overload retVal="" descr="count(start=0, step=1) --&gt; count object&#10;&#10;Return a count object whose .next() method returns consecutive values.&#10;Equivalent to:&#10;&#10;    def count(firstval=0, step=1):&#10;        x = firstval&#10;        while 1:&#10;            yield x&#10;            x += step">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.count.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heapify" func="yes">
			<Overload retVal="" descr="Transform list into a heap, in-place, in O(len(heap)) time.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heappop" func="yes">
			<Overload retVal="" descr="Pop the smallest item off the heap, maintaining the heap invariant.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heappush" func="yes">
			<Overload retVal="" descr="heappush(heap, item) -&gt; None. Push item onto heap, maintaining the heap invariant.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heappushpop" func="yes">
			<Overload retVal="" descr="heappushpop(heap, item) -&gt; value. Push item on the heap, then pop and return the smallest item&#10;from the heap. The combined action runs more efficiently than&#10;heappush() followed by a separate call to heappop().">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heapreplace" func="yes">
			<Overload retVal="" descr="heapreplace(heap, item) -&gt; value. Pop and return the current smallest value, and add the new item.&#10;&#10;This is more efficient than heappop() followed by heappush(), and can be&#10;more appropriate when using a fixed-size heap.  Note that the value&#10;returned may be larger than item!  That constrains reasonable uses of&#10;this routine unless written as part of a conditional replacement:&#10;&#10;    if item &gt; heap[0]:&#10;        item = heapreplace(heap, item)">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.imap" func="yes">
			<Overload retVal="" descr="imap(func, *iterables) --&gt; imap object&#10;&#10;Make an iterator that computes the function using arguments from&#10;each of the iterables.  Like map() except that it returns&#10;an iterator instead of a list and that it stops when the shortest&#10;iterable is exhausted instead of filling in None for shorter&#10;iterables.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.imap.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.islice" func="yes">
			<Overload retVal="" descr="islice(iterable, [start,] stop [, step]) --&gt; islice object&#10;&#10;Return an iterator whose next() method returns selected values from an&#10;iterable.  If start is specified, will skip all preceding elements;&#10;otherwise, start defaults to zero.  Step defaults to one.  If&#10;specified as another value, step determines how many values are &#10;skipped between successive calls.  Works like a slice() on a list&#10;but returns an iterator.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.islice.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.itemgetter" func="yes">
			<Overload retVal="" descr="itemgetter(item, ...) --&gt; itemgetter object&#10;&#10;Return a callable object that fetches the given item(s) from its operand.&#10;After f = itemgetter(2), the call f(r) returns r[2].&#10;After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.izip" func="yes">
			<Overload retVal="" descr="izip(iter1 [,iter2 [...]]) --&gt; izip object&#10;&#10;Return a izip object whose .next() method returns a tuple where&#10;the i-th element comes from the i-th iterable argument.  The .next()&#10;method continues until the shortest iterable in the argument sequence&#10;is exhausted and then it raises StopIteration.  Works like the zip()&#10;function but consumes less memory by returning an iterator instead of&#10;a list.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.izip.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.merge" func="yes">
			<Overload retVal="" descr="Merge multiple sorted inputs into a single sorted output.&#10;&#10;Similar to sorted(itertools.chain(*iterables)) but returns a generator,&#10;does not pull the data into memory all at once, and assumes that each of&#10;the input streams is already sorted (smallest to largest).&#10;&#10;&gt;&gt;&gt; list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))&#10;[0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.nlargest" func="yes">
			<Overload retVal="" descr="Find the n largest elements in a dataset.&#10;&#10;Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]">
				<Param name="n" />
				<Param name="iterable" />
				<Param name="[key=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.nsmallest" func="yes">
			<Overload retVal="" descr="Find the n smallest elements in a dataset.&#10;&#10;Equivalent to:  sorted(iterable, key=key)[:n]">
				<Param name="n" />
				<Param name="iterable" />
				<Param name="[key=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.tee" func="yes">
			<Overload retVal="" descr="tee(iterable, n=2) --&gt; tuple of n independent iterators.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapreplace" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="help" func="yes">
			<Overload retVal="" descr="Function of cProfile">
			</Overload>
		</KeyWord>
		<KeyWord name="hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="hexbin" func="yes">
			<Overload retVal="" descr="Function of binhex">
			</Overload>
		</KeyWord>
		<KeyWord name="hideturtle" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="hls_to_rgb" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac" func="yes">
			<Overload retVal="" descr="HMAC (Keyed-Hashing for Message Authentication) Python module.&#10;&#10;Implements the HMAC algorithm as described by RFC 2104.">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.compare_digest" func="yes">
			<Overload retVal="" descr="compare_digest(a, b) -&gt; bool&#10;&#10;Return 'a == b'.  This function uses an approach designed to prevent&#10;timing analysis, making it appropriate for cryptography.&#10;a and b must both be of the same type: either str (ASCII only),&#10;or any type that supports the buffer protocol (e.g. bytes).&#10;&#10;Note: If a and b are of different lengths, or if an error occurs,&#10;a timing attack could theoretically reveal information about the&#10;types and lengths of a and b--but not their values.">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.new" func="yes">
			<Overload retVal="" descr="Create a new hashing object and return it.&#10;&#10;key: The starting key for the hash.&#10;msg: if available, will immediately be hashed into the object's starting&#10;state.&#10;&#10;You can now feed arbitrary strings into the object using its update()&#10;method, and can ask for the hash value at any time by calling its digest()&#10;method.">
				<Param name="key" />
				<Param name="[msg=None" />
				<Param name="[digestmod=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.trans_36" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.trans_5C" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.x" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="home" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="hook_compressed" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="hook_encoded" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="hotshot" func="yes">
			<Overload retVal="" descr="High-perfomance logging profiler, mostly written in C.">
			</Overload>
		</KeyWord>
		<KeyWord name="hotshot.Profile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="hotshot.ProfilerError" />
		<KeyWord name="hotshot.ProfilerError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hotshot.ProfilerError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hsv_to_rgb" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="ht" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="html" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="htmlentitydefs" func="yes">
			<Overload retVal="" descr="HTML character entity references.">
			</Overload>
		</KeyWord>
		<KeyWord name="htmlentitydefs.codepoint2name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="htmlentitydefs.entitydefs" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="htmlentitydefs.name2codepoint" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="htmllib" func="yes">
			<Overload retVal="" descr="HTML 2.0 parser.&#10;&#10;See the HTML 2.0 specification:&#10;http://www.w3.org/hypertext/WWW/MarkUp/html-spec/html-spec_toc.html">
			</Overload>
		</KeyWord>
		<KeyWord name="htmllib.HTMLParseError" func="yes">
			<Overload retVal="" descr="Error raised when an HTML document can't be parsed.">
			</Overload>
		</KeyWord>
		<KeyWord name="htmllib.HTMLParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="htmllib.HTMLParseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="htmllib.HTMLParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="htmllib.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="htonl" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="htons" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="http2time" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib" func="yes">
			<Overload retVal="" descr="HTTP/1.1 client library&#10;&#10;&lt;intro stuff goes here&gt;&#10;&lt;other stuff, too&gt;&#10;&#10;HTTPConnection goes through a number of &quot;states&quot;, which define when a client&#10;may legally make another request or fetch the response for a particular&#10;request. This diagram details these state transitions:&#10;&#10;    (null)&#10;      |&#10;      | HTTPConnection()&#10;      v&#10;    Idle&#10;      |&#10;      | putrequest()&#10;      v&#10;    Request-started&#10;      |&#10;      | ( putheader() )*  endheaders()&#10;      v&#10;    Request-sent&#10;      |&#10;      | response = getresponse()&#10;      v&#10;    Unread-response   [Response-headers-read]&#10;      |\____________________&#10;      |                     |&#10;      | response.read()     | putrequest()&#10;      v                     v&#10;    Idle                  Req-started-unread-response&#10;                     ______/|&#10;                   /        |&#10;   response.read() |        | ( putheader() )*  endheaders()&#10;                   v        v&#10;       Request-started    Req-sent-unread-response&#10;                            |&#10;                            | response.read()&#10;                            v&#10;                          Request-sent&#10;&#10;This diagram presents the following rules:&#10;  -- a second request may not be started until {response-headers-read}&#10;  -- a response [object] cannot be retrieved until {request-sent}&#10;  -- there is no differentiation between an unread response body and a&#10;     partially read response body&#10;&#10;Note: this enforcement is applied by the HTTPConnection class. The&#10;      HTTPResponse class does not enforce this state machine, which&#10;      implies sophisticated clients may accelerate the request/response&#10;      pipeline. Caution should be taken, though: accelerating the states&#10;      beyond the above pattern may imply knowledge of the server's&#10;      connection-close behavior for certain requests. For example, it&#10;      is impossible to tell whether the server will close the connection&#10;      UNTIL the response headers have been read; this means that further&#10;      requests cannot be placed into the pipeline until it is known that&#10;      the server will NOT be closing the connection.&#10;&#10;Logical State                  __state            __response&#10;-------------                  -------            ----------&#10;Idle                           _CS_IDLE           None&#10;Request-started                _CS_REQ_STARTED    None&#10;Request-sent                   _CS_REQ_SENT       None&#10;Unread-response                _CS_IDLE           &lt;response_class&gt;&#10;Req-started-unread-response    _CS_REQ_STARTED    &lt;response_class&gt;&#10;Req-sent-unread-response       _CS_REQ_SENT       &lt;response_class&gt;">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.ACCEPTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.BAD_GATEWAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.BAD_REQUEST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.BadStatusLine" />
		<KeyWord name="httplib.BadStatusLine.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.BadStatusLine.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CONFLICT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CONTINUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CREATED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CannotSendHeader" />
		<KeyWord name="httplib.CannotSendHeader.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CannotSendHeader.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CannotSendRequest" />
		<KeyWord name="httplib.CannotSendRequest.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.CannotSendRequest.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.EXPECTATION_FAILED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.FAILED_DEPENDENCY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.FORBIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.FOUND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.FakeSocket" />
		<KeyWord name="httplib.GATEWAY_TIMEOUT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.GONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTP" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPConnection" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPException" />
		<KeyWord name="httplib.HTTPException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPException.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPResponse" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPS" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPSConnection" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTPS_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.HTTP_VERSION_NOT_SUPPORTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.IM_USED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.INSUFFICIENT_STORAGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.INTERNAL_SERVER_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.ImproperConnectionState" />
		<KeyWord name="httplib.ImproperConnectionState.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.ImproperConnectionState.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.IncompleteRead" />
		<KeyWord name="httplib.IncompleteRead.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.IncompleteRead.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.InvalidURL" />
		<KeyWord name="httplib.InvalidURL.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.InvalidURL.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.LENGTH_REQUIRED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.LOCKED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.LineAndFileWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.LineTooLong" />
		<KeyWord name="httplib.LineTooLong.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.LineTooLong.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.MAXAMOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.METHOD_NOT_ALLOWED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.MOVED_PERMANENTLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.MULTIPLE_CHOICES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.MULTI_STATUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NON_AUTHORITATIVE_INFORMATION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NOT_ACCEPTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NOT_EXTENDED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NOT_FOUND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NOT_IMPLEMENTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NOT_MODIFIED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NO_CONTENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NotConnected" />
		<KeyWord name="httplib.NotConnected.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.NotConnected.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.PARTIAL_CONTENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.PAYMENT_REQUIRED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.PRECONDITION_FAILED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.PROCESSING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.PROXY_AUTHENTICATION_REQUIRED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.REQUESTED_RANGE_NOT_SATISFIABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.REQUEST_ENTITY_TOO_LARGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.REQUEST_TIMEOUT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.REQUEST_URI_TOO_LONG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.RESET_CONTENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.ResponseNotReady" />
		<KeyWord name="httplib.ResponseNotReady.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.ResponseNotReady.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.SEE_OTHER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.SERVICE_UNAVAILABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.SWITCHING_PROTOCOLS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.TEMPORARY_REDIRECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UNAUTHORIZED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UNPROCESSABLE_ENTITY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UNSUPPORTED_MEDIA_TYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UPGRADE_REQUIRED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.USE_PROXY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UnimplementedFileMode" />
		<KeyWord name="httplib.UnimplementedFileMode.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UnimplementedFileMode.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UnknownProtocol" />
		<KeyWord name="httplib.UnknownProtocol.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UnknownProtocol.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UnknownTransferEncoding" />
		<KeyWord name="httplib.UnknownTransferEncoding.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.UnknownTransferEncoding.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array" func="yes">
			<Overload retVal="" descr="array(typecode [, initializer]) -&gt; array&#10;&#10;Return a new array whose items are restricted by typecode, and&#10;initialized from the optional initializer value, which must be a list,&#10;string or iterable over elements of the appropriate type.&#10;&#10;Arrays represent basic values and behave very much like lists, except&#10;the type of objects stored in them is constrained.&#10;&#10;Methods:&#10;&#10;append() -- append a new item to the end of the array&#10;buffer_info() -- return information giving the current memory info&#10;byteswap() -- byteswap all the items of the array&#10;count() -- return number of occurrences of an object&#10;extend() -- extend array by appending multiple elements from an iterable&#10;fromfile() -- read items from a file object&#10;fromlist() -- append items from the list&#10;fromstring() -- append items from the string&#10;index() -- return index of first occurrence of an object&#10;insert() -- insert a new item into the array at a provided position&#10;pop() -- remove and return item (default last)&#10;read() -- DEPRECATED, use fromfile()&#10;remove() -- remove first occurrence of an object&#10;reverse() -- reverse the order of the items in the array&#10;tofile() -- write all items to a file object&#10;tolist() -- return the array converted to an ordinary list&#10;tostring() -- return the array converted to a string&#10;write() -- DEPRECATED, use tofile()&#10;&#10;Attributes:&#10;&#10;typecode -- the typecode character used to create the array&#10;itemsize -- the length in bytes of one array item">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.append" func="yes">
			<Overload retVal="" descr="append(x)&#10;&#10;Append new value x to the end of the array.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.buffer_info" func="yes">
			<Overload retVal="" descr="buffer_info() -&gt; (address, length)&#10;&#10;Return a tuple (address, length) giving the current memory address and&#10;the length in items of the buffer used to hold array's contents&#10;The length should be multiplied by the itemsize attribute to calculate&#10;the buffer length in bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.byteswap" func="yes">
			<Overload retVal="" descr="byteswap()&#10;&#10;Byteswap all items of the array.  If the items in the array are not 1, 2,&#10;4, or 8 bytes in size, RuntimeError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.count" func="yes">
			<Overload retVal="" descr="count(x)&#10;&#10;Return number of occurrences of x in the array.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.extend" func="yes">
			<Overload retVal="" descr="extend(array or iterable)&#10;&#10;Append items to the end of the array.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.fromfile" func="yes">
			<Overload retVal="" descr="fromfile(f, n)&#10;&#10;Read n objects from the file object f and append them to the end of the&#10;array.  Also called as read.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.fromlist" func="yes">
			<Overload retVal="" descr="fromlist(list)&#10;&#10;Append items to array from list.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.fromstring" func="yes">
			<Overload retVal="" descr="fromstring(string)&#10;&#10;Appends items from the string, interpreting it as an array of machine&#10;values,as if it had been read from a file using the fromfile() method).">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.fromunicode" func="yes">
			<Overload retVal="" descr="fromunicode(ustr)&#10;&#10;Extends this array with data from the unicode string ustr.&#10;The array must be a type 'u' array; otherwise a ValueError&#10;is raised.  Use array.fromstring(ustr.decode(...)) to&#10;append Unicode data to an array of some other type.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.index" func="yes">
			<Overload retVal="" descr="index(x)&#10;&#10;Return index of first occurrence of x in the array.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.insert" func="yes">
			<Overload retVal="" descr="insert(i,x)&#10;&#10;Insert a new item x into the array before position i.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.itemsize" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.pop" func="yes">
			<Overload retVal="" descr="pop([i])&#10;&#10;Return the i-th element and delete it from the array. i defaults to -1.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.read" func="yes">
			<Overload retVal="" descr="fromfile(f, n)&#10;&#10;Read n objects from the file object f and append them to the end of the&#10;array.  Also called as read.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.remove" func="yes">
			<Overload retVal="" descr="remove(x)&#10;&#10;Remove the first occurrence of x in the array.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.reverse" func="yes">
			<Overload retVal="" descr="reverse()&#10;&#10;Reverse the order of the items in the array.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.tofile" func="yes">
			<Overload retVal="" descr="tofile(f)&#10;&#10;Write all items (as machine values) to the file object f.  Also called as&#10;write.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.tolist" func="yes">
			<Overload retVal="" descr="tolist() -&gt; list&#10;&#10;Convert array to an ordinary list with the same items.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.tostring" func="yes">
			<Overload retVal="" descr="tostring() -&gt; string&#10;&#10;Convert the array to an array of machine values and return the string&#10;representation.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.tounicode" func="yes">
			<Overload retVal="" descr="tounicode() -&gt; unicode&#10;&#10;Convert the array to a unicode string.  The array must be&#10;a type 'u' array; otherwise a ValueError is raised.  Use&#10;array.tostring().decode() to obtain a unicode string from&#10;an array of some other type.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.typecode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.array.write" func="yes">
			<Overload retVal="" descr="tofile(f)&#10;&#10;Write all items (as machine values) to the file object f.  Also called as&#10;write.">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.error" />
		<KeyWord name="httplib.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.responses" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="httplib.urlsplit" func="yes">
			<Overload retVal="" descr="Parse a URL into 5 components:&#10;&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;&#10;Return a 5-tuple: (scheme, netloc, path, query, fragment).&#10;Note that we don't break the components up in smaller bits&#10;(e.g. netloc is a single string) and we don't expand % escapes.">
				<Param name="url" />
				<Param name="[scheme" />
				<Param name="[allow_fragments=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="hypot" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="id" func="yes">
			<Overload retVal="" descr="id(object) -&gt; integer&#10;&#10;Return the identity of an object.  This is guaranteed to be unique among&#10;simultaneously existing objects.  (Hint: it's the object's memory address.)">
			</Overload>
		</KeyWord>
		<KeyWord name="identify" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="idlelib" />
		<KeyWord name="if" />
		<KeyWord name="ifilter" func="yes">
			<Overload retVal="" descr="Function of sets.ifilter">
			</Overload>
		</KeyWord>
		<KeyWord name="ifilterfalse" func="yes">
			<Overload retVal="" descr="Function of filecmp.ifilterfalse">
			</Overload>
		</KeyWord>
		<KeyWord name="iglob" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="ignore_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="ignore_patterns" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks" func="yes">
			<Overload retVal="" descr="Import hook support.&#10;&#10;Consistent use of this module will make it possible to change the&#10;different mechanisms involved in loading modules independently.&#10;&#10;While the built-in module imp exports interfaces to the built-in&#10;module searching and loading algorithm, and it is possible to replace&#10;the built-in function __import__ in order to change the semantics of&#10;the import statement, until now it has been difficult to combine the&#10;effect of different __import__ hacks, like loading modules from URLs&#10;by rimport.py, or restricted execution by rexec.py.&#10;&#10;This module defines three new concepts:&#10;&#10;1) A &quot;file system hooks&quot; class provides an interface to a filesystem.&#10;&#10;One hooks class is defined (Hooks), which uses the interface provided&#10;by standard modules os and os.path.  It should be used as the base&#10;class for other hooks classes.&#10;&#10;2) A &quot;module loader&quot; class provides an interface to search for a&#10;module in a search path and to load it.  It defines a method which&#10;searches for a module in a single directory; by overriding this method&#10;one can redefine the details of the search.  If the directory is None,&#10;built-in and frozen modules are searched instead.&#10;&#10;Two module loader class are defined, both implementing the search&#10;strategy used by the built-in __import__ function: ModuleLoader uses&#10;the imp module's find_module interface, while HookableModuleLoader&#10;uses a file system hooks class to interact with the file system.  Both&#10;use the imp module's load_* interfaces to actually load the module.&#10;&#10;3) A &quot;module importer&quot; class provides an interface to import a&#10;module, as well as interfaces to reload and unload a module.  It also&#10;provides interfaces to install and uninstall itself instead of the&#10;default __import__ and reload (and unload) functions.&#10;&#10;One module importer class is defined (ModuleImporter), which uses a&#10;module loader instance passed in (by default HookableModuleLoader is&#10;instantiated).&#10;&#10;The classes defined here should be used as base classes for extended&#10;functionality along those lines.&#10;&#10;If a module importer class supports dotted names, its import_module()&#10;must return a different value depending on whether it is called on&#10;behalf of a &quot;from ... import ...&quot; statement or not.  (This is caused&#10;by the way the __import__ hook is used by the Python interpreter.)  It&#10;would also do wise to install a different version of reload().">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.BUILTIN_MODULE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.BasicModuleImporter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.BasicModuleLoader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.C_BUILTIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.C_EXTENSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.FROZEN_MODULE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.FancyModuleLoader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.Hooks" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.ModuleImporter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.ModuleLoader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.PKG_DIRECTORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.PY_COMPILED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.PY_FROZEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.PY_SOURCE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.install" func="yes">
			<Overload retVal="" descr=>
				<Param name="[importer=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ihooks.uninstall" />
		<KeyWord name="ihooks.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="image_names" func="yes">
			<Overload retVal="" descr="Function of Tkinter">
			</Overload>
		</KeyWord>
		<KeyWord name="image_types" func="yes">
			<Overload retVal="" descr="Function of FileDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="imap" func="yes">
			<Overload retVal="" descr="Function of heapq.imap">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib" func="yes">
			<Overload retVal="" descr="IMAP4 client.&#10;&#10;Based on RFC 2060.&#10;&#10;Public class:           IMAP4&#10;Public variable:        Debug&#10;Public functions:       Internaldate2tuple&#10;                        Int2AP&#10;                        ParseFlags&#10;                        Time2Internaldate">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.AllowedVersions" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Commands" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Continuation" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Flags" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Int2AP" func="yes">
			<Overload retVal="" descr="Convert integer to A-P string representation.">
				<Param name="num" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.InternalDate" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Internaldate2tuple" func="yes">
			<Overload retVal="" descr="Parse an IMAP4 INTERNALDATE string.&#10;&#10;Return corresponding local time.  The return value is a&#10;time.struct_time instance or None if the string has wrong format.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Literal" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.MapCRLF" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Mon2num" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.ParseFlags" func="yes">
			<Overload retVal="" descr="Convert IMAP4 flags response to python tuple.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Response_code" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Time2Internaldate" func="yes">
			<Overload retVal="" descr="Convert date_time to IMAP4 INTERNALDATE representation.&#10;&#10;Return string in form: '&quot;DD-Mmm-YYYY HH:MM:SS +HHMM&quot;'.  The&#10;date_time argument can be a number (int or float) representing&#10;seconds since epoch (as returned by time.time()), a 9-tuple&#10;representing local time (as returned by time.localtime()), or a&#10;double-quoted string.  In the last case, it is assumed to already&#10;be in the correct format.">
				<Param name="date_time" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Untagged_response" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Untagged_status" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr" func="yes">
			<Overload retVal="" descr="Recognize image file formats based on their first few bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test" />
		<KeyWord name="imghdr.test_bmp" />
		<KeyWord name="imghdr.test_exif" func="yes">
			<Overload retVal="" descr="JPEG data in Exif format">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_gif" func="yes">
			<Overload retVal="" descr="GIF ('87 and '89 variants)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_jpeg" func="yes">
			<Overload retVal="" descr="JPEG data in JFIF format">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_pbm" func="yes">
			<Overload retVal="" descr="PBM (portable bitmap)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_pgm" func="yes">
			<Overload retVal="" descr="PGM (portable graymap)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_png" />
		<KeyWord name="imghdr.test_ppm" func="yes">
			<Overload retVal="" descr="PPM (portable pixmap)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_rast" func="yes">
			<Overload retVal="" descr="Sun raster file">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_rgb" func="yes">
			<Overload retVal="" descr="SGI image library">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_tiff" func="yes">
			<Overload retVal="" descr="TIFF (can be in Motorola or Intel byte order)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_xbm" func="yes">
			<Overload retVal="" descr="X bitmap (X10 or X11)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.testall" />
		<KeyWord name="imghdr.tests" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.what" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="[h=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="import" />
		<KeyWord name="import_module" func="yes">
			<Overload retVal="" descr="Function of importlib">
			</Overload>
		</KeyWord>
		<KeyWord name="importfile" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="importlib" func="yes">
			<Overload retVal="" descr="Backport of importlib.import_module from 3.x.">
			</Overload>
		</KeyWord>
		<KeyWord name="importlib.import_module" func="yes">
			<Overload retVal="" descr="Import a module.&#10;&#10;The 'package' argument is required when performing a relative import. It&#10;specifies the package to use as the anchor point from which to resolve the&#10;relative import to an absolute import.">
				<Param name="name" />
				<Param name="[package=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imputil" func="yes">
			<Overload retVal="" descr="Import utilities&#10;&#10;Exported classes:&#10;    ImportManager   Manage the import process&#10;&#10;    Importer        Base class for replacing standard import functions&#10;    BuiltinImporter Emulate the import mechanism for builtin and frozen modules&#10;&#10;    DynLoadSuffixImporter">
			</Overload>
		</KeyWord>
		<KeyWord name="imputil.BuiltinImporter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imputil.DynLoadSuffixImporter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imputil.ImportManager" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imputil.Importer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="imputil.py_suffix_importer" />
		<KeyWord name="in" />
		<KeyWord name="in_table_a1" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_b1" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c11" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c11_c12" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c12" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c21" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c21_c22" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c22" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c3" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c4" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c5" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c6" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c7" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c8" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c9" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_d1" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_d2" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="increment_lineno" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="indentsize" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="inet_aton" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="inet_ntoa" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="info" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="infolist" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="init" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="init_database" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="initlog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="input" func="yes">
			<Overload retVal="" descr="input([prompt]) -&gt; value&#10;&#10;Equivalent to eval(raw_input(prompt)).">
			</Overload>
		</KeyWord>
		<KeyWord name="insert" func="yes">
			<Overload retVal="" descr="B.insert(index, int) -&gt; None&#10;&#10;Insert a single item into the bytearray before the given index.">
			</Overload>
		</KeyWord>
		<KeyWord name="insort" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="insort_left" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="insort_right" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect" func="yes">
			<Overload retVal="" descr="Get useful information from live Python objects.&#10;&#10;This module encapsulates the interface provided by the internal special&#10;attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.&#10;It also provides some help for examining source code and class layout.&#10;&#10;Here are some of the useful functions provided by this module:&#10;&#10;    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),&#10;        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),&#10;        isroutine() - check object types&#10;    getmembers() - get members of an object that satisfy a given condition&#10;&#10;    getfile(), getsourcefile(), getsource() - find an object's source code&#10;    getdoc(), getcomments() - get documentation on an object&#10;    getmodule() - determine the module that an object came from&#10;    getclasstree() - arrange classes so as to represent their hierarchy&#10;&#10;    getargspec(), getargvalues(), getcallargs() - get info about function arguments&#10;    formatargspec(), formatargvalues() - format an argument spec&#10;    getouterframes(), getinnerframes() - get info about frames&#10;    currentframe() - get the current stack frame&#10;    stack(), trace() - get info about frames on the stack or in a traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo" func="yes">
			<Overload retVal="" descr="ArgInfo(args, varargs, keywords, locals)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.keywords" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.locals" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec" func="yes">
			<Overload retVal="" descr="ArgSpec(args, varargs, keywords, defaults)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.defaults" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.keywords" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments" func="yes">
			<Overload retVal="" descr="Arguments(args, varargs, keywords)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.keywords" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute" func="yes">
			<Overload retVal="" descr="Attribute(name, kind, defining_class, object)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.defining_class" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.kind" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.object" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BlockFinder" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_GENERATOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_NESTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_NEWLOCALS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_NOFREE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_OPTIMIZED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_VARARGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_VARKEYWORDS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.EndOfBlock" />
		<KeyWord name="inspect.EndOfBlock.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.EndOfBlock.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo" func="yes">
			<Overload retVal="" descr="ModuleInfo(name, suffix, mode, module_type)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo.mode" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo.module_type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ModuleInfo.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.TPFLAGS_IS_ABSTRACT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback" func="yes">
			<Overload retVal="" descr="Traceback(filename, lineno, function, code_context, index)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.code_context" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.filename" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.function" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.index" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.lineno" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.attrgetter" func="yes">
			<Overload retVal="" descr="attrgetter(attr, ...) --&gt; attrgetter object&#10;&#10;Return a callable object that fetches the given attribute(s) from its operand.&#10;After f = attrgetter('name'), the call f(r) returns r.name.&#10;After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).&#10;After h = attrgetter('name.first', 'name.last'), the call h(r) returns&#10;(r.name.first, r.name.last).">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.classify_class_attrs" func="yes">
			<Overload retVal="" descr="Return list of attribute-descriptor tuples.&#10;&#10;For each name in dir(cls), the return list contains a 4-tuple&#10;with these elements:&#10;&#10;    0. The name (a string).&#10;&#10;    1. The kind of attribute this is, one of these strings:&#10;           'class method'    created via classmethod()&#10;           'static method'   created via staticmethod()&#10;           'property'        created via property()&#10;           'method'          any other flavor of method&#10;           'data'            not a method&#10;&#10;    2. The class which defined this attribute (a class).&#10;&#10;    3. The object as obtained directly from the defining class's&#10;       __dict__, not via getattr.  This is especially important for&#10;       data attributes:  C.data is just a data object, but&#10;       C.__dict__['data'] may be a data descriptor with additional&#10;       info, like a __doc__ string.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.cleandoc" func="yes">
			<Overload retVal="" descr="Clean up indentation from docstrings.&#10;&#10;Any whitespace that can be uniformly removed from the second line&#10;onwards is removed.">
				<Param name="doc" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.currentframe" func="yes">
			<Overload retVal="" descr="_getframe([depth]) -&gt; frameobject&#10;&#10;Return a frame object from the call stack.  If optional integer depth is&#10;given, return the frame object that many calls below the top of the stack.&#10;If that is deeper than the call stack, ValueError is raised.  The default&#10;for depth is zero, returning the frame at the top of the call stack.&#10;&#10;This function should be used for internal and specialized&#10;purposes only.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.findsource" func="yes">
			<Overload retVal="" descr="Return the entire source file and starting line number for an object.&#10;&#10;The argument may be a module, class, method, function, traceback, frame,&#10;or code object.  The source code is returned as a list of all the lines&#10;in the file and the line number indexes a line in that list.  An IOError&#10;is raised if the source code cannot be retrieved.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.formatargspec" func="yes">
			<Overload retVal="" descr="Format an argument spec from the 4 values returned by getargspec.&#10;&#10;The first four arguments are (args, varargs, varkw, defaults).  The&#10;other four arguments are the corresponding optional formatting functions&#10;that are called to turn names and values into strings.  The ninth&#10;argument is an optional function to format the sequence of arguments.">
				<Param name="args" />
				<Param name="[varargs=None" />
				<Param name="[varkw=None" />
				<Param name="[defaults=None" />
				<Param name="[formatarg=<type 'str'>" />
				<Param name="[formatvarargs=<function <lambda> at 0x0000000002872978>" />
				<Param name="[formatvarkw=<function <lambda> at 0x00000000028729E8>" />
				<Param name="[formatvalue=<function <lambda> at 0x0000000002872A58>" />
				<Param name="[join=<function joinseq at 0x0000000002872898>]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.formatargvalues" func="yes">
			<Overload retVal="" descr="Format an argument spec from the 4 values returned by getargvalues.&#10;&#10;The first four arguments are (args, varargs, varkw, locals).  The&#10;next four arguments are the corresponding optional formatting functions&#10;that are called to turn names and values into strings.  The ninth&#10;argument is an optional function to format the sequence of arguments.">
				<Param name="args" />
				<Param name="varargs" />
				<Param name="varkw" />
				<Param name="locals" />
				<Param name="[formatarg=<type 'str'>" />
				<Param name="[formatvarargs=<function <lambda> at 0x0000000002872BA8>" />
				<Param name="[formatvarkw=<function <lambda> at 0x0000000002872C18>" />
				<Param name="[formatvalue=<function <lambda> at 0x0000000002872C88>" />
				<Param name="[join=<function joinseq at 0x0000000002872898>]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getabsfile" func="yes">
			<Overload retVal="" descr="Return an absolute path to the source or compiled file for an object.&#10;&#10;The idea is for each object to have a unique origin, so this routine&#10;normalizes the result as much as possible.">
				<Param name="object" />
				<Param name="[_filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getargs" func="yes">
			<Overload retVal="" descr="Get information about the arguments accepted by a code object.&#10;&#10;Three things are returned: (args, varargs, varkw), where 'args' is&#10;a list of argument names (possibly containing nested lists), and&#10;'varargs' and 'varkw' are the names of the * and ** arguments or None.">
				<Param name="co" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getargspec" func="yes">
			<Overload retVal="" descr="Get the names and default values of a function's arguments.&#10;&#10;A tuple of four things is returned: (args, varargs, varkw, defaults).&#10;'args' is a list of the argument names (it may contain nested lists).&#10;'varargs' and 'varkw' are the names of the * and ** arguments or None.&#10;'defaults' is an n-tuple of the default values of the last n arguments.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getargvalues" func="yes">
			<Overload retVal="" descr="Get information about arguments passed into a particular frame.&#10;&#10;A tuple of four things is returned: (args, varargs, varkw, locals).&#10;'args' is a list of the argument names (it may contain nested lists).&#10;'varargs' and 'varkw' are the names of the * and ** arguments or None.&#10;'locals' is the locals dictionary of the given frame.">
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getblock" func="yes">
			<Overload retVal="" descr="Extract the block of code at the top of the given list of lines.">
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getcallargs" func="yes">
			<Overload retVal="" descr="Get the mapping of arguments to values.&#10;&#10;A dict is returned, with keys the function argument names (including the&#10;names of the * and ** arguments, if any), and values the respective bound&#10;values from 'positional' and 'named'.">
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getclasstree" func="yes">
			<Overload retVal="" descr="Arrange the given list of classes into a hierarchy of nested lists.&#10;&#10;Where a nested list appears, it contains classes derived from the class&#10;whose entry immediately precedes the list.  Each entry is a 2-tuple&#10;containing a class and a tuple of its base classes.  If the 'unique'&#10;argument is true, exactly one entry appears in the returned structure&#10;for each class in the given list.  Otherwise, classes using multiple&#10;inheritance and their descendants will appear multiple times.">
				<Param name="classes" />
				<Param name="[unique=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getcomments" func="yes">
			<Overload retVal="" descr="Get lines of comments immediately preceding an object's source code.&#10;&#10;Returns None when source can't be found.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getdoc" func="yes">
			<Overload retVal="" descr="Get the documentation string for an object.&#10;&#10;All tabs are expanded to spaces.  To clean up docstrings that are&#10;indented to line up with blocks of code, any whitespace than can be&#10;uniformly removed from the second line onwards is removed.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getfile" func="yes">
			<Overload retVal="" descr="Work out which source or compiled file an object was defined in.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getframeinfo" func="yes">
			<Overload retVal="" descr="Get information about a frame or traceback object.&#10;&#10;A tuple of five things is returned: the filename, the line number of&#10;the current line, the function name, a list of lines of context from&#10;the source code, and the index of the current line within that list.&#10;The optional second argument specifies the number of lines of context&#10;to return, which are centered around the current line.">
				<Param name="frame" />
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getinnerframes" func="yes">
			<Overload retVal="" descr="Get a list of records for a traceback's frame and all lower frames.&#10;&#10;Each record contains a frame object, filename, line number, function&#10;name, a list of lines of context, and index within the context.">
				<Param name="tb" />
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getlineno" func="yes">
			<Overload retVal="" descr="Get the line number from a frame object, allowing for optimization.">
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmembers" func="yes">
			<Overload retVal="" descr="Return all members of an object as (name, value) pairs sorted by name.&#10;Optionally, only return members that satisfy a given predicate.">
				<Param name="object" />
				<Param name="[predicate=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmodule" func="yes">
			<Overload retVal="" descr="Return the module an object was defined in, or None if not found.">
				<Param name="object" />
				<Param name="[_filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmoduleinfo" func="yes">
			<Overload retVal="" descr="Get the module name, suffix, mode, and module type for a given file.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmodulename" func="yes">
			<Overload retVal="" descr="Return the module name for a given file, or None.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmro" func="yes">
			<Overload retVal="" descr="Return tuple of base classes (including cls) in method resolution order.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getouterframes" func="yes">
			<Overload retVal="" descr="Get a list of records for a frame and all higher (calling) frames.&#10;&#10;Each record contains a frame object, filename, line number, function&#10;name, a list of lines of context, and index within the context.">
				<Param name="frame" />
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getsource" func="yes">
			<Overload retVal="" descr="Return the text of the source code for an object.&#10;&#10;The argument may be a module, class, method, function, traceback, frame,&#10;or code object.  The source code is returned as a single string.  An&#10;IOError is raised if the source code cannot be retrieved.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getsourcefile" func="yes">
			<Overload retVal="" descr="Return the filename that can be used to locate an object's source.&#10;Return None if no way can be identified to get the source.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getsourcelines" func="yes">
			<Overload retVal="" descr="Return a list of source lines and starting line number for an object.&#10;&#10;The argument may be a module, class, method, function, traceback, frame,&#10;or code object.  The source code is returned as a list of the lines&#10;corresponding to the object and the line number indicates where in the&#10;original source file the first line of code was found.  An IOError is&#10;raised if the source code cannot be retrieved.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.indentsize" func="yes">
			<Overload retVal="" descr="Return the indent size, in spaces, at the start of a line of text.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isabstract" func="yes">
			<Overload retVal="" descr="Return true if the object is an abstract base class (ABC).">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isbuiltin" func="yes">
			<Overload retVal="" descr="Return true if the object is a built-in function or method.&#10;&#10;Built-in functions and methods provide these attributes:&#10;    __doc__         documentation string&#10;    __name__        original name of this function or method&#10;    __self__        instance to which a method is bound, or None">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isclass" func="yes">
			<Overload retVal="" descr="Return true if the object is a class.&#10;&#10;Class objects provide these attributes:&#10;    __doc__         documentation string&#10;    __module__      name of module in which this class was defined">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.iscode" func="yes">
			<Overload retVal="" descr="Return true if the object is a code object.&#10;&#10;Code objects provide these attributes:&#10;    co_argcount     number of arguments (not including * or ** args)&#10;    co_code         string of raw compiled bytecode&#10;    co_consts       tuple of constants used in the bytecode&#10;    co_filename     name of file in which this code object was created&#10;    co_firstlineno  number of first line in Python source code&#10;    co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg&#10;    co_lnotab       encoded mapping of line numbers to bytecode indices&#10;    co_name         name with which this code object was defined&#10;    co_names        tuple of names of local variables&#10;    co_nlocals      number of local variables&#10;    co_stacksize    virtual machine stack space required&#10;    co_varnames     tuple of names of arguments and local variables">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isdatadescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a data descriptor.&#10;&#10;Data descriptors have both a __get__ and a __set__ attribute.  Examples are&#10;properties (defined in Python) and getsets and members (defined in C).&#10;Typically, data descriptors will also have __name__ and __doc__ attributes&#10;(properties, getsets, and members have both of these attributes), but this&#10;is not guaranteed.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isframe" func="yes">
			<Overload retVal="" descr="Return true if the object is a frame object.&#10;&#10;Frame objects provide these attributes:&#10;    f_back          next outer frame object (this frame's caller)&#10;    f_builtins      built-in namespace seen by this frame&#10;    f_code          code object being executed in this frame&#10;    f_exc_traceback traceback if raised in this frame, or None&#10;    f_exc_type      exception type if raised in this frame, or None&#10;    f_exc_value     exception value if raised in this frame, or None&#10;    f_globals       global namespace seen by this frame&#10;    f_lasti         index of last attempted instruction in bytecode&#10;    f_lineno        current line number in Python source code&#10;    f_locals        local namespace seen by this frame&#10;    f_restricted    0 or 1 if frame is in restricted execution mode&#10;    f_trace         tracing function for this frame, or None">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isfunction" func="yes">
			<Overload retVal="" descr="Return true if the object is a user-defined function.&#10;&#10;Function objects provide these attributes:&#10;    __doc__         documentation string&#10;    __name__        name with which this function was defined&#10;    func_code       code object containing compiled function bytecode&#10;    func_defaults   tuple of any default values for arguments&#10;    func_doc        (same as __doc__)&#10;    func_globals    global namespace in which this function was defined&#10;    func_name       (same as __name__)">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isgenerator" func="yes">
			<Overload retVal="" descr='Return true if the object is a generator.&#10;&#10;Generator objects provide these attributes:&#10;    __iter__        defined to support iteration over container&#10;    close           raises a new GeneratorExit exception inside the&#10;                    generator to terminate the iteration&#10;    gi_code         code object&#10;    gi_frame        frame object or possibly None once the generator has&#10;                    been exhausted&#10;    gi_running      set to 1 when generator is executing, 0 otherwise&#10;    next            return the next item from the container&#10;    send            resumes the generator and "sends" a value that becomes&#10;                    the result of the current yield-expression&#10;    throw           used to raise an exception inside the generator'>
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isgeneratorfunction" func="yes">
			<Overload retVal="" descr="Return true if the object is a user-defined generator function.&#10;&#10;Generator function objects provides same attributes as functions.&#10;&#10;See help(isfunction) for attributes listing.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isgetsetdescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a getset descriptor.&#10;&#10;getset descriptors are specialized descriptors defined in extension&#10;modules.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismemberdescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a member descriptor.&#10;&#10;Member descriptors are specialized descriptors defined in extension&#10;modules.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismethod" func="yes">
			<Overload retVal="" descr="Return true if the object is an instance method.&#10;&#10;Instance method objects provide these attributes:&#10;    __doc__         documentation string&#10;    __name__        name with which this method was defined&#10;    im_class        class object in which this method belongs&#10;    im_func         function object containing implementation of method&#10;    im_self         instance to which this method is bound, or None">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismethoddescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a method descriptor.&#10;&#10;But not if ismethod() or isclass() or isfunction() are true.&#10;&#10;This is new in Python 2.2, and, for example, is true of int.__add__.&#10;An object passing this test has a __get__ attribute but not a __set__&#10;attribute, but beyond that the set of attributes varies.  __name__ is&#10;usually sensible, and __doc__ often is.&#10;&#10;Methods implemented via descriptors that also pass one of the other&#10;tests return false from the ismethoddescriptor() test, simply because&#10;the other tests promise more -- you can, e.g., count on having the&#10;im_func attribute (etc) when an object passes ismethod().">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismodule" func="yes">
			<Overload retVal="" descr="Return true if the object is a module.&#10;&#10;Module objects provide these attributes:&#10;    __doc__         documentation string&#10;    __file__        filename (missing for built-in modules)">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isroutine" func="yes">
			<Overload retVal="" descr="Return true if the object is any kind of function or method.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.istraceback" func="yes">
			<Overload retVal="" descr="Return true if the object is a traceback.&#10;&#10;Traceback objects provide these attributes:&#10;    tb_frame        frame object at this level&#10;    tb_lasti        index of last attempted instruction in bytecode&#10;    tb_lineno       current line number in Python source code&#10;    tb_next         next inner traceback object (called by this level)">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.joinseq" />
		<KeyWord name="inspect.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
				<Param name="typename" />
				<Param name="field_names" />
				<Param name="[verbose=False" />
				<Param name="[rename=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.stack" func="yes">
			<Overload retVal="" descr="Return a list of records for the stack above the caller's frame.">
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.strseq" func="yes">
			<Overload retVal="" descr="Recursively walk a sequence, stringifying each element.">
				<Param name="object" />
				<Param name="convert" />
				<Param name="[join=<function joinseq at 0x0000000002872898>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.trace" func="yes">
			<Overload retVal="" descr="Return a list of records for the stack below the current exception.">
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.walktree" func="yes">
			<Overload retVal="" descr="Recursive helper function for getclasstree().">
				<Param name="classes" />
				<Param name="children" />
				<Param name="parent" />
			</Overload>
		</KeyWord>
		<KeyWord name="install" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="installHandler" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="install_opener" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="instance" func="yes">
			<Overload retVal="" descr="Function of new.instance">
			</Overload>
		</KeyWord>
		<KeyWord name="instate" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="int" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="interact" func="yes">
			<Overload retVal="" descr="Function of code">
			</Overload>
		</KeyWord>
		<KeyWord name="intern" func="yes">
			<Overload retVal="" descr="intern(string) -&gt; string&#10;&#10;``Intern'' the given string.  This enters the string in the (global)&#10;table of interned strings whose purpose is to speed up dictionary lookups.&#10;Return the string itself or the previously interned string object with the&#10;same value.">
			</Overload>
		</KeyWord>
		<KeyWord name="interrupt" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="interrupt_main" func="yes">
			<Overload retVal="" descr="Function of dummy_thread">
			</Overload>
		</KeyWord>
		<KeyWord name="intersection" func="yes">
			<Overload retVal="" descr="Return the intersection of two or more sets as a new set.&#10;&#10;(i.e. elements that are common to all of the sets.)">
			</Overload>
		</KeyWord>
		<KeyWord name="intersection_update" func="yes">
			<Overload retVal="" descr="Update a set with the intersection of itself and another.">
			</Overload>
		</KeyWord>
		<KeyWord name="io" func="yes">
			<Overload retVal="" descr="The io module provides the Python interfaces to stream handling. The&#10;builtin open function is defined in this module.&#10;&#10;At the top of the I/O hierarchy is the abstract base class IOBase. It&#10;defines the basic interface to a stream. Note, however, that there is no&#10;separation between reading and writing to streams; implementations are&#10;allowed to raise an IOError if they do not support a given operation.&#10;&#10;Extending IOBase is RawIOBase which deals simply with the reading and&#10;writing of raw bytes to a stream. FileIO subclasses RawIOBase to provide&#10;an interface to OS files.&#10;&#10;BufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its&#10;subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer&#10;streams that are readable, writable, and both respectively.&#10;BufferedRandom provides a buffered interface to random access&#10;streams. BytesIO is a simple stream of in-memory bytes.&#10;&#10;Another IOBase subclass, TextIOBase, deals with the encoding and decoding&#10;of streams into text. TextIOWrapper, which extends it, is a buffered text&#10;interface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO&#10;is a in-memory stream for text.&#10;&#10;Argument names are not part of the specification, and only the arguments&#10;of open() are intended to be used as keyword arguments.&#10;&#10;data:&#10;&#10;DEFAULT_BUFFER_SIZE&#10;&#10;   An int containing the default buffer size used by the module's buffered&#10;   I/O classes. open() uses the file's blksize (as obtained by os.stat) if&#10;   possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError" func="yes">
			<Overload retVal="" descr="Exception raised when I/O would block on a non-blocking I/O stream">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.characters_written" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair" func="yes">
			<Overload retVal="" descr="A buffered reader and writer object together.&#10;&#10;A buffered reader object and buffered writer object put together to&#10;form a sequential IO object that can read and write. This is typically&#10;used with a socket or two-way pipe.&#10;&#10;reader and writer are RawIOBase objects that are readable and&#10;writeable respectively. If the buffer_size is omitted it defaults to&#10;DEFAULT_BUFFER_SIZE.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.close" />
		<KeyWord name="io.BufferedRWPair.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;An IOError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.flush" />
		<KeyWord name="io.BufferedRWPair.isatty" />
		<KeyWord name="io.BufferedRWPair.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.peek" />
		<KeyWord name="io.BufferedRWPair.read" />
		<KeyWord name="io.BufferedRWPair.read1" />
		<KeyWord name="io.BufferedRWPair.readable" />
		<KeyWord name="io.BufferedRWPair.readinto" />
		<KeyWord name="io.BufferedRWPair.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If limit is specified, at most limit bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise IOError.&#10;This method may need to do a test seek().">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.writable" />
		<KeyWord name="io.BufferedRWPair.write" />
		<KeyWord name="io.BufferedRWPair.writelines" />
		<KeyWord name="io.BufferedRandom" func="yes">
			<Overload retVal="" descr="A buffered interface to random access streams.&#10;&#10;The constructor creates a reader and writer for a seekable stream,&#10;raw, given in the first argument. If the buffer_size is omitted it&#10;defaults to DEFAULT_BUFFER_SIZE. max_buffer_size isn't used anymore.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.close" />
		<KeyWord name="io.BufferedRandom.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.detach" />
		<KeyWord name="io.BufferedRandom.fileno" />
		<KeyWord name="io.BufferedRandom.flush" />
		<KeyWord name="io.BufferedRandom.isatty" />
		<KeyWord name="io.BufferedRandom.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.peek" />
		<KeyWord name="io.BufferedRandom.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.read" />
		<KeyWord name="io.BufferedRandom.read1" />
		<KeyWord name="io.BufferedRandom.readable" />
		<KeyWord name="io.BufferedRandom.readinto" />
		<KeyWord name="io.BufferedRandom.readline" />
		<KeyWord name="io.BufferedRandom.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.seek" />
		<KeyWord name="io.BufferedRandom.seekable" />
		<KeyWord name="io.BufferedRandom.tell" />
		<KeyWord name="io.BufferedRandom.truncate" />
		<KeyWord name="io.BufferedRandom.writable" />
		<KeyWord name="io.BufferedRandom.write" />
		<KeyWord name="io.BufferedRandom.writelines" />
		<KeyWord name="io.BufferedReader" func="yes">
			<Overload retVal="" descr="Create a new buffered reader using the given readable raw IO object.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.close" />
		<KeyWord name="io.BufferedReader.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.detach" />
		<KeyWord name="io.BufferedReader.fileno" />
		<KeyWord name="io.BufferedReader.flush" />
		<KeyWord name="io.BufferedReader.isatty" />
		<KeyWord name="io.BufferedReader.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.peek" />
		<KeyWord name="io.BufferedReader.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.read" />
		<KeyWord name="io.BufferedReader.read1" />
		<KeyWord name="io.BufferedReader.readable" />
		<KeyWord name="io.BufferedReader.readinto" />
		<KeyWord name="io.BufferedReader.readline" />
		<KeyWord name="io.BufferedReader.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.seek" />
		<KeyWord name="io.BufferedReader.seekable" />
		<KeyWord name="io.BufferedReader.tell" />
		<KeyWord name="io.BufferedReader.truncate" />
		<KeyWord name="io.BufferedReader.writable" />
		<KeyWord name="io.BufferedReader.write" func="yes">
			<Overload retVal="" descr="Write the given buffer to the IO stream.&#10;&#10;Returns the number of bytes written, which is never less than&#10;len(b).&#10;&#10;Raises BlockingIOError if the buffer is full and the&#10;underlying raw stream cannot accept more data at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.writelines" />
		<KeyWord name="io.BufferedWriter" func="yes">
			<Overload retVal="" descr="A buffer for a writeable sequential RawIO object.&#10;&#10;The constructor creates a BufferedWriter for the given writeable raw&#10;stream. If the buffer_size is not given, it defaults to&#10;DEFAULT_BUFFER_SIZE. max_buffer_size isn't used anymore.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.close" />
		<KeyWord name="io.BufferedWriter.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.detach" />
		<KeyWord name="io.BufferedWriter.fileno" />
		<KeyWord name="io.BufferedWriter.flush" />
		<KeyWord name="io.BufferedWriter.isatty" />
		<KeyWord name="io.BufferedWriter.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.read" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes.&#10;&#10;If the argument is omitted, None, or negative, reads and&#10;returns all data until EOF.&#10;&#10;If the argument is positive, and the underlying raw stream is&#10;not 'interactive', multiple raw reads may be issued to satisfy&#10;the byte count (unless EOF is reached first).  But for&#10;interactive raw streams (as well as sockets and pipes), at most&#10;one raw read will be issued, and a short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.&#10;&#10;Returns None if the underlying raw stream was open in non-blocking&#10;mode and no data is available at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.read1" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes, with at most one read() call&#10;to the underlying raw stream. A short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.readable" />
		<KeyWord name="io.BufferedWriter.readinto" />
		<KeyWord name="io.BufferedWriter.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If limit is specified, at most limit bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.seek" />
		<KeyWord name="io.BufferedWriter.seekable" />
		<KeyWord name="io.BufferedWriter.tell" />
		<KeyWord name="io.BufferedWriter.truncate" />
		<KeyWord name="io.BufferedWriter.writable" />
		<KeyWord name="io.BufferedWriter.write" />
		<KeyWord name="io.BufferedWriter.writelines" />
		<KeyWord name="io.BytesIO" func="yes">
			<Overload retVal="" descr="BytesIO([buffer]) -&gt; object&#10;&#10;Create a buffered I/O implementation using an in-memory bytes&#10;buffer, ready for reading and writing.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None.  Disable all I/O operations.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;An IOError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Does nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.getvalue" func="yes">
			<Overload retVal="" descr="getvalue() -&gt; bytes.&#10;&#10;Retrieve the entire contents of the BytesIO object.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; False.&#10;&#10;Always returns False since BytesIO objects are not connected&#10;to a tty-like device.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative, read until EOF is reached.&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.read1" func="yes">
			<Overload retVal="" descr="read1(size) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readable" func="yes">
			<Overload retVal="" descr="readable() -&gt; bool. Returns True if the IO object can be read.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readinto" func="yes">
			<Overload retVal="" descr="readinto(bytearray) -&gt; int.  Read up to len(b) bytes into b.&#10;&#10;Returns number of bytes read (0 for EOF), or None if the object&#10;is set not to block as has no data to read.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.seek" func="yes">
			<Overload retVal="" descr="seek(pos, whence=0) -&gt; int.  Change stream position.&#10;&#10;Seek to byte offset pos relative to position indicated by whence:&#10;     0  Start of stream (the default).  pos should be &gt;= 0;&#10;     1  Current position - pos may be negative;&#10;     2  End of stream - pos usually negative.&#10;Returns the new absolute position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.seekable" func="yes">
			<Overload retVal="" descr="seekable() -&gt; bool. Returns True if the IO object can be seeked.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; int.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is unchanged.  Returns the new size.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.writable" func="yes">
			<Overload retVal="" descr="writable() -&gt; bool. Returns True if the IO object can be written.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.write" func="yes">
			<Overload retVal="" descr="write(bytes) -&gt; int.  Write bytes to file.&#10;&#10;Return the number of bytes written.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable&#10;object producing strings. This is equivalent to calling write() for&#10;each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.DEFAULT_BUFFER_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO" func="yes">
			<Overload retVal="" descr="file(name: str[, mode: str]) -&gt; file IO object&#10;&#10;Open a file.  The mode can be 'r' (default), 'w' or 'a' for reading,&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a '+' to the mode to allow simultaneous&#10;reading and writing.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None.  Close the file.&#10;&#10;A closed file cannot be used for further I/O operations.  close() may be&#10;called more than once without error.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.closefd" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; int.  Return the underlying file descriptor (an integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; bool.  True if the file is connected to a TTY device.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.read" func="yes">
			<Overload retVal="" descr="read(size: int) -&gt; bytes.  read at most size bytes, returned as bytes.&#10;&#10;Only makes one system call, so less data may be returned than requested&#10;In non-blocking mode, returns None if no data is available.&#10;On end-of-file, returns ''.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readable" func="yes">
			<Overload retVal="" descr="readable() -&gt; bool.  True if file was opened in a read mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readall" func="yes">
			<Overload retVal="" descr="readall() -&gt; bytes.  read all data from the file, returned as bytes.&#10;&#10;In non-blocking mode, returns as much as is immediately available,&#10;or None if no data is available.  On end-of-file, returns ''.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Same as RawIOBase.readinto().">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If limit is specified, at most limit bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.seek" func="yes">
			<Overload retVal="" descr="seek(offset: int[, whence: int]) -&gt; int.  Move to new file position&#10;and return the file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;SEEK_SET or 0 (offset from start of file, offset should be &gt;= 0); other values&#10;are SEEK_CUR or 1 (move relative to current position, positive or negative),&#10;and SEEK_END or 2 (move relative to end of file, usually negative, although&#10;many platforms allow seeking beyond the end of a file).&#10;&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.seekable" func="yes">
			<Overload retVal="" descr="seekable() -&gt; bool.  True if file supports random-access.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; int.  Current file position.&#10;&#10;Can raise OSError for non seekable files.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.truncate" func="yes">
			<Overload retVal="" descr="truncate([size: int]) -&gt; int.  Truncate the file to at most size bytes and&#10;return the truncated size.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is changed to the value of size.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.writable" func="yes">
			<Overload retVal="" descr="writable() -&gt; bool.  True if file was opened in a write mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.write" func="yes">
			<Overload retVal="" descr="write(b: bytes) -&gt; int.  Write bytes b to file, return number written.&#10;&#10;Only makes one system call, so not all of the data may be written.&#10;The number of bytes actually written is returned.  In non-blocking mode,&#10;returns None if the write would block.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.writelines" />
		<KeyWord name="io.IOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder" func="yes">
			<Overload retVal="" descr="Codec used when reading a file in universal newlines mode.  It wraps&#10;another incremental decoder, translating \r\n and \r into \n.  It also&#10;records the types of newlines encountered.  When used with&#10;translate=False, it ensures that the newline sequence is returned in&#10;one piece. When used with decoder=None, it expects unicode strings as&#10;decode input and translates newlines without first invoking an external&#10;decoder.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder.decode" />
		<KeyWord name="io.IncrementalNewlineDecoder.getstate" />
		<KeyWord name="io.IncrementalNewlineDecoder.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder.reset" />
		<KeyWord name="io.IncrementalNewlineDecoder.setstate" />
		<KeyWord name="io.OpenWrapper" func="yes">
			<Overload retVal="" descr="Open file and return a stream.  Raise IOError upon failure.&#10;&#10;file is either a text or byte string giving the name (and the path&#10;if the file isn't in the current working directory) of the file to&#10;be opened or an integer file descriptor of the file to be&#10;wrapped. (If a file descriptor is given, it is closed when the&#10;returned I/O object is closed, unless closefd is set to False.)&#10;&#10;mode is an optional string that specifies the mode in which the file&#10;is opened. It defaults to 'r' which means open for reading in text&#10;mode.  Other common values are 'w' for writing (truncating the file if&#10;it already exists), and 'a' for appending (which on some Unix systems,&#10;means that all writes append to the end of the file regardless of the&#10;current seek position). In text mode, if encoding is not specified the&#10;encoding used is platform dependent. (For reading and writing raw&#10;bytes use binary mode and leave encoding unspecified.) The available&#10;modes are:&#10;&#10;========= ===============================================================&#10;Character Meaning&#10;--------- ---------------------------------------------------------------&#10;'r'       open for reading (default)&#10;'w'       open for writing, truncating the file first&#10;'a'       open for writing, appending to the end of the file if it exists&#10;'b'       binary mode&#10;'t'       text mode (default)&#10;'+'       open a disk file for updating (reading and writing)&#10;'U'       universal newline mode (for backwards compatibility; unneeded&#10;          for new code)&#10;========= ===============================================================&#10;&#10;The default mode is 'rt' (open for reading text). For binary random&#10;access, the mode 'w+b' opens and truncates the file to 0 bytes, while&#10;'r+b' opens the file without truncation.&#10;&#10;Python distinguishes between files opened in binary and text modes,&#10;even when the underlying operating system doesn't. Files opened in&#10;binary mode (appending 'b' to the mode argument) return contents as&#10;bytes objects without any decoding. In text mode (the default, or when&#10;'t' is appended to the mode argument), the contents of the file are&#10;returned as strings, the bytes having been first decoded using a&#10;platform-dependent encoding or using the specified encoding if given.&#10;&#10;buffering is an optional integer used to set the buffering policy.&#10;Pass 0 to switch buffering off (only allowed in binary mode), 1 to select&#10;line buffering (only usable in text mode), and an integer &gt; 1 to indicate&#10;the size of a fixed-size chunk buffer.  When no buffering argument is&#10;given, the default buffering policy works as follows:&#10;&#10;* Binary files are buffered in fixed-size chunks; the size of the buffer&#10;  is chosen using a heuristic trying to determine the underlying device's&#10;  &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.&#10;  On many systems, the buffer will typically be 4096 or 8192 bytes long.&#10;&#10;* &quot;Interactive&quot; text files (files for which isatty() returns True)&#10;  use line buffering.  Other text files use the policy described above&#10;  for binary files.&#10;&#10;encoding is the name of the encoding used to decode or encode the&#10;file. This should only be used in text mode. The default encoding is&#10;platform dependent, but any encoding supported by Python can be&#10;passed.  See the codecs module for the list of supported encodings.&#10;&#10;errors is an optional string that specifies how encoding errors are to&#10;be handled---this argument should not be used in binary mode. Pass&#10;'strict' to raise a ValueError exception if there is an encoding error&#10;(the default of None has the same effect), or pass 'ignore' to ignore&#10;errors. (Note that ignoring encoding errors can lead to data loss.)&#10;See the documentation for codecs.register for a list of the permitted&#10;encoding error strings.&#10;&#10;newline controls how universal newlines works (it only applies to text&#10;mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as&#10;follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '', no translation takes place. If newline is any of the&#10;  other legal values, any '\n' characters written are translated to&#10;  the given string.&#10;&#10;If closefd is False, the underlying file descriptor will be kept open&#10;when the file is closed. This does not work when a file name is given&#10;and must be True in that case.&#10;&#10;open() returns a file object whose type depends on the mode, and&#10;through which the standard file operations such as reading and writing&#10;are performed. When open() is used to open a file in a text mode ('w',&#10;'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open&#10;a file in a binary mode, the returned class varies: in read binary&#10;mode, it returns a BufferedReader; in write binary and append binary&#10;modes, it returns a BufferedWriter, and in read/write mode, it returns&#10;a BufferedRandom.&#10;&#10;It is also possible to use a string or bytearray as a file for both&#10;reading and writing. For strings StringIO can be used like a file&#10;opened in a text mode, and for bytes a BytesIO can be used like a file&#10;opened in a binary mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.RawIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.SEEK_CUR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.SEEK_END" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO" func="yes">
			<Overload retVal="" descr="Text I/O implementation using an in-memory buffer.&#10;&#10;The initial_value argument sets the value of object.  The newline&#10;argument is like the one of TextIOWrapper's constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.close" func="yes">
			<Overload retVal="" descr="Close the IO object. Attempting any further operation after the&#10;object is closed will raise a ValueError.&#10;&#10;This method has no effect if the file is already closed.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.encoding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;An IOError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the object.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.line_buffering" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.read" func="yes">
			<Overload retVal="" descr="Read at most n characters, returned as a string.&#10;&#10;If the argument is negative or omitted, read until EOF&#10;is reached. Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.readable" func="yes">
			<Overload retVal="" descr="readable() -&gt; bool. Returns True if the IO object can be read.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to character offset pos relative to position indicated by whence:&#10;    0  Start of stream (the default).  pos should be &gt;= 0;&#10;    1  Current position - pos must be 0;&#10;    2  End of stream - pos must be 0.&#10;Returns the new absolute position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.seekable" func="yes">
			<Overload retVal="" descr="seekable() -&gt; bool. Returns True if the IO object can be seeked.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.tell" func="yes">
			<Overload retVal="" descr="Tell the current file position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate size to pos.&#10;&#10;The pos argument defaults to the current file position, as&#10;returned by tell().  The current file position is unchanged.&#10;Returns the new absolute position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.writable" func="yes">
			<Overload retVal="" descr="writable() -&gt; bool. Returns True if the IO object can be written.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.write" func="yes">
			<Overload retVal="" descr="Write string to file.&#10;&#10;Returns the number of characters written, which is always equal to&#10;the length of the string.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.writelines" />
		<KeyWord name="io.TextIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper" func="yes">
			<Overload retVal="" descr="Character and line based layer over a BufferedIOBase object, buffer.&#10;&#10;encoding gives the name of the encoding that the stream will be&#10;decoded or encoded with. It defaults to locale.getpreferredencoding.&#10;&#10;errors determines the strictness of encoding and decoding (see the&#10;codecs.register) and defaults to &quot;strict&quot;.&#10;&#10;newline controls how line endings are handled. It can be None, '',&#10;'\n', '\r', and '\r\n'.  It works as follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '', no translation takes place. If newline is any of the&#10;  other legal values, any '\n' characters written are translated to&#10;  the given string.&#10;&#10;If line_buffering is True, a call to flush is implied when a call to&#10;write contains a newline character.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.buffer" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.close" />
		<KeyWord name="io.TextIOWrapper.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.detach" />
		<KeyWord name="io.TextIOWrapper.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.fileno" />
		<KeyWord name="io.TextIOWrapper.flush" />
		<KeyWord name="io.TextIOWrapper.isatty" />
		<KeyWord name="io.TextIOWrapper.line_buffering" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.read" />
		<KeyWord name="io.TextIOWrapper.readable" />
		<KeyWord name="io.TextIOWrapper.readline" />
		<KeyWord name="io.TextIOWrapper.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.seek" />
		<KeyWord name="io.TextIOWrapper.seekable" />
		<KeyWord name="io.TextIOWrapper.tell" />
		<KeyWord name="io.TextIOWrapper.truncate" />
		<KeyWord name="io.TextIOWrapper.writable" />
		<KeyWord name="io.TextIOWrapper.write" />
		<KeyWord name="io.TextIOWrapper.writelines" />
		<KeyWord name="io.UnsupportedOperation" />
		<KeyWord name="io.UnsupportedOperation.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.open" func="yes">
			<Overload retVal="" descr="Open file and return a stream.  Raise IOError upon failure.&#10;&#10;file is either a text or byte string giving the name (and the path&#10;if the file isn't in the current working directory) of the file to&#10;be opened or an integer file descriptor of the file to be&#10;wrapped. (If a file descriptor is given, it is closed when the&#10;returned I/O object is closed, unless closefd is set to False.)&#10;&#10;mode is an optional string that specifies the mode in which the file&#10;is opened. It defaults to 'r' which means open for reading in text&#10;mode.  Other common values are 'w' for writing (truncating the file if&#10;it already exists), and 'a' for appending (which on some Unix systems,&#10;means that all writes append to the end of the file regardless of the&#10;current seek position). In text mode, if encoding is not specified the&#10;encoding used is platform dependent. (For reading and writing raw&#10;bytes use binary mode and leave encoding unspecified.) The available&#10;modes are:&#10;&#10;========= ===============================================================&#10;Character Meaning&#10;--------- ---------------------------------------------------------------&#10;'r'       open for reading (default)&#10;'w'       open for writing, truncating the file first&#10;'a'       open for writing, appending to the end of the file if it exists&#10;'b'       binary mode&#10;'t'       text mode (default)&#10;'+'       open a disk file for updating (reading and writing)&#10;'U'       universal newline mode (for backwards compatibility; unneeded&#10;          for new code)&#10;========= ===============================================================&#10;&#10;The default mode is 'rt' (open for reading text). For binary random&#10;access, the mode 'w+b' opens and truncates the file to 0 bytes, while&#10;'r+b' opens the file without truncation.&#10;&#10;Python distinguishes between files opened in binary and text modes,&#10;even when the underlying operating system doesn't. Files opened in&#10;binary mode (appending 'b' to the mode argument) return contents as&#10;bytes objects without any decoding. In text mode (the default, or when&#10;'t' is appended to the mode argument), the contents of the file are&#10;returned as strings, the bytes having been first decoded using a&#10;platform-dependent encoding or using the specified encoding if given.&#10;&#10;buffering is an optional integer used to set the buffering policy.&#10;Pass 0 to switch buffering off (only allowed in binary mode), 1 to select&#10;line buffering (only usable in text mode), and an integer &gt; 1 to indicate&#10;the size of a fixed-size chunk buffer.  When no buffering argument is&#10;given, the default buffering policy works as follows:&#10;&#10;* Binary files are buffered in fixed-size chunks; the size of the buffer&#10;  is chosen using a heuristic trying to determine the underlying device's&#10;  &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.&#10;  On many systems, the buffer will typically be 4096 or 8192 bytes long.&#10;&#10;* &quot;Interactive&quot; text files (files for which isatty() returns True)&#10;  use line buffering.  Other text files use the policy described above&#10;  for binary files.&#10;&#10;encoding is the name of the encoding used to decode or encode the&#10;file. This should only be used in text mode. The default encoding is&#10;platform dependent, but any encoding supported by Python can be&#10;passed.  See the codecs module for the list of supported encodings.&#10;&#10;errors is an optional string that specifies how encoding errors are to&#10;be handled---this argument should not be used in binary mode. Pass&#10;'strict' to raise a ValueError exception if there is an encoding error&#10;(the default of None has the same effect), or pass 'ignore' to ignore&#10;errors. (Note that ignoring encoding errors can lead to data loss.)&#10;See the documentation for codecs.register for a list of the permitted&#10;encoding error strings.&#10;&#10;newline controls how universal newlines works (it only applies to text&#10;mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as&#10;follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '', no translation takes place. If newline is any of the&#10;  other legal values, any '\n' characters written are translated to&#10;  the given string.&#10;&#10;If closefd is False, the underlying file descriptor will be kept open&#10;when the file is closed. This does not work when a file name is given&#10;and must be True in that case.&#10;&#10;open() returns a file object whose type depends on the mode, and&#10;through which the standard file operations such as reading and writing&#10;are performed. When open() is used to open a file in a text mode ('w',&#10;'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open&#10;a file in a binary mode, the returned class varies: in read binary&#10;mode, it returns a BufferedReader; in write binary and append binary&#10;modes, it returns a BufferedWriter, and in read/write mode, it returns&#10;a BufferedRandom.&#10;&#10;It is also possible to use a string or bytearray as a file for both&#10;reading and writing. For strings StringIO can be used like a file&#10;opened in a text mode, and for bytes a BytesIO can be used like a file&#10;opened in a binary mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="ioctl" func="yes">
			<Overload retVal="" descr="Function of socket.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="is" />
		<KeyWord name="isAlive" func="yes">
			<Overload retVal="" descr="Function of threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="isDaemon" func="yes">
			<Overload retVal="" descr="Function of threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="isEnabledFor" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="isReservedKey" func="yes">
			<Overload retVal="" descr="Function of Cookie.Morsel">
			</Overload>
		</KeyWord>
		<KeyWord name="is_HDN" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="is_alive" func="yes">
			<Overload retVal="" descr="Function of threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="is_assigned" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_canonical" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_declared_global" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_finite" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_free" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_global" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_imported" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_infinite" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="is_local" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_namespace" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_nan" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_nested" func="yes">
			<Overload retVal="" descr="Function of symtable.SymbolTable">
			</Overload>
		</KeyWord>
		<KeyWord name="is_normal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_optimized" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="is_package" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
		<KeyWord name="is_parameter" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_python_build" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="is_qnan" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_referenced" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_signed" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_snan" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_subnormal" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="is_tarfile" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="is_third_party" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="is_zero" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_zipfile" func="yes">
			<Overload retVal="" descr="Function of zipfile">
			</Overload>
		</KeyWord>
		<KeyWord name="isabs" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isabstract" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isalnum" func="yes">
			<Overload retVal="" descr="B.isalnum() -&gt; bool&#10;&#10;Return True if all characters in B are alphanumeric&#10;and there is at least one character in B, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="isbasestring" func="yes">
			<Overload retVal="" descr="Function of optparse">
			</Overload>
		</KeyWord>
		<KeyWord name="isblk" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isbuiltin" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ischr" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isclass" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="iscode" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isdata" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="isdatadescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isdev" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isdir" func="yes">
			<Overload retVal="" descr="Function of os2emxpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isdisjoint" func="yes">
			<Overload retVal="" descr="Return True if two sets have a null intersection.">
			</Overload>
		</KeyWord>
		<KeyWord name="isdown" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="isfifo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isfile" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isfirstline" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="isframe" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isfunction" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isgenerator" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isgeneratorfunction" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isgetsetdescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ishex" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="isident" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="isinf" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="isinstance" func="yes">
			<Overload retVal="" descr="isinstance(object, class-or-type-or-tuple) -&gt; bool&#10;&#10;Return whether an object is an instance of a class or of a subclass thereof.&#10;With a type as second argument, return whether that is the object's type.&#10;The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for&#10;isinstance(x, A) or isinstance(x, B) or ... (etc.).">
			</Overload>
		</KeyWord>
		<KeyWord name="iskeyword" func="yes">
			<Overload retVal="" descr="Function of keyword">
			</Overload>
		</KeyWord>
		<KeyWord name="isleap" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="islice" func="yes">
			<Overload retVal="" descr="Function of heapq.islice">
			</Overload>
		</KeyWord>
		<KeyWord name="islink" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="islnk" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="ismemberdescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismethod" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismethoddescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismodule" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismount" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isname" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="isnan" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="iso2time" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="isocalendar" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="isoformat" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="isoweekday" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="ispackage" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="ispath" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="isreadable" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="isrecursive" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="isreg" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isroutine" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="issparse" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isstdin" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="isstring" func="yes">
			<Overload retVal="" descr="Function of sre_compile">
			</Overload>
		</KeyWord>
		<KeyWord name="issubclass" func="yes">
			<Overload retVal="" descr="issubclass(C, B) -&gt; bool&#10;&#10;Return whether class C is a subclass (i.e., a derived class) of class B.&#10;When using a tuple as the second argument issubclass(X, (A, B, ...)),&#10;is a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.).">
			</Overload>
		</KeyWord>
		<KeyWord name="issubset" func="yes">
			<Overload retVal="" descr="Report whether another set contains this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="issuperset" func="yes">
			<Overload retVal="" descr="Report whether this set contains another set.">
			</Overload>
		</KeyWord>
		<KeyWord name="issym" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="istraceback" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isvisible" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="iter" func="yes">
			<Overload retVal="" descr="iter(collection) -&gt; iterator&#10;iter(callable, sentinel) -&gt; iterator&#10;&#10;Get an iterator from an object.  In the first form, the argument must&#10;supply its own iterator, or be a sequence.&#10;In the second form, the callable is called until it returns the sentinel.">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_child_nodes" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_fields" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_importer_modules" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_importers" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_modules" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_zipimport_modules" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iterdecode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="iterdump" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="iterencode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="itermonthdates" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itermonthdays" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itermonthdays2" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="iterweekdays" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itn" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="izip" func="yes">
			<Overload retVal="" descr="Function of filecmp.izip">
			</Overload>
		</KeyWord>
		<KeyWord name="java_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="join_header_words" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="joinfields" func="yes">
			<Overload retVal="" descr="Function of string">
			</Overload>
		</KeyWord>
		<KeyWord name="joinseq" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="js_output" func="yes">
			<Overload retVal="" descr="Function of Cookie.BaseCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="json" func="yes">
			<Overload retVal="" descr="JSON (JavaScript Object Notation) &lt;http://json.org&gt; is a subset of&#10;JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data&#10;interchange format.&#10;&#10;:mod:`json` exposes an API familiar to users of the standard library&#10;:mod:`marshal` and :mod:`pickle` modules. It is the externally maintained&#10;version of the :mod:`json` library contained in Python 2.6, but maintains&#10;compatibility with Python 2.4 and Python 2.5 and (currently) has&#10;significant performance advantages, even without using the optional C&#10;extension for speedups.&#10;&#10;Encoding basic Python object hierarchies::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])&#10;    '[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]'&#10;    &gt;&gt;&gt; print json.dumps(&quot;\&quot;foo\bar&quot;)&#10;    &quot;\&quot;foo\bar&quot;&#10;    &gt;&gt;&gt; print json.dumps(u'\u1234')&#10;    &quot;\u1234&quot;&#10;    &gt;&gt;&gt; print json.dumps('\\')&#10;    &quot;\\&quot;&#10;    &gt;&gt;&gt; print json.dumps({&quot;c&quot;: 0, &quot;b&quot;: 0, &quot;a&quot;: 0}, sort_keys=True)&#10;    {&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0}&#10;    &gt;&gt;&gt; from StringIO import StringIO&#10;    &gt;&gt;&gt; io = StringIO()&#10;    &gt;&gt;&gt; json.dump(['streaming API'], io)&#10;    &gt;&gt;&gt; io.getvalue()&#10;    '[&quot;streaming API&quot;]'&#10;&#10;Compact encoding::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; json.dumps([1,2,3,{'4': 5, '6': 7}], sort_keys=True, separators=(',',':'))&#10;    '[1,2,3,{&quot;4&quot;:5,&quot;6&quot;:7}]'&#10;&#10;Pretty printing::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; print json.dumps({'4': 5, '6': 7}, sort_keys=True,&#10;    ...                  indent=4, separators=(',', ': '))&#10;    {&#10;        &quot;4&quot;: 5,&#10;        &quot;6&quot;: 7&#10;    }&#10;&#10;Decoding JSON::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; obj = [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]&#10;    &gt;&gt;&gt; json.loads('[&quot;foo&quot;, {&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]}]') == obj&#10;    True&#10;    &gt;&gt;&gt; json.loads('&quot;\\&quot;foo\\bar&quot;') == u'&quot;foo\x08ar'&#10;    True&#10;    &gt;&gt;&gt; from StringIO import StringIO&#10;    &gt;&gt;&gt; io = StringIO('[&quot;streaming API&quot;]')&#10;    &gt;&gt;&gt; json.load(io)[0] == 'streaming API'&#10;    True&#10;&#10;Specializing JSON object decoding::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; def as_complex(dct):&#10;    ...     if '__complex__' in dct:&#10;    ...         return complex(dct['real'], dct['imag'])&#10;    ...     return dct&#10;    ...&#10;    &gt;&gt;&gt; json.loads('{&quot;__complex__&quot;: true, &quot;real&quot;: 1, &quot;imag&quot;: 2}',&#10;    ...     object_hook=as_complex)&#10;    (1+2j)&#10;    &gt;&gt;&gt; from decimal import Decimal&#10;    &gt;&gt;&gt; json.loads('1.1', parse_float=Decimal) == Decimal('1.1')&#10;    True&#10;&#10;Specializing JSON object encoding::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; def encode_complex(obj):&#10;    ...     if isinstance(obj, complex):&#10;    ...         return [obj.real, obj.imag]&#10;    ...     raise TypeError(repr(o) + &quot; is not JSON serializable&quot;)&#10;    ...&#10;    &gt;&gt;&gt; json.dumps(2 + 1j, default=encode_complex)&#10;    '[2.0, 1.0]'&#10;    &gt;&gt;&gt; json.JSONEncoder(default=encode_complex).encode(2 + 1j)&#10;    '[2.0, 1.0]'&#10;    &gt;&gt;&gt; ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))&#10;    '[2.0, 1.0]'&#10;&#10;&#10;Using json.tool from the shell to validate and pretty-print::&#10;&#10;    $ echo '{&quot;json&quot;:&quot;obj&quot;}' | python -m json.tool&#10;    {&#10;        &quot;json&quot;: &quot;obj&quot;&#10;    }&#10;    $ echo '{ 1.2:3.4}' | python -m json.tool&#10;    Expecting property name enclosed in double quotes: line 1 column 3 (char 2)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecoder" func="yes">
			<Overload retVal="" descr="Simple JSON &lt;http://json.org&gt; decoder&#10;&#10;Performs the following translations in decoding by default:&#10;&#10;+---------------+-------------------+&#10;| JSON          | Python            |&#10;+===============+===================+&#10;| object        | dict              |&#10;+---------------+-------------------+&#10;| array         | list              |&#10;+---------------+-------------------+&#10;| string        | unicode           |&#10;+---------------+-------------------+&#10;| number (int)  | int, long         |&#10;+---------------+-------------------+&#10;| number (real) | float             |&#10;+---------------+-------------------+&#10;| true          | True              |&#10;+---------------+-------------------+&#10;| false         | False             |&#10;+---------------+-------------------+&#10;| null          | None              |&#10;+---------------+-------------------+&#10;&#10;It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as&#10;their corresponding ``float`` values, which is outside the JSON spec.">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecoder.decode" func="yes">
			<Overload retVal="" descr="Return the Python representation of ``s`` (a ``str`` or ``unicode``&#10;instance containing a JSON document)">
				<Param name="self" />
				<Param name="s" />
				<Param name="[_w=<built-in method match of _sre.SRE_Pattern object at 0x0000000003A398F0>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecoder.raw_decode" func="yes">
			<Overload retVal="" descr="Decode a JSON document from ``s`` (a ``str`` or ``unicode``&#10;beginning with a JSON document) and return a 2-tuple of the Python&#10;representation and the index in ``s`` where the document ended.&#10;&#10;This can be used to decode a JSON document from a string that may&#10;have extraneous data at the end.">
				<Param name="self" />
				<Param name="s" />
				<Param name="[idx=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder" func="yes">
			<Overload retVal="" descr="Extensible JSON &lt;http://json.org&gt; encoder for Python data structures.&#10;&#10;Supports the following objects and types by default:&#10;&#10;+-------------------+---------------+&#10;| Python            | JSON          |&#10;+===================+===============+&#10;| dict              | object        |&#10;+-------------------+---------------+&#10;| list, tuple       | array         |&#10;+-------------------+---------------+&#10;| str, unicode      | string        |&#10;+-------------------+---------------+&#10;| int, long, float  | number        |&#10;+-------------------+---------------+&#10;| True              | true          |&#10;+-------------------+---------------+&#10;| False             | false         |&#10;+-------------------+---------------+&#10;| None              | null          |&#10;+-------------------+---------------+&#10;&#10;To extend this to recognize other objects, subclass and implement a&#10;``.default()`` method with another method that returns a serializable&#10;object for ``o`` if possible, otherwise it should call the superclass&#10;implementation (to raise ``TypeError``).">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.default" func="yes">
			<Overload retVal="" descr="Implement this method in a subclass such that it returns&#10;a serializable object for ``o``, or calls the base implementation&#10;(to raise a ``TypeError``).&#10;&#10;For example, to support arbitrary iterators, you could&#10;implement default like this::&#10;&#10;    def default(self, o):&#10;        try:&#10;            iterable = iter(o)&#10;        except TypeError:&#10;            pass&#10;        else:&#10;            return list(iterable)&#10;        # Let the base class default method raise the TypeError&#10;        return JSONEncoder.default(self, o)">
				<Param name="self" />
				<Param name="o" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.encode" func="yes">
			<Overload retVal="" descr="Return a JSON string representation of a Python data structure.&#10;&#10;&gt;&gt;&gt; JSONEncoder().encode({&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]})&#10;'{&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]}'">
				<Param name="self" />
				<Param name="o" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.item_separator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.iterencode" func="yes">
			<Overload retVal="" descr="Encode the given object and yield each string&#10;representation as available.&#10;&#10;For example::&#10;&#10;    for chunk in JSONEncoder().iterencode(bigobject):&#10;        mysocket.write(chunk)">
				<Param name="self" />
				<Param name="o" />
				<Param name="[_one_shot=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.key_separator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.dump" func="yes">
			<Overload retVal="" descr="Serialize ``obj`` as a JSON formatted stream to ``fp`` (a&#10;``.write()``-supporting file-like object).&#10;&#10;If ``skipkeys`` is true then ``dict`` keys that are not basic types&#10;(``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)&#10;will be skipped instead of raising a ``TypeError``.&#10;&#10;If ``ensure_ascii`` is true (the default), all non-ASCII characters in the&#10;output are escaped with ``\uXXXX`` sequences, and the result is a ``str``&#10;instance consisting of ASCII characters only.  If ``ensure_ascii`` is&#10;``False``, some chunks written to ``fp`` may be ``unicode`` instances.&#10;This usually happens because the input contains unicode strings or the&#10;``encoding`` parameter is used. Unless ``fp.write()`` explicitly&#10;understands ``unicode`` (as in ``codecs.getwriter``) this is likely to&#10;cause an error.&#10;&#10;If ``check_circular`` is false, then the circular reference check&#10;for container types will be skipped and a circular reference will&#10;result in an ``OverflowError`` (or worse).&#10;&#10;If ``allow_nan`` is false, then it will be a ``ValueError`` to&#10;serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)&#10;in strict compliance of the JSON specification, instead of using the&#10;JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).&#10;&#10;If ``indent`` is a non-negative integer, then JSON array elements and&#10;object members will be pretty-printed with that indent level. An indent&#10;level of 0 will only insert newlines. ``None`` is the most compact&#10;representation.  Since the default item separator is ``', '``,  the&#10;output might include trailing whitespace when ``indent`` is specified.&#10;You can use ``separators=(',', ': ')`` to avoid this.&#10;&#10;If ``separators`` is an ``(item_separator, dict_separator)`` tuple&#10;then it will be used instead of the default ``(', ', ': ')`` separators.&#10;``(',', ':')`` is the most compact JSON representation.&#10;&#10;``encoding`` is the character encoding for str instances, default is UTF-8.&#10;&#10;``default(obj)`` is a function that should return a serializable version&#10;of obj or raise TypeError. The default simply raises TypeError.&#10;&#10;If *sort_keys* is ``True`` (default: ``False``), then the output of&#10;dictionaries will be sorted by key.&#10;&#10;To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the&#10;``.default()`` method to serialize additional types), specify it with&#10;the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.">
				<Param name="obj" />
				<Param name="fp" />
				<Param name="[skipkeys=False" />
				<Param name="[ensure_ascii=True" />
				<Param name="[check_circular=True" />
				<Param name="[allow_nan=True" />
				<Param name="[cls=None" />
				<Param name="[indent=None" />
				<Param name="[separators=None" />
				<Param name="[encoding=utf-8" />
				<Param name="[default=None" />
				<Param name="[sort_keys=False" />
				<Param name="[**]]]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.dumps" func="yes">
			<Overload retVal="" descr="Serialize ``obj`` to a JSON formatted ``str``.&#10;&#10;If ``skipkeys`` is false then ``dict`` keys that are not basic types&#10;(``str``, ``unicode``, ``int``, ``long``, ``float``, ``bool``, ``None``)&#10;will be skipped instead of raising a ``TypeError``.&#10;&#10;If ``ensure_ascii`` is false, all non-ASCII characters are not escaped, and&#10;the return value may be a ``unicode`` instance. See ``dump`` for details.&#10;&#10;If ``check_circular`` is false, then the circular reference check&#10;for container types will be skipped and a circular reference will&#10;result in an ``OverflowError`` (or worse).&#10;&#10;If ``allow_nan`` is false, then it will be a ``ValueError`` to&#10;serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in&#10;strict compliance of the JSON specification, instead of using the&#10;JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).&#10;&#10;If ``indent`` is a non-negative integer, then JSON array elements and&#10;object members will be pretty-printed with that indent level. An indent&#10;level of 0 will only insert newlines. ``None`` is the most compact&#10;representation.  Since the default item separator is ``', '``,  the&#10;output might include trailing whitespace when ``indent`` is specified.&#10;You can use ``separators=(',', ': ')`` to avoid this.&#10;&#10;If ``separators`` is an ``(item_separator, dict_separator)`` tuple&#10;then it will be used instead of the default ``(', ', ': ')`` separators.&#10;``(',', ':')`` is the most compact JSON representation.&#10;&#10;``encoding`` is the character encoding for str instances, default is UTF-8.&#10;&#10;``default(obj)`` is a function that should return a serializable version&#10;of obj or raise TypeError. The default simply raises TypeError.&#10;&#10;If *sort_keys* is ``True`` (default: ``False``), then the output of&#10;dictionaries will be sorted by key.&#10;&#10;To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the&#10;``.default()`` method to serialize additional types), specify it with&#10;the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.">
				<Param name="obj" />
				<Param name="[skipkeys=False" />
				<Param name="[ensure_ascii=True" />
				<Param name="[check_circular=True" />
				<Param name="[allow_nan=True" />
				<Param name="[cls=None" />
				<Param name="[indent=None" />
				<Param name="[separators=None" />
				<Param name="[encoding=utf-8" />
				<Param name="[default=None" />
				<Param name="[sort_keys=False" />
				<Param name="[**]]]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.load" func="yes">
			<Overload retVal="" descr="Deserialize ``fp`` (a ``.read()``-supporting file-like object containing&#10;a JSON document) to a Python object.&#10;&#10;If the contents of ``fp`` is encoded with an ASCII based encoding other&#10;than utf-8 (e.g. latin-1), then an appropriate ``encoding`` name must&#10;be specified. Encodings that are not ASCII based (such as UCS-2) are&#10;not allowed, and should be wrapped with&#10;``codecs.getreader(fp)(encoding)``, or simply decoded to a ``unicode``&#10;object and passed to ``loads()``&#10;&#10;``object_hook`` is an optional function that will be called with the&#10;result of any object literal decode (a ``dict``). The return value of&#10;``object_hook`` will be used instead of the ``dict``. This feature&#10;can be used to implement custom decoders (e.g. JSON-RPC class hinting).&#10;&#10;``object_pairs_hook`` is an optional function that will be called with the&#10;result of any object literal decoded with an ordered list of pairs.  The&#10;return value of ``object_pairs_hook`` will be used instead of the ``dict``.&#10;This feature can be used to implement custom decoders that rely on the&#10;order that the key and value pairs are decoded (for example,&#10;collections.OrderedDict will remember the order of insertion). If&#10;``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.&#10;&#10;To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``&#10;kwarg; otherwise ``JSONDecoder`` is used.">
				<Param name="fp" />
				<Param name="[encoding=None" />
				<Param name="[cls=None" />
				<Param name="[object_hook=None" />
				<Param name="[parse_float=None" />
				<Param name="[parse_int=None" />
				<Param name="[parse_constant=None" />
				<Param name="[object_pairs_hook=None" />
				<Param name="[**]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.loads" func="yes">
			<Overload retVal="" descr="Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON&#10;document) to a Python object.&#10;&#10;If ``s`` is a ``str`` instance and is encoded with an ASCII based encoding&#10;other than utf-8 (e.g. latin-1) then an appropriate ``encoding`` name&#10;must be specified. Encodings that are not ASCII based (such as UCS-2)&#10;are not allowed and should be decoded to ``unicode`` first.&#10;&#10;``object_hook`` is an optional function that will be called with the&#10;result of any object literal decode (a ``dict``). The return value of&#10;``object_hook`` will be used instead of the ``dict``. This feature&#10;can be used to implement custom decoders (e.g. JSON-RPC class hinting).&#10;&#10;``object_pairs_hook`` is an optional function that will be called with the&#10;result of any object literal decoded with an ordered list of pairs.  The&#10;return value of ``object_pairs_hook`` will be used instead of the ``dict``.&#10;This feature can be used to implement custom decoders that rely on the&#10;order that the key and value pairs are decoded (for example,&#10;collections.OrderedDict will remember the order of insertion). If&#10;``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.&#10;&#10;``parse_float``, if specified, will be called with the string&#10;of every JSON float to be decoded. By default this is equivalent to&#10;float(num_str). This can be used to use another datatype or parser&#10;for JSON floats (e.g. decimal.Decimal).&#10;&#10;``parse_int``, if specified, will be called with the string&#10;of every JSON int to be decoded. By default this is equivalent to&#10;int(num_str). This can be used to use another datatype or parser&#10;for JSON integers (e.g. float).&#10;&#10;``parse_constant``, if specified, will be called with one of the&#10;following strings: -Infinity, Infinity, NaN, null, true, false.&#10;This can be used to raise an exception if invalid JSON numbers&#10;are encountered.&#10;&#10;To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``&#10;kwarg; otherwise ``JSONDecoder`` is used.">
				<Param name="s" />
				<Param name="[encoding=None" />
				<Param name="[cls=None" />
				<Param name="[object_hook=None" />
				<Param name="[parse_float=None" />
				<Param name="[parse_int=None" />
				<Param name="[parse_constant=None" />
				<Param name="[object_pairs_hook=None" />
				<Param name="[**]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="jumpahead" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword" func="yes">
			<Overload retVal="" descr="Keywords (from &quot;graminit.c&quot;)&#10;&#10;This file is automatically generated; please don't muck it up!&#10;&#10;To update the symbols in this file, 'cd' to the top directory of&#10;the python source tree after building the interpreter and run:&#10;&#10;    ./python Lib/keyword.py">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword.iskeyword" func="yes">
			<Overload retVal="" descr="x.__contains__(y) &lt;==&gt; y in x.">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword.kwlist" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword.main" />
		<KeyWord name="kill" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="label" func="yes">
			<Overload retVal="" descr="Function of cProfile">
			</Overload>
		</KeyWord>
		<KeyWord name="lambda" />
		<KeyWord name="latin_1_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="latin_1_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="layout" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="ldexp" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="ldgettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="ldngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="leapdays" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="left" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="len" func="yes">
			<Overload retVal="" descr="len(object) -&gt; integer&#10;&#10;Return the number of items of a sequence or collection.">
			</Overload>
		</KeyWord>
		<KeyWord name="lexists" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="lgamma" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="lgettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="lib2to3" />
		<KeyWord name="libc_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="liberal_is_HDN" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="lift" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache" func="yes">
			<Overload retVal="" descr="Cache lines from files.&#10;&#10;This is intended to read lines from modules imported -- hence if a filename&#10;is not found, it will look down the module search path for a file by&#10;that name.">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.checkcache" func="yes">
			<Overload retVal="" descr="Discard cache entries that are out of date.&#10;(This is not checked upon each call!)">
				<Param name="[filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.clearcache" func="yes">
			<Overload retVal="" descr="Clear the cache entirely.">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.getline" func="yes">
			<Overload retVal="" descr=>
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[module_globals=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.getlines" func="yes">
			<Overload retVal="" descr="Get the lines for a file from the cache.&#10;Update the cache if it doesn't contain an entry for this file already.">
				<Param name="filename" />
				<Param name="[module_globals=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.updatecache" func="yes">
			<Overload retVal="" descr="Update a cache entry and return its list of lines.&#10;If something's wrong, print a message, discard the cache entry,&#10;and return an empty list.">
				<Param name="filename" />
				<Param name="[module_globals=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="lineno" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="linux_distribution" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="list" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="list2cmdline" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="list_dialects" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="list_public_methods" func="yes">
			<Overload retVal="" descr="Function of SimpleXMLRPCServer">
			</Overload>
		</KeyWord>
		<KeyWord name="listdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="listen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="listmailcapfiles" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="literal_eval" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="ln" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="lngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="load" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromModule" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromName" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromNames" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromTestCase" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="load_cert_chain" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="load_default_certs" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="load_dh_params" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="load_extension" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="load_module" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
		<KeyWord name="load_verify_locations" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="loads" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib">
			</Overload>
		</KeyWord>
		<KeyWord name="localcontext" func="yes">
			<Overload retVal="" descr="Function of decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="locale" func="yes">
			<Overload retVal="" descr="Locale support.&#10;&#10;The module provides low-level access to the C lib's locale APIs&#10;and adds high level number formatting APIs as well as a locale&#10;aliasing engine to complement these.&#10;&#10;The aliasing engine includes support for many commonly used locale&#10;names and maps them to values suitable for passing to the C lib's&#10;setlocale() function. It also includes default encodings for all&#10;supported locale names.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.CHAR_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.Error" />
		<KeyWord name="locale.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_COLLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_CTYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_MONETARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_NUMERIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_TIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.atof" func="yes">
			<Overload retVal="" descr="Parses a string as a float according to the locale settings.">
				<Param name="string" />
				<Param name="[func=<type 'float'>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.atoi" func="yes">
			<Overload retVal="" descr="Converts a string to an integer according to the locale settings.">
				<Param name="str" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.currency" func="yes">
			<Overload retVal="" descr="Formats val according to the currency settings&#10;in the current locale.">
				<Param name="val" />
				<Param name="[symbol=True" />
				<Param name="[grouping=False" />
				<Param name="[international=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.format" func="yes">
			<Overload retVal="" descr="Returns the locale-aware substitution of a %? specifier&#10;(percent).&#10;&#10;additional is for format strings which contain one or more&#10;'*' modifiers.">
				<Param name="percent" />
				<Param name="value" />
				<Param name="[grouping=False" />
				<Param name="[monetary=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.format_string" func="yes">
			<Overload retVal="" descr="Formats a string in the same way that the % formatting would use,&#10;but takes the current locale into account.&#10;Grouping is applied if the third parameter is true.">
				<Param name="f" />
				<Param name="val" />
				<Param name="[grouping=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.getdefaultlocale" func="yes">
			<Overload retVal="" descr="Tries to determine the default locale settings and returns&#10;them as tuple (language code, encoding).&#10;&#10;According to POSIX, a program which has not called&#10;setlocale(LC_ALL, &quot;&quot;) runs using the portable 'C' locale.&#10;Calling setlocale(LC_ALL, &quot;&quot;) lets it use the default locale as&#10;defined by the LANG variable. Since we don't want to interfere&#10;with the current locale setting we thus emulate the behavior&#10;in the way described above.&#10;&#10;To maintain compatibility with other platforms, not only the&#10;LANG variable is tested, but a list of variables given as&#10;envvars parameter. The first found to be defined will be&#10;used. envvars defaults to the search path used in GNU gettext;&#10;it must always contain the variable name 'LANG'.&#10;&#10;Except for the code 'C', the language code corresponds to RFC&#10;1766.  code and encoding can be None in case the values cannot&#10;be determined.">
				<Param name="[envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.getlocale" func="yes">
			<Overload retVal="" descr="Returns the current setting for the given locale category as&#10;tuple (language code, encoding).&#10;&#10;category may be one of the LC_* value except LC_ALL. It&#10;defaults to LC_CTYPE.&#10;&#10;Except for the code 'C', the language code corresponds to RFC&#10;1766.  code and encoding can be None in case the values cannot&#10;be determined.">
				<Param name="[category=2]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.getpreferredencoding" func="yes">
			<Overload retVal="" descr="Return the charset that the user is likely using.">
				<Param name="[do_setlocale=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.locale_alias" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.locale_encoding_alias" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.localeconv" func="yes">
			<Overload retVal="" descr="() -&gt; dict. Returns numeric and monetary locale-specific parameters.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.normalize" func="yes">
			<Overload retVal="" descr="Returns a normalized locale code for the given locale&#10;name.&#10;&#10;The returned locale code is formatted for use with&#10;setlocale().&#10;&#10;If normalization fails, the original name is returned&#10;unchanged.&#10;&#10;If the given encoding is not known, the function defaults to&#10;the default encoding for the locale code just like setlocale()&#10;does.">
				<Param name="localename" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.resetlocale" func="yes">
			<Overload retVal="" descr="Sets the locale for category to the default setting.&#10;&#10;The default setting is determined by calling&#10;getdefaultlocale(). category defaults to LC_ALL.">
				<Param name="[category=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.setlocale" func="yes">
			<Overload retVal="" descr="Set the locale for the given category.  The locale can be&#10;a string, an iterable of two strings (language code and encoding),&#10;or None.&#10;&#10;Iterables are converted to strings using the locale aliasing&#10;engine.  Locale strings are passed directly to the C lib.&#10;&#10;category may be given as one of the LC_* values.">
				<Param name="category" />
				<Param name="[locale=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.str" func="yes">
			<Overload retVal="" descr="Convert float to integer, taking the locale into account.">
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.strcoll" func="yes">
			<Overload retVal="" descr="string,string -&gt; int. Compares two strings according to the locale.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.strxfrm" func="yes">
			<Overload retVal="" descr="string -&gt; string. Returns a string that behaves for cmp locale-aware.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.windows_locale" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="localeconv" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="localhost" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="locals" func="yes">
			<Overload retVal="" descr="locals() -&gt; dictionary&#10;&#10;Update and return a dictionary containing the current scope's local variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="locate" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="location" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="locked" func="yes">
			<Overload retVal="" descr="Function of dummy_thread.LockType">
			</Overload>
		</KeyWord>
		<KeyWord name="log" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="log10" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="log1p" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="log_to_stderr" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="logb" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="logging" func="yes">
			<Overload retVal="" descr="Logging package for Python. Based on PEP 282 and comments thereto in&#10;comp.lang.python.&#10;&#10;Copyright (C) 2001-2014 Vinay Sajip. All Rights Reserved.&#10;&#10;To use, simply 'import logging' and log away!">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BASIC_FORMAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter" func="yes">
			<Overload retVal="" descr="A formatter suitable for formatting a number of records.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter.format" func="yes">
			<Overload retVal="" descr="Format the specified records and return the result as a string.">
				<Param name="self" />
				<Param name="records" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter.formatFooter" func="yes">
			<Overload retVal="" descr="Return the footer string for the specified records.">
				<Param name="self" />
				<Param name="records" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter.formatHeader" func="yes">
			<Overload retVal="" descr="Return the header string for the specified records.">
				<Param name="self" />
				<Param name="records" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.CRITICAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FATAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler" func="yes">
			<Overload retVal="" descr="A handler class which writes formatted logging records to disk files.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.close" func="yes">
			<Overload retVal="" descr="Closes the stream.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.emit" func="yes">
			<Overload retVal="" descr="Emit a record.&#10;&#10;If the stream was not opened because 'delay' was specified in the&#10;constructor, open it before calling the superclass's emit.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.flush" func="yes">
			<Overload retVal="" descr="Flushes the stream.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.get_name" />
		<KeyWord name="logging.FileHandler.handle" func="yes">
			<Overload retVal="" descr="Conditionally emit the specified logging record.&#10;&#10;Emission depends on filters which may have been added to the handler.&#10;Wrap the actual emission of the record with acquisition/release of&#10;the I/O thread lock. Returns whether the filter passed the record for&#10;emission.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.set_name" />
		<KeyWord name="logging.Filter" func="yes">
			<Overload retVal="" descr='Filter instances are used to perform arbitrary filtering of LogRecords.&#10;&#10;Loggers and Handlers can optionally use Filter instances to filter&#10;records as desired. The base filter class only allows events which are&#10;below a certain point in the logger hierarchy. For example, a filter&#10;initialized with "A.B" will allow events logged by loggers "A.B",&#10;"A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If&#10;initialized with the empty string, all events are passed.'>
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filter.filter" func="yes">
			<Overload retVal="" descr="Determine if the specified record is to be logged.&#10;&#10;Is the specified record to be logged? Returns 0 for no, nonzero for&#10;yes. If deemed appropriate, the record may be modified in-place.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer" func="yes">
			<Overload retVal="" descr="A base class for loggers and handlers which allows them to share&#10;common code.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter" func="yes">
			<Overload retVal="" descr="Formatter instances are used to convert a LogRecord to text.&#10;&#10;Formatters need to know how a LogRecord is constructed. They are&#10;responsible for converting a LogRecord to (usually) a string which can&#10;be interpreted by either a human or an external system. The base Formatter&#10;allows a formatting string to be specified. If none is supplied, the&#10;default value of &quot;%s(message)\n&quot; is used.&#10;&#10;The Formatter can be initialized with a format string which makes use of&#10;knowledge of the LogRecord attributes - e.g. the default value mentioned&#10;above makes use of the fact that the user's message and arguments are pre-&#10;formatted into a LogRecord's message attribute. Currently, the useful&#10;attributes in a LogRecord are described by:&#10;&#10;%(name)s            Name of the logger (logging channel)&#10;%(levelno)s         Numeric logging level for the message (DEBUG, INFO,&#10;                    WARNING, ERROR, CRITICAL)&#10;%(levelname)s       Text logging level for the message (&quot;DEBUG&quot;, &quot;INFO&quot;,&#10;                    &quot;WARNING&quot;, &quot;ERROR&quot;, &quot;CRITICAL&quot;)&#10;%(pathname)s        Full pathname of the source file where the logging&#10;                    call was issued (if available)&#10;%(filename)s        Filename portion of pathname&#10;%(module)s          Module (name portion of filename)&#10;%(lineno)d          Source line number where the logging call was issued&#10;                    (if available)&#10;%(funcName)s        Function name&#10;%(created)f         Time when the LogRecord was created (time.time()&#10;                    return value)&#10;%(asctime)s         Textual time when the LogRecord was created&#10;%(msecs)d           Millisecond portion of the creation time&#10;%(relativeCreated)d Time in milliseconds when the LogRecord was created,&#10;                    relative to the time the logging module was loaded&#10;                    (typically at application startup time)&#10;%(thread)d          Thread ID (if available)&#10;%(threadName)s      Thread name (if available)&#10;%(process)d         Process ID (if available)&#10;%(message)s         The result of record.getMessage(), computed just as&#10;                    the record is emitted">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.converter" func="yes">
			<Overload retVal="" descr="localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,&#10;                          tm_sec,tm_wday,tm_yday,tm_isdst)&#10;&#10;Convert seconds since the Epoch to a time tuple expressing local time.&#10;When 'seconds' is not passed in, convert the current time instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.format" func="yes">
			<Overload retVal="" descr="Format the specified record as text.&#10;&#10;The record's attribute dictionary is used as the operand to a&#10;string formatting operation which yields the returned string.&#10;Before formatting the dictionary, a couple of preparatory steps&#10;are carried out. The message attribute of the record is computed&#10;using LogRecord.getMessage(). If the formatting string uses the&#10;time (as determined by a call to usesTime(), formatTime() is&#10;called to format the event time. If there is exception information,&#10;it is formatted using formatException() and appended to the message.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.formatException" func="yes">
			<Overload retVal="" descr="Format and return the specified exception information as a string.&#10;&#10;This default implementation just uses&#10;traceback.print_exception()">
				<Param name="self" />
				<Param name="ei" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.formatTime" func="yes">
			<Overload retVal="" descr="Return the creation time of the specified LogRecord as formatted text.&#10;&#10;This method should be called from format() by a formatter which&#10;wants to make use of a formatted time. This method can be overridden&#10;in formatters to provide for any specific requirement, but the&#10;basic behaviour is as follows: if datefmt (a string) is specified,&#10;it is used with time.strftime() to format the creation time of the&#10;record. Otherwise, the ISO8601 format is used. The resulting&#10;string is returned. This function uses a user-configurable function&#10;to convert the creation time to a tuple. By default, time.localtime()&#10;is used; to change this for a particular formatter instance, set the&#10;'converter' attribute to a function with the same signature as&#10;time.localtime() or time.gmtime(). To change it for all formatters,&#10;for example if you want all logging times to be shown in GMT,&#10;set the 'converter' attribute in the Formatter class.">
				<Param name="self" />
				<Param name="record" />
				<Param name="[datefmt=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.usesTime" func="yes">
			<Overload retVal="" descr="Check if the format uses the creation time of the record.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler" func="yes">
			<Overload retVal="" descr="Handler instances dispatch logging events to specific destinations.&#10;&#10;The base handler class. Acts as a placeholder which defines the Handler&#10;interface. Handlers can optionally use Formatter instances to format&#10;records as desired. By default, no formatter is specified; in this case,&#10;the 'raw' message as determined by record.message is logged.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.close" func="yes">
			<Overload retVal="" descr="Tidy up any resources used by the handler.&#10;&#10;This version removes the handler from an internal map of handlers,&#10;_handlers, which is used for handler lookup by name. Subclasses&#10;should ensure that this gets called from overridden close()&#10;methods.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.emit" func="yes">
			<Overload retVal="" descr="Do whatever it takes to actually log the specified logging record.&#10;&#10;This version is intended to be implemented by subclasses and so&#10;raises a NotImplementedError.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.flush" func="yes">
			<Overload retVal="" descr="Ensure all logging output has been flushed.&#10;&#10;This version does nothing and is intended to be implemented by&#10;subclasses.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.get_name" />
		<KeyWord name="logging.Handler.handle" func="yes">
			<Overload retVal="" descr="Conditionally emit the specified logging record.&#10;&#10;Emission depends on filters which may have been added to the handler.&#10;Wrap the actual emission of the record with acquisition/release of&#10;the I/O thread lock. Returns whether the filter passed the record for&#10;emission.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.set_name" />
		<KeyWord name="logging.INFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LogRecord" func="yes">
			<Overload retVal="" descr="A LogRecord instance represents an event being logged.&#10;&#10;LogRecord instances are created every time something is logged. They&#10;contain all the information pertinent to the event being logged. The&#10;main information passed in is in msg and args, which are combined&#10;using str(msg) % args to create the message field of the record. The&#10;record also includes information such as when the record was created,&#10;the source line where the logging call was made, and any exception&#10;information to be logged.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LogRecord.getMessage" func="yes">
			<Overload retVal="" descr="Return the message for this LogRecord.&#10;&#10;Return the message for this LogRecord after merging any user-supplied&#10;arguments with the message.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger" func="yes">
			<Overload retVal="" descr='Instances of the Logger class represent a single logging channel. A&#10;"logging channel" indicates an area of an application. Exactly how an&#10;"area" is defined is up to the application developer. Since an&#10;application can have any number of areas, logging channels are identified&#10;by a unique string. Application areas can be nested (e.g. an area&#10;of "input processing" might include sub-areas "read CSV files", "read&#10;XLS files" and "read Gnumeric files"). To cater for this natural nesting,&#10;channel names are organized into a namespace hierarchy where levels are&#10;separated by periods, much like the Java or Python package namespace. So&#10;in the instance given above, channel names might be "input" for the upper&#10;level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.&#10;There is no arbitrary limit to the depth of nesting.'>
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.addHandler" func="yes">
			<Overload retVal="" descr="Add the specified handler to this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.callHandlers" func="yes">
			<Overload retVal="" descr='Pass a record to all relevant handlers.&#10;&#10;Loop through all handlers for this logger and its parents in the&#10;logger hierarchy. If no handler was found, output a one-off error&#10;message to sys.stderr. Stop searching up the hierarchy whenever a&#10;logger with the "propagate" attribute set to zero is found - that&#10;will be the last logger whose handlers are called.'>
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.critical" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.debug" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'DEBUG'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.debug(&quot;Houston, we have a %s&quot;, &quot;thorny problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.error" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'ERROR'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.error(&quot;Houston, we have a %s&quot;, &quot;major problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.exception" func="yes">
			<Overload retVal="" descr="Convenience method for logging an ERROR with exception information.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.fatal" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.findCaller" func="yes">
			<Overload retVal="" descr="Find the stack frame of the caller so that we can note the source&#10;file name, line number and function name.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.getChild" func="yes">
			<Overload retVal="" descr="Get a logger which is a descendant to this one.&#10;&#10;This is a convenience method, such that&#10;&#10;logging.getLogger('abc').getChild('def.ghi')&#10;&#10;is the same as&#10;&#10;logging.getLogger('abc.def.ghi')&#10;&#10;It's useful, for example, when the parent logger is named using&#10;__name__ rather than a literal string.">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Get the effective level for this logger.&#10;&#10;Loop through this logger and its parents in the logger hierarchy,&#10;looking for a non-zero logging level. Return the first one found.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.handle" func="yes">
			<Overload retVal="" descr="Call the handlers for the specified record.&#10;&#10;This method is used for unpickled records received from a socket, as&#10;well as those created locally. Logger-level filtering is applied.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.info" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'INFO'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.info(&quot;Houston, we have a %s&quot;, &quot;interesting problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.isEnabledFor" func="yes">
			<Overload retVal="" descr="Is this logger enabled for level 'level'?">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.log" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with the integer severity 'level'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.log(level, &quot;We have a %s&quot;, &quot;mysterious problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.makeRecord" func="yes">
			<Overload retVal="" descr="A factory method which can be overridden in subclasses to create&#10;specialized LogRecords.">
				<Param name="self" />
				<Param name="name" />
				<Param name="level" />
				<Param name="fn" />
				<Param name="lno" />
				<Param name="msg" />
				<Param name="args" />
				<Param name="exc_info" />
				<Param name="[func=None" />
				<Param name="[extra=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.manager" func="yes">
			<Overload retVal="" descr="(Manager)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.removeHandler" func="yes">
			<Overload retVal="" descr="Remove the specified handler from this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.root" func="yes">
			<Overload retVal="" descr="(RootLogger)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this logger.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.warn" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'WARNING'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.warning" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'WARNING'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter" func="yes">
			<Overload retVal="" descr="An adapter for loggers which makes it easier to specify contextual&#10;information in logging output.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.critical" func="yes">
			<Overload retVal="" descr="Delegate a critical call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.debug" func="yes">
			<Overload retVal="" descr="Delegate a debug call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.error" func="yes">
			<Overload retVal="" descr="Delegate an error call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.exception" func="yes">
			<Overload retVal="" descr="Delegate an exception call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.info" func="yes">
			<Overload retVal="" descr="Delegate an info call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.isEnabledFor" func="yes">
			<Overload retVal="" descr="See if the underlying logger is enabled for the specified level.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.log" func="yes">
			<Overload retVal="" descr="Delegate a log call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.process" func="yes">
			<Overload retVal="" descr="Process the logging message and keyword arguments passed in to&#10;a logging call to insert contextual information. You can either&#10;manipulate the message itself, the keyword args or both. Return&#10;the message and kwargs modified (or not) to suit your needs.&#10;&#10;Normally, you'll only need to override this one method in a&#10;LoggerAdapter subclass for your specific needs.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="kwargs" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.warning" func="yes">
			<Overload retVal="" descr="Delegate a warning call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager" func="yes">
			<Overload retVal="" descr="There is [under normal circumstances] just one Manager instance, which&#10;holds the hierarchy of loggers.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager.getLogger" func="yes">
			<Overload retVal="" descr="Get a logger with the specified name (channel name), creating it&#10;if it doesn't yet exist. This name is a dot-separated hierarchical&#10;name, such as &quot;a&quot;, &quot;a.b&quot;, &quot;a.b.c&quot; or similar.&#10;&#10;If a PlaceHolder existed for the specified name [i.e. the logger&#10;didn't exist but a child of it did], replace it with the created&#10;logger and fix up the parent/child references which pointed to the&#10;placeholder to now point to the logger.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager.setLoggerClass" func="yes">
			<Overload retVal="" descr="Set the class to be used when instantiating a logger with this Manager.">
				<Param name="self" />
				<Param name="klass" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler" func="yes">
			<Overload retVal="" descr="This handler does nothing. It's intended to be used to avoid the&#10;&quot;No handlers could be found for logger XXX&quot; one-off warning. This is&#10;important for library code, which may contain code to log events. If a user&#10;of the library does not configure logging, the one-off warning might be&#10;produced; to avoid this, the library developer simply needs to instantiate&#10;a NullHandler and add it to the top-level logger of the library module or&#10;package.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.close" func="yes">
			<Overload retVal="" descr="Tidy up any resources used by the handler.&#10;&#10;This version removes the handler from an internal map of handlers,&#10;_handlers, which is used for handler lookup by name. Subclasses&#10;should ensure that this gets called from overridden close()&#10;methods.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.createLock" />
		<KeyWord name="logging.NullHandler.emit" />
		<KeyWord name="logging.NullHandler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.flush" func="yes">
			<Overload retVal="" descr="Ensure all logging output has been flushed.&#10;&#10;This version does nothing and is intended to be implemented by&#10;subclasses.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.get_name" />
		<KeyWord name="logging.NullHandler.handle" />
		<KeyWord name="logging.NullHandler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.set_name" />
		<KeyWord name="logging.PlaceHolder" func="yes">
			<Overload retVal="" descr="PlaceHolder instances are used in the Manager logger hierarchy to take&#10;the place of nodes for which no loggers have been defined. This class is&#10;intended for internal use only and not as part of the public API.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.PlaceHolder.append" func="yes">
			<Overload retVal="" descr="Add the specified logger as a child of this placeholder.">
				<Param name="self" />
				<Param name="alogger" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger" func="yes">
			<Overload retVal="" descr="A root logger is not that different to any other logger, except that&#10;it must have a logging level and there is only one instance of it in&#10;the hierarchy.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.addHandler" func="yes">
			<Overload retVal="" descr="Add the specified handler to this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.callHandlers" func="yes">
			<Overload retVal="" descr='Pass a record to all relevant handlers.&#10;&#10;Loop through all handlers for this logger and its parents in the&#10;logger hierarchy. If no handler was found, output a one-off error&#10;message to sys.stderr. Stop searching up the hierarchy whenever a&#10;logger with the "propagate" attribute set to zero is found - that&#10;will be the last logger whose handlers are called.'>
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.critical" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.debug" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'DEBUG'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.debug(&quot;Houston, we have a %s&quot;, &quot;thorny problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.error" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'ERROR'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.error(&quot;Houston, we have a %s&quot;, &quot;major problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.exception" func="yes">
			<Overload retVal="" descr="Convenience method for logging an ERROR with exception information.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.fatal" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.findCaller" func="yes">
			<Overload retVal="" descr="Find the stack frame of the caller so that we can note the source&#10;file name, line number and function name.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.getChild" func="yes">
			<Overload retVal="" descr="Get a logger which is a descendant to this one.&#10;&#10;This is a convenience method, such that&#10;&#10;logging.getLogger('abc').getChild('def.ghi')&#10;&#10;is the same as&#10;&#10;logging.getLogger('abc.def.ghi')&#10;&#10;It's useful, for example, when the parent logger is named using&#10;__name__ rather than a literal string.">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Get the effective level for this logger.&#10;&#10;Loop through this logger and its parents in the logger hierarchy,&#10;looking for a non-zero logging level. Return the first one found.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.handle" func="yes">
			<Overload retVal="" descr="Call the handlers for the specified record.&#10;&#10;This method is used for unpickled records received from a socket, as&#10;well as those created locally. Logger-level filtering is applied.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.info" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'INFO'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.info(&quot;Houston, we have a %s&quot;, &quot;interesting problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.isEnabledFor" func="yes">
			<Overload retVal="" descr="Is this logger enabled for level 'level'?">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.log" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with the integer severity 'level'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.log(level, &quot;We have a %s&quot;, &quot;mysterious problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.makeRecord" func="yes">
			<Overload retVal="" descr="A factory method which can be overridden in subclasses to create&#10;specialized LogRecords.">
				<Param name="self" />
				<Param name="name" />
				<Param name="level" />
				<Param name="fn" />
				<Param name="lno" />
				<Param name="msg" />
				<Param name="args" />
				<Param name="exc_info" />
				<Param name="[func=None" />
				<Param name="[extra=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.manager" func="yes">
			<Overload retVal="" descr="(Manager)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.removeHandler" func="yes">
			<Overload retVal="" descr="Remove the specified handler from this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.root" func="yes">
			<Overload retVal="" descr="(RootLogger)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this logger.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.warn" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'WARNING'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.warning" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'WARNING'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler" func="yes">
			<Overload retVal="" descr="A handler class which writes logging records, appropriately formatted,&#10;to a stream. Note that this class does not close the stream, as&#10;sys.stdout or sys.stderr may be used.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.close" func="yes">
			<Overload retVal="" descr="Tidy up any resources used by the handler.&#10;&#10;This version removes the handler from an internal map of handlers,&#10;_handlers, which is used for handler lookup by name. Subclasses&#10;should ensure that this gets called from overridden close()&#10;methods.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.emit" func="yes">
			<Overload retVal="" descr="Emit a record.&#10;&#10;If a formatter is specified, it is used to format the record.&#10;The record is then written to the stream with a trailing newline.  If&#10;exception information is present, it is formatted using&#10;traceback.print_exception and appended to the stream.  If the stream&#10;has an 'encoding' attribute, it is used to determine how to do the&#10;output to the stream.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.flush" func="yes">
			<Overload retVal="" descr="Flushes the stream.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.get_name" />
		<KeyWord name="logging.StreamHandler.handle" func="yes">
			<Overload retVal="" descr="Conditionally emit the specified logging record.&#10;&#10;Emission depends on filters which may have been added to the handler.&#10;Wrap the actual emission of the record with acquisition/release of&#10;the I/O thread lock. Returns whether the filter passed the record for&#10;emission.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.set_name" />
		<KeyWord name="logging.WARN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.WARNING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.addLevelName" func="yes">
			<Overload retVal="" descr="Associate 'levelName' with 'level'.&#10;&#10;This is used when converting levels to text during message formatting.">
				<Param name="level" />
				<Param name="levelName" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.basicConfig" func="yes">
			<Overload retVal="" descr="Do basic configuration for the logging system.&#10;&#10;This function does nothing if the root logger already has handlers&#10;configured. It is a convenience method intended for use by simple scripts&#10;to do one-shot configuration of the logging package.&#10;&#10;The default behaviour is to create a StreamHandler which writes to&#10;sys.stderr, set a formatter using the BASIC_FORMAT format string, and&#10;add the handler to the root logger.&#10;&#10;A number of optional keyword arguments may be specified, which can alter&#10;the default behaviour.&#10;&#10;filename  Specifies that a FileHandler be created, using the specified&#10;          filename, rather than a StreamHandler.&#10;filemode  Specifies the mode to open the file, if filename is specified&#10;          (if filemode is unspecified, it defaults to 'a').&#10;format    Use the specified format string for the handler.&#10;datefmt   Use the specified date/time format.&#10;level     Set the root logger level to the specified level.&#10;stream    Use the specified stream to initialize the StreamHandler. Note&#10;          that this argument is incompatible with 'filename' - if both&#10;          are present, 'stream' is ignored.&#10;&#10;Note that you could specify a stream created using open(filename, mode)&#10;rather than passing the filename and mode in. However, it should be&#10;remembered that StreamHandler does not close its stream (since it may be&#10;using sys.stdout or sys.stderr), whereas FileHandler closes its stream&#10;when the handler is closed.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.captureWarnings" func="yes">
			<Overload retVal="" descr="If capture is true, redirect all warnings to the logging package.&#10;If capture is False, ensure that warnings are not redirected to logging&#10;but to their original destinations.">
				<Param name="capture" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.critical" func="yes">
			<Overload retVal="" descr="Log a message with severity 'CRITICAL' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.currentframe" />
		<KeyWord name="logging.debug" func="yes">
			<Overload retVal="" descr="Log a message with severity 'DEBUG' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.disable" func="yes">
			<Overload retVal="" descr="Disable all logging calls of severity 'level' and below.">
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.error" func="yes">
			<Overload retVal="" descr="Log a message with severity 'ERROR' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.exception" func="yes">
			<Overload retVal="" descr="Log a message with severity 'ERROR' on the root logger,&#10;with exception information.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.fatal" func="yes">
			<Overload retVal="" descr="Log a message with severity 'CRITICAL' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLevelName" func="yes">
			<Overload retVal="" descr="Return the textual representation of logging level 'level'.&#10;&#10;If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,&#10;INFO, DEBUG) then you get the corresponding string. If you have&#10;associated levels with names using addLevelName then the name you have&#10;associated with 'level' is returned.&#10;&#10;If a numeric value corresponding to one of the defined levels is passed&#10;in, the corresponding string representation is returned.&#10;&#10;Otherwise, the string &quot;Level %s&quot; % level is returned.">
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLogger" func="yes">
			<Overload retVal="" descr="Return a logger with the specified name, creating it if necessary.&#10;&#10;If no name is specified, return the root logger.">
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLoggerClass" func="yes">
			<Overload retVal="" descr="Return the class to be used when instantiating a logger.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.info" func="yes">
			<Overload retVal="" descr="Log a message with severity 'INFO' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.log" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with the integer severity 'level' on the root logger.">
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.logMultiprocessing" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.logProcesses" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.logThreads" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.makeLogRecord" func="yes">
			<Overload retVal="" descr="Make a LogRecord whose attributes are defined by the specified dictionary,&#10;This function is useful for converting a logging event received over&#10;a socket connection (which is sent as a dictionary) into a LogRecord&#10;instance.">
				<Param name="dict" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.raiseExceptions" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.root" func="yes">
			<Overload retVal="" descr="(RootLogger)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.setLoggerClass" func="yes">
			<Overload retVal="" descr="Set the class to be used when instantiating a logger. The class should&#10;define __init__() such that only a name argument is required, and the&#10;__init__() should call Logger.__init__()">
				<Param name="klass" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.shutdown" func="yes">
			<Overload retVal="" descr="Perform any cleanup actions in the logging system (e.g. flushing&#10;buffers).&#10;&#10;Should be called at application exit.">
				<Param name="[handlerList=[<weakref at 0000000004DAC2C8; to 'NULLHandler' at 0000000004D9EBE0>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.warn" func="yes">
			<Overload retVal="" descr="Log a message with severity 'WARNING' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.warning" func="yes">
			<Overload retVal="" descr="Log a message with severity 'WARNING' on the root logger.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logical_and" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="logical_invert" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="logical_or" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="logical_xor" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="lognormvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="long" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="long_has_args" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="lookup" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="lookup_error" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="loop" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="lower" func="yes">
			<Overload retVal="" descr="B.lower() -&gt; copy of B&#10;&#10;Return a copy of B with all ASCII characters converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="lseek" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="lstat" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="lt" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="lwp_cookie_str" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="m" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="mac_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="machine" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath" func="yes">
			<Overload retVal="" descr="Pathname and path-related operations for the Macintosh.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_ARCHIVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_SNAPSHOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_ATIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_CTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_DEV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_GID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_INO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_MTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_NLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_UID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ENFMT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFBLK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFCHR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFDIR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFIFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFLNK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFMT" />
		<KeyWord name="macpath.S_IFREG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFSOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IMODE" />
		<KeyWord name="macpath.S_IREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IROTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRWXG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRWXO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRWXU" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISBLK" />
		<KeyWord name="macpath.S_ISCHR" />
		<KeyWord name="macpath.S_ISDIR" />
		<KeyWord name="macpath.S_ISFIFO" />
		<KeyWord name="macpath.S_ISGID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISLNK" />
		<KeyWord name="macpath.S_ISREG" />
		<KeyWord name="macpath.S_ISSOCK" />
		<KeyWord name="macpath.S_ISUID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISVTX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IXGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IXOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IXUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_COMPRESSED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_HIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_NODUMP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_OPAQUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.abspath" func="yes">
			<Overload retVal="" descr="Return an absolute path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.basename" />
		<KeyWord name="macpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.dirname" />
		<KeyWord name="macpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.expanduser" func="yes">
			<Overload retVal="" descr="Dummy to retain interface-compatibility with other operating systems.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.expandvars" func="yes">
			<Overload retVal="" descr="Dummy to retain interface-compatibility with other operating systems.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.isabs" func="yes">
			<Overload retVal="" descr="Return true if a path is absolute.&#10;On the Mac, relative paths begin with a colon,&#10;but as a special case, paths with no colons at all are also relative.&#10;Anything else is absolute (the string up to the first colon is the&#10;volume name).">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.islink" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to a symbolic link.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ismount" />
		<KeyWord name="macpath.join" />
		<KeyWord name="macpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns True for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.norm_error" func="yes">
			<Overload retVal="" descr="Path cannot be normalized">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.norm_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.norm_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.normcase" />
		<KeyWord name="macpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize a pathname.  Will return the same result for&#10;equivalent paths.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.realpath" />
		<KeyWord name="macpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.split" func="yes">
			<Overload retVal="" descr="Split a pathname into two parts: the directory leading up to the final&#10;bit, and the basename (the filename, without colons, in that directory).&#10;The result (s, t) is such that join(s, t) yields the original argument.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.splitdrive" func="yes">
			<Overload retVal="" descr="Split a pathname into a drive specification and the rest of the&#10;path.  Useful on DOS/Windows/NT; on the Mac, the drive is always&#10;empty (don't use the volume name -- it doesn't have the same&#10;syntactic and semantic oddities as DOS drive letters, such as there&#10;being a separate current directory per drive).">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.supports_unicode_filenames" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.walk" func="yes">
			<Overload retVal="" descr="Directory tree walk with callback function.&#10;&#10;For each directory in the directory tree rooted at top (including top&#10;itself, but excluding '.' and '..'), call func(arg, dirname, fnames).&#10;dirname is the name of the directory, and fnames a list of the names of&#10;the files and subdirectories in dirname (excluding '.' and '..').  func&#10;may modify the fnames list in-place (e.g. via del or slice assignment),&#10;and walk will only recurse into the subdirectories whose names remain in&#10;fnames; this can be used to implement a filter, or to impose a specific&#10;order of visiting.  No semantics are defined for, or required of, arg,&#10;beyond that arg is always passed to func.  It can be used, e.g., to pass&#10;a filename pattern, or a mutable object designed to accumulate&#10;statistics.  Passing None for arg is common.">
				<Param name="top" />
				<Param name="func" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="macurl2path" func="yes">
			<Overload retVal="" descr="Macintosh-specific module for conversion between pathnames and URLs.&#10;&#10;Do not import directly; use urllib instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="macurl2path.pathname2url" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a file system path to a relative URL&#10;of the 'file' scheme; not recommended for general use.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="macurl2path.url2pathname" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a relative URL of the 'file' scheme&#10;to a file system path; not recommended for general use.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox" func="yes">
			<Overload retVal="" descr="Read/write support for Maildir, mbox, MH, Babyl, and MMDF mailboxes.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMailbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Error" func="yes">
			<Overload retVal="" descr="Raised for module-specific errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.ExternalClashError" func="yes">
			<Overload retVal="" descr="Another process caused an action to fail.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.ExternalClashError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.ExternalClashError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.FormatError" func="yes">
			<Overload retVal="" descr="A file appears to have an invalid format.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.FormatError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.FormatError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMailbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MmdfMailbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NoSuchMailboxError" func="yes">
			<Overload retVal="" descr="The specified mailbox does not exist and won't be created.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NoSuchMailboxError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NoSuchMailboxError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NotEmptyError" func="yes">
			<Overload retVal="" descr="The specified mailbox is not empty and deletion was requested.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NotEmptyError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NotEmptyError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.PortableUnixMailbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.UnixMailbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap" func="yes">
			<Overload retVal="" descr="Mailcap file handling.  See RFC 1524.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.findmatch" func="yes">
			<Overload retVal="" descr="Find a match for a mailcap entry.&#10;&#10;Return a tuple containing the command line, and the mailcap entry&#10;used; (None, None) if no match is found.  This may invoke the&#10;'test' command of several matching entries before deciding which&#10;entry to use.">
				<Param name="caps" />
				<Param name="MIMEtype" />
				<Param name="[key=view" />
				<Param name="[filename=/dev/null" />
				<Param name="[plist=[]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.findparam" />
		<KeyWord name="mailcap.getcaps" func="yes">
			<Overload retVal="" descr="Return a dictionary containing the mailcap database.&#10;&#10;The dictionary maps a MIME type (in all lowercase, e.g. 'text/plain')&#10;to a list of dictionaries corresponding to mailcap entries.  The list&#10;collects all the entries for that MIME type from all available mailcap&#10;files.  Each dictionary contains key-value pairs for that MIME type,&#10;where the viewing command is stored with the key &quot;view&quot;.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.listmailcapfiles" func="yes">
			<Overload retVal="" descr="Return a list of all mailcap files found on the system.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.lookup" func="yes">
			<Overload retVal="" descr=>
				<Param name="caps" />
				<Param name="MIMEtype" />
				<Param name="[key=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.parsefield" func="yes">
			<Overload retVal="" descr="Separate one key-value pair in a mailcap entry.">
				<Param name="line" />
				<Param name="i" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.parseline" func="yes">
			<Overload retVal="" descr='Parse one entry in a mailcap file and return a dictionary.&#10;&#10;The viewing command is stored as the value with the key "view",&#10;and the rest of the fields produce key-value pairs in the dict.'>
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.readmailcapfile" func="yes">
			<Overload retVal="" descr='Read a mailcap file and return a dictionary keyed by MIME type.&#10;&#10;Each MIME type is mapped to an entry consisting of a list of&#10;dictionaries; the list will contain more than one such dictionary&#10;if a given MIME type appears more than once in the mailcap file.&#10;Each dictionary contains key-value pairs for that MIME type, where&#10;the viewing command is stored with the key "view".'>
				<Param name="fp" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.show" />
		<KeyWord name="mailcap.subst" func="yes">
			<Overload retVal="" descr=>
				<Param name="field" />
				<Param name="MIMEtype" />
				<Param name="filename" />
				<Param name="[plist=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.test" />
		<KeyWord name="main" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="mainloop" func="yes">
			<Overload retVal="" descr="Function of tkCommonDialog">
			</Overload>
		</KeyWord>
		<KeyWord name="makeLogRecord" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="makeRecord" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="makeSuite" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="make_archive" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="make_encoding_map" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="make_file" func="yes">
			<Overload retVal="" descr="Function of difflib.HtmlDiff">
			</Overload>
		</KeyWord>
		<KeyWord name="make_id" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="make_identity_dict" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="make_table" func="yes">
			<Overload retVal="" descr="Function of difflib.HtmlDiff">
			</Overload>
		</KeyWord>
		<KeyWord name="makedev" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makedict" func="yes">
			<Overload retVal="" descr="Function of sre_compile">
			</Overload>
		</KeyWord>
		<KeyWord name="makedir" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makedirs" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="makefifo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makefile" func="yes">
			<Overload retVal="" descr="Function of socket.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="makelink" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makepath" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="makepipeline" func="yes">
			<Overload retVal="" descr="Function of pipes">
			</Overload>
		</KeyWord>
		<KeyWord name="maketrans" func="yes">
			<Overload retVal="" descr="Function of string">
			</Overload>
		</KeyWord>
		<KeyWord name="makeunknown" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="map" func="yes">
			<Overload retVal="" descr="map(function, sequence[, sequence, ...]) -&gt; list&#10;&#10;Return a list of the results of applying the function to the items of&#10;the argument sequence(s).  If more than one sequence is given, the&#10;function is called with an argument list consisting of the corresponding&#10;item of each sequence, substituting None for missing values when not all&#10;sequences have the same length.  If the function is None, return a list of&#10;the items of the sequence (or a list of tuples if more than one sequence).">
			</Overload>
		</KeyWord>
		<KeyWord name="map_table_b2" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="map_table_b3" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="markupbase" func="yes">
			<Overload retVal="" descr="Shared support for scanning document type declarations in HTML and XHTML.&#10;&#10;This module is used as a foundation for the HTMLParser and sgmllib&#10;modules (indirectly, for htmllib as well).  It has no documented&#10;public API and should not be used directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="markupbase.ParserBase" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="match" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="match_hostname" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="max" func="yes">
			<Overload retVal="" descr="max(iterable[, key=func]) -&gt; value&#10;max(a, b, c, ...[, key=func]) -&gt; value&#10;&#10;With a single iterable argument, return its largest item.&#10;With two or more arguments, return the largest argument.">
			</Overload>
		</KeyWord>
		<KeyWord name="max_mag" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="maybe" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="mbcs_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="mbcs_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="md5" />
		<KeyWord name="md5.blocksize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="md5.digest_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="md5.md5" func="yes">
			<Overload retVal="" descr="Returns a md5 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="md5.new" func="yes">
			<Overload retVal="" descr="Returns a md5 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="memoryview" func="yes">
			<Overload retVal="" descr="memoryview(object)&#10;&#10;Create a new memoryview object which references the given object.">
			</Overload>
		</KeyWord>
		<KeyWord name="merge" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="message_from_file" func="yes">
			<Overload retVal="" descr="Function of email">
			</Overload>
		</KeyWord>
		<KeyWord name="message_from_string" func="yes">
			<Overload retVal="" descr="Function of email">
			</Overload>
		</KeyWord>
		<KeyWord name="meth" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib" func="yes">
			<Overload retVal="" descr="MH interface -- purely object-oriented (well, almost)&#10;&#10;Executive summary:&#10;&#10;import mhlib&#10;&#10;mh = mhlib.MH()         # use default mailbox directory and profile&#10;mh = mhlib.MH(mailbox)  # override mailbox location (default from profile)&#10;mh = mhlib.MH(mailbox, profile) # override mailbox and profile&#10;&#10;mh.error(format, ...)   # print error message -- can be overridden&#10;s = mh.getprofile(key)  # profile entry (None if not set)&#10;path = mh.getpath()     # mailbox pathname&#10;name = mh.getcontext()  # name of current folder&#10;mh.setcontext(name)     # set name of current folder&#10;&#10;list = mh.listfolders() # names of top-level folders&#10;list = mh.listallfolders() # names of all folders, including subfolders&#10;list = mh.listsubfolders(name) # direct subfolders of given folder&#10;list = mh.listallsubfolders(name) # all subfolders of given folder&#10;&#10;mh.makefolder(name)     # create new folder&#10;mh.deletefolder(name)   # delete folder -- must have no subfolders&#10;&#10;f = mh.openfolder(name) # new open folder object&#10;&#10;f.error(format, ...)    # same as mh.error(format, ...)&#10;path = f.getfullname()  # folder's full pathname&#10;path = f.getsequencesfilename() # full pathname of folder's sequences file&#10;path = f.getmessagefilename(n)  # full pathname of message n in folder&#10;&#10;list = f.listmessages() # list of messages in folder (as numbers)&#10;n = f.getcurrent()      # get current message&#10;f.setcurrent(n)         # set current message&#10;list = f.parsesequence(seq)     # parse msgs syntax into list of messages&#10;n = f.getlast()         # get last message (0 if no messagse)&#10;f.setlast(n)            # set last message (internal use only)&#10;&#10;dict = f.getsequences() # dictionary of sequences in folder {name: list}&#10;f.putsequences(dict)    # write sequences back to folder&#10;&#10;f.createmessage(n, fp)  # add message from file f as number n&#10;f.removemessages(list)  # remove messages in list from folder&#10;f.refilemessages(list, tofolder) # move messages in list to other folder&#10;f.movemessage(n, tofolder, ton)  # move one message to a given destination&#10;f.copymessage(n, tofolder, ton)  # copy one message to a given destination&#10;&#10;m = f.openmessage(n)    # new open message object (costs a file descriptor)&#10;m is a derived class of mimetools.Message(rfc822.Message), with:&#10;s = m.getheadertext()   # text of message's headers&#10;s = m.getheadertext(pred) # text of message's headers, filtered by pred&#10;s = m.getbodytext()     # text of message's body, decoded&#10;s = m.getbodytext(0)    # text of message's body, not decoded">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.Error" />
		<KeyWord name="mhlib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.FOLDER_PROTECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.Folder" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.IntSet" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.MH" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.MH_PROFILE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.MH_SEQUENCES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.PATH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.SubMessage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.bisect" func="yes">
			<Overload retVal="" descr="bisect(a, x[, lo[, hi]]) -&gt; index&#10;bisect_right(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt;= x, and all e in&#10;a[i:] have e &gt; x.  So if x already appears in the list, i points just&#10;beyond the rightmost x already there&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.isnumeric" />
		<KeyWord name="mhlib.numericprog" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.pickline" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="key" />
				<Param name="[casefold=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mhlib.test" />
		<KeyWord name="mhlib.updateline" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="key" />
				<Param name="value" />
				<Param name="[casefold=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mime_decode" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="mime_decode_header" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="mime_encode" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="mime_encode_header" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools" func="yes">
			<Overload retVal="" descr="Various tools used by MIME-reading or MIME-writing programs.">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.catch_warnings" func="yes">
			<Overload retVal="" descr="A context manager that copies and restores the warnings filter upon&#10;exiting the context.&#10;&#10;The 'record' argument specifies whether warnings should be captured by a&#10;custom implementation of warnings.showwarning() and be appended to a list&#10;returned by the context manager. Otherwise None is returned by the context&#10;manager. The objects appended to the list are arguments whose attributes&#10;mirror the arguments to showwarning().&#10;&#10;The 'module' argument is to specify an alternative module to the module&#10;named 'warnings' and imported under that name. This argument is only useful&#10;when testing the warnings module itself.">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.choose_boundary" func="yes">
			<Overload retVal="" descr="Return a string usable as a multipart boundary.&#10;&#10;The string chosen is unique within a single program run, and&#10;incorporates the user id (if available), process id (if available),&#10;and current time.  So it's very unlikely the returned string appears&#10;in message text, but there's no guarantee.&#10;&#10;The boundary contains dots so you have to quote it in the header.">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.copybinary" />
		<KeyWord name="mimetools.copyliteral" />
		<KeyWord name="mimetools.decode" func="yes">
			<Overload retVal="" descr="Decode common content-transfer-encodings (base64, quopri, uuencode).">
				<Param name="input" />
				<Param name="output" />
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.decodetab" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.encode" func="yes">
			<Overload retVal="" descr="Encode common content-transfer-encodings (base64, quopri, uuencode).">
				<Param name="input" />
				<Param name="output" />
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.encodetab" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.filterwarnings" func="yes">
			<Overload retVal="" descr="Insert an entry into the list of warnings filters (at the front).&#10;&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'message' -- a regex that the warning message must match&#10;'category' -- a class that the warning must be a subclass of&#10;'module' -- a regex that the module name must match&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[message" />
				<Param name="[category=<type 'exceptions.Warning'>" />
				<Param name="[module" />
				<Param name="[lineno=0" />
				<Param name="[append=0]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.pipethrough" />
		<KeyWord name="mimetools.pipeto" />
		<KeyWord name="mimetools.uudecode_pipe" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetools.warnpy3k" func="yes">
			<Overload retVal="" descr="Issue a deprecation warning for Python 3.x related changes.&#10;&#10;Warnings are omitted unless Python is started with the -3 option.">
				<Param name="message" />
				<Param name="[category=None" />
				<Param name="[stacklevel=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes" func="yes">
			<Overload retVal="" descr="Guess the MIME type of a file.&#10;&#10;This module defines two useful functions:&#10;&#10;guess_type(url, strict=1) -- guess the MIME type and encoding of a URL.&#10;&#10;guess_extension(type, strict=1) -- guess the extension for a given MIME type.&#10;&#10;It also contains the following, for tuning the behavior:&#10;&#10;Data:&#10;&#10;knownfiles -- list of files to parse&#10;inited -- flag set when init() has been called&#10;suffix_map -- dictionary mapping suffixes to suffixes&#10;encodings_map -- dictionary mapping suffixes to encodings&#10;types_map -- dictionary mapping suffixes to types&#10;&#10;Functions:&#10;&#10;init([files]) -- parse a list of files, default knownfiles (on Windows, the&#10;  default values are taken from the registry)&#10;read_mime_types(file) -- parse one file, return a dictionary or None">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.add_type" func="yes">
			<Overload retVal="" descr="Add a mapping between a type and an extension.&#10;&#10;When the extension is already known, the new&#10;type will replace the old one. When the type&#10;is already known the extension will be added&#10;to the list of known extensions.&#10;&#10;If strict is true, information will be added to&#10;list of standard types, else to the list of non-standard&#10;types.">
				<Param name="type" />
				<Param name="ext" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.common_types" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.encodings_map" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.guess_all_extensions" func="yes">
			<Overload retVal="" descr="Guess the extensions for a file based on its MIME type.&#10;&#10;Return value is a list of strings giving the possible filename&#10;extensions, including the leading dot ('.').  The extension is not&#10;guaranteed to have been associated with any particular data&#10;stream, but would be mapped to the MIME type `type' by&#10;guess_type().  If no extension can be guessed for `type', None&#10;is returned.&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="type" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.guess_extension" func="yes">
			<Overload retVal="" descr="Guess the extension for a file based on its MIME type.&#10;&#10;Return value is a string giving a filename extension, including the&#10;leading dot ('.').  The extension is not guaranteed to have been&#10;associated with any particular data stream, but would be mapped to the&#10;MIME type `type' by guess_type().  If no extension can be guessed for&#10;`type', None is returned.&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="type" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.guess_type" func="yes">
			<Overload retVal="" descr="Guess the type of a file based on its URL.&#10;&#10;Return value is a tuple (type, encoding) where type is None if the&#10;type can't be guessed (no or unknown suffix) or a string of the&#10;form type/subtype, usable for a MIME Content-type header; and&#10;encoding is None for no encoding or the name of the program used&#10;to encode (e.g. compress or gzip).  The mappings are table&#10;driven.  Encoding suffixes are case sensitive; type suffixes are&#10;first tried case sensitive, then case insensitive.&#10;&#10;The suffixes .tgz, .taz and .tz (case sensitive!) are all mapped&#10;to &quot;.tar.gz&quot;.  (This is table-driven too, using the dictionary&#10;suffix_map).&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found, but&#10;non-standard types.">
				<Param name="url" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.init" func="yes">
			<Overload retVal="" descr=>
				<Param name="[files=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.inited" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.knownfiles" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.read_mime_types" />
		<KeyWord name="mimetypes.suffix_map" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.types_map" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify" func="yes">
			<Overload retVal="" descr="Mimification and unmimification of mail messages.&#10;&#10;Decode quoted-printable parts of a mail message or encode using&#10;quoted-printable.&#10;&#10;Usage:&#10;        mimify(input, output)&#10;        unmimify(input, output, decode_base64 = 0)&#10;to encode and decode respectively.  Input and output may be the name&#10;of a file or an open file object.  Only a readline() method is used&#10;on the input file, only a write() method is used on the output file.&#10;When using file names, the input and output file names may be the&#10;same.&#10;&#10;Interactive usage:&#10;        mimify.py -e [infile [outfile]]&#10;        mimify.py -d [infile [outfile]]&#10;to encode and decode respectively.  Infile defaults to standard&#10;input and outfile to standard output.">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.CHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.File" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.HeaderFile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.MAXLEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.QUOTE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.base64_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.chrset" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.cte" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.he" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.iso_char" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_char" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_code" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_decode" func="yes">
			<Overload retVal="" descr="Decode a single line of quoted-printable text to 8bit.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_decode_header" func="yes">
			<Overload retVal="" descr="Decode a header line to 8bit.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_encode" func="yes">
			<Overload retVal="" descr="Code a single line as quoted-printable.&#10;If header is set, quote some extra characters.">
				<Param name="line" />
				<Param name="header" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_encode_header" func="yes">
			<Overload retVal="" descr="Code a single header line as quoted-printable.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_head" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_header" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mime_header_char" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mimify" func="yes">
			<Overload retVal="" descr="Convert 8bit parts of a MIME mail message to quoted-printable.">
				<Param name="infile" />
				<Param name="outfile" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mimify_part" func="yes">
			<Overload retVal="" descr="Convert an 8bit part of a MIME mail message to quoted-printable.">
				<Param name="ifile" />
				<Param name="ofile" />
				<Param name="is_mime" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mp" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.mv" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.qp" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.repl" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.unmimify" func="yes">
			<Overload retVal="" descr="Convert quoted-printable parts of a MIME mail message to 8bit.">
				<Param name="infile" />
				<Param name="outfile" />
				<Param name="[decode_base64=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify.unmimify_part" func="yes">
			<Overload retVal="" descr="Convert a quoted-printable part of a MIME mail message to 8bit.">
				<Param name="ifile" />
				<Param name="ofile" />
				<Param name="[decode_base64=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimify_part" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="min" func="yes">
			<Overload retVal="" descr="min(iterable[, key=func]) -&gt; value&#10;min(a, b, c, ...[, key=func]) -&gt; value&#10;&#10;With a single iterable argument, return its smallest item.&#10;With two or more arguments, return the smallest argument.">
			</Overload>
		</KeyWord>
		<KeyWord name="min_mag" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="minus" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="mirrored" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="mk2arg" func="yes">
			<Overload retVal="" descr="Function of commands">
			</Overload>
		</KeyWord>
		<KeyWord name="mkarg" func="yes">
			<Overload retVal="" descr="Function of commands">
			</Overload>
		</KeyWord>
		<KeyWord name="mkdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="mkdtemp" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="mkstemp" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="mktemp" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="mktime_tz" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="mloads" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="mode" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="modf" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="modname" func="yes">
			<Overload retVal="" descr="Function of trace">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder" func="yes">
			<Overload retVal="" descr="Find modules used by a script, using introspection.">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.AddPackagePath" />
		<KeyWord name="modulefinder.HAVE_ARGUMENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.IMPORT_NAME" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.LOAD_CONST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.Module" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.READ_MODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ReplacePackage" />
		<KeyWord name="modulefinder.STORE_GLOBAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.STORE_NAME" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.STORE_OPS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.generators" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.test" />
		<KeyWord name="month" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthcalendar" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthdatescalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthdays2calendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthdayscalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthrange" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="most_common" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="move" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib" />
		<KeyWord name="msilib.AMD64" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Binary" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.CAB" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Control" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.CreateRecord" func="yes">
			<Overload retVal="" descr="OpenDatabase(name, flags) -&gt; dbobj&#10;Wraps MsiCreateRecord">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Directory" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.FCICreate" func="yes">
			<Overload retVal="" descr="fcicreate(cabname,files) -&gt; None">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Feature" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSICOLINFO_TYPES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_CREATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_CREATEDIRECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_DIRECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_PATCHFILE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_TRANSACT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIError" />
		<KeyWord name="msilib.MSIError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_ASSIGN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_DELETE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_INSERT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_INSERT_TEMPORARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_MERGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_REPLACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_SEEK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_UPDATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE_DELETE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE_FIELD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE_NEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.OpenDatabase" func="yes">
			<Overload retVal="" descr="OpenDatabase(name, flags) -&gt; dbobj&#10;Wraps MsiOpenDatabase">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_APPNAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_AUTHOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_CHARCOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_CODEPAGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_COMMENTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_CREATE_DTM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_KEYWORDS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_LASTAUTHOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_LASTPRINTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_LASTSAVE_DTM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_PAGECOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_REVNUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_SECURITY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_SUBJECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_TITLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_WORDCOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.RadioButtonGroup" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Table" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.UuidCreate" func="yes">
			<Overload retVal="" descr="UuidCreate() -&gt; string">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Win64" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.add_data" />
		<KeyWord name="msilib.add_stream" />
		<KeyWord name="msilib.add_tables" />
		<KeyWord name="msilib.change_sequence" func="yes">
			<Overload retVal="" descr="Change the sequence number of an action in a sequence list">
				<Param name="seq" />
				<Param name="action" />
				<Param name="[seqno=msilib._Unspecified" />
				<Param name="[cond=msilib._Unspecified]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.datasizemask" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.gen_uuid" />
		<KeyWord name="msilib.init_database" />
		<KeyWord name="msilib.knownbits" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.make_id" />
		<KeyWord name="msilib.type_binary" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_key" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_localizable" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_nullable" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_short" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_string" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_valid" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.typemask" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="multifile" func="yes">
			<Overload retVal="" descr='A readline()-style interface to the parts of a multipart message.&#10;&#10;The MultiFile class makes each part of a multipart message "feel" like&#10;an ordinary file, as long as you use fp.readline().  Allows recursive&#10;use, for nested multipart messages.  Probably best used together&#10;with module mimetools.&#10;&#10;Suggested use:&#10;&#10;real_fp = open(...)&#10;fp = MultiFile(real_fp)&#10;&#10;"read some lines from fp"&#10;fp.push(separator)&#10;while 1:&#10;        "read lines from fp until it returns an empty string" (A)&#10;        if not fp.next(): break&#10;fp.pop()&#10;"read remaining lines from fp until it returns an empty string"&#10;&#10;The latter sequence may be used recursively at (A).&#10;It is also allowed to use multiple push()...pop() sequences.&#10;&#10;If seekable is given as 0, the class code will not do the bookkeeping&#10;it normally attempts in order to make seeks relative to the beginning of the&#10;current file part.  This may be useful when using MultiFile with a non-&#10;seekable stream object.'>
			</Overload>
		</KeyWord>
		<KeyWord name="multifile.Error" />
		<KeyWord name="multifile.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multifile.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multifile.MultiFile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiply" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing" />
		<KeyWord name="multiprocessing.Array" func="yes">
			<Overload retVal="" descr="Returns a synchronized shared array">
				<Param name="typecode_or_type" />
				<Param name="size_or_initializer" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.AuthenticationError" />
		<KeyWord name="multiprocessing.AuthenticationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.AuthenticationError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="Returns a bounded semaphore object">
				<Param name="[value=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BufferTooShort" />
		<KeyWord name="multiprocessing.BufferTooShort.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BufferTooShort.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Condition" func="yes">
			<Overload retVal="" descr="Returns a condition object">
				<Param name="[lock=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Event" func="yes">
			<Overload retVal="" descr="Returns an event object">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.JoinableQueue" func="yes">
			<Overload retVal="" descr="Returns a queue object">
				<Param name="[maxsize=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Lock" func="yes">
			<Overload retVal="" descr="Returns a non-recursive lock object">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Manager" func="yes">
			<Overload retVal="" descr="Returns a manager associated with a running server process&#10;&#10;The managers methods such as `Lock()`, `Condition()` and `Queue()`&#10;can be used to create shared objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Pipe" func="yes">
			<Overload retVal="" descr="Returns two connection object connected by a pipe">
				<Param name="[duplex=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Pool" func="yes">
			<Overload retVal="" descr="Returns a process pool object">
				<Param name="[processes=None" />
				<Param name="[initializer=None" />
				<Param name="[initargs=()" />
				<Param name="[maxtasksperchild=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process" func="yes">
			<Overload retVal="" descr="Process objects represent activity that is run in a separate process&#10;&#10;The class is analagous to `threading.Thread`">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.authkey" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.exitcode" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.is_alive" func="yes">
			<Overload retVal="" descr="Return whether process is alive">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.join" func="yes">
			<Overload retVal="" descr="Wait until child process terminates">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.pid" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.run" func="yes">
			<Overload retVal="" descr="Method to be run in sub-process; can be overridden in sub-class">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.start" func="yes">
			<Overload retVal="" descr="Start child process">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.terminate" func="yes">
			<Overload retVal="" descr="Terminate process; sends SIGTERM signal or uses TerminateProcess()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.ProcessError" />
		<KeyWord name="multiprocessing.ProcessError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.ProcessError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Queue" func="yes">
			<Overload retVal="" descr="Returns a queue object">
				<Param name="[maxsize=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.RLock" func="yes">
			<Overload retVal="" descr="Returns a recursive lock object">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.RawArray" func="yes">
			<Overload retVal="" descr="Returns a shared array">
				<Param name="typecode_or_type" />
				<Param name="size_or_initializer" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.RawValue" func="yes">
			<Overload retVal="" descr="Returns a shared object">
				<Param name="typecode_or_type" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.SUBDEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.SUBWARNING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Semaphore" func="yes">
			<Overload retVal="" descr="Returns a semaphore object">
				<Param name="[value=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.TimeoutError" />
		<KeyWord name="multiprocessing.TimeoutError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.TimeoutError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Value" func="yes">
			<Overload retVal="" descr="Returns a synchronized shared object">
				<Param name="typecode_or_type" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.active_children" func="yes">
			<Overload retVal="" descr="Return list of process objects corresponding to live child processes">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.allow_connection_pickling" func="yes">
			<Overload retVal="" descr="Install support for sending connections and sockets between processes">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.cpu_count" func="yes">
			<Overload retVal="" descr="Returns the number of CPUs in the system">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.current_process" func="yes">
			<Overload retVal="" descr="Return process object representing the current process">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.freeze_support" func="yes">
			<Overload retVal="" descr="Check whether this is a fake forked process in a frozen executable.&#10;If so then run code specified by commandline and exit.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.get_logger" func="yes">
			<Overload retVal="" descr="Return package logger -- if it does not already exist then it is created">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.log_to_stderr" func="yes">
			<Overload retVal="" descr="Turn on logging and add a handler which prints to stderr">
				<Param name="[level=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.set_executable" func="yes">
			<Overload retVal="" descr="Sets the path to a python.exe or pythonw.exe binary used to run&#10;child processes on Windows instead of sys.executable.&#10;Useful for people embedding Python.">
				<Param name="executable" />
			</Overload>
		</KeyWord>
		<KeyWord name="mutex" func="yes">
			<Overload retVal="" descr="Mutual exclusion -- for use with module sched&#10;&#10;A mutex has two pieces of state -- a 'locked' bit and a queue.&#10;When the mutex is not locked, the queue is empty.&#10;Otherwise, the queue contains 0 or more (function, argument) pairs&#10;representing functions (or methods) waiting to acquire the lock.&#10;When the mutex is unlocked while the queue is not empty,&#10;the first queue entry is removed and its function(argument) pair called,&#10;implying it now has the lock.&#10;&#10;Of course, no multi-threading is implied -- hence the funny interface&#10;for lock, where a function is called once the lock is aquired.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;Build an ordered collection with optimized access from its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="mutex.mutex" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="name" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="namedtuple" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="namelist" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="names" func="yes">
			<Overload retVal="" descr="Function of tkFont">
			</Overload>
		</KeyWord>
		<KeyWord name="nametofont" func="yes">
			<Overload retVal="" descr="Function of tkFont">
			</Overload>
		</KeyWord>
		<KeyWord name="nametowidget" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="ndiff" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="needsquoting" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="nested" func="yes">
			<Overload retVal="" descr="Function of contextlib">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc" func="yes">
			<Overload retVal="" descr="An object-oriented interface to .netrc files.">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.NetrcParseError" func="yes">
			<Overload retVal="" descr="Exception raised on syntax errors in the .netrc file.">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.NetrcParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.NetrcParseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.netrc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="new" func="yes">
			<Overload retVal="" descr="Create new objects of various types.  Deprecated.&#10;&#10;This module is no longer required except for backward compatibility.&#10;Objects of most types can now be created by calling the type object.">
			</Overload>
		</KeyWord>
		<KeyWord name="new.classobj" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.code.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.function.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.instance" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="new.instance.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="new.instancemethod" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="new.instancemethod.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.instancemethod.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.instancemethod.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="new.module" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="next_minus" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="next_plus" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="next_toward" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="nextfile" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="ngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="nlargest" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib" func="yes">
			<Overload retVal="" descr="An NNTP client class based on RFC 977: Network News Transfer Protocol.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; from nntplib import NNTP&#10;&gt;&gt;&gt; s = NNTP('news')&#10;&gt;&gt;&gt; resp, count, first, last, name = s.group('comp.lang.python')&#10;&gt;&gt;&gt; print 'Group', name, 'has', count, 'articles, range', first, 'to', last&#10;Group comp.lang.python has 51 articles, range 5770 to 5821&#10;&gt;&gt;&gt; resp, subs = s.xhdr('subject', first + '-' + last)&#10;&gt;&gt;&gt; resp = s.quit()&#10;&gt;&gt;&gt;&#10;&#10;Here 'resp' is the server response line.&#10;Error responses are turned into exceptions.&#10;&#10;To post an article from a file:&#10;&gt;&gt;&gt; f = open(filename, 'r') # file containing article, including header&#10;&gt;&gt;&gt; resp = s.post(f)&#10;&gt;&gt;&gt;&#10;&#10;For descriptions of all methods, read the comments in the code below.&#10;Note that all arguments and return values representing article numbers&#10;are strings, not numbers, since they are rarely used for calculations.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.LONGRESP" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPDataError" func="yes">
			<Overload retVal="" descr="Error in response data">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPDataError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPDataError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPError" func="yes">
			<Overload retVal="" descr="Base class for all nntplib exceptions">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPPermanentError" func="yes">
			<Overload retVal="" descr="5xx errors">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPPermanentError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPPermanentError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPProtocolError" func="yes">
			<Overload retVal="" descr="Response does not begin with [1-5]">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPProtocolError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPProtocolError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPReplyError" func="yes">
			<Overload retVal="" descr="Unexpected [123]xx reply">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPReplyError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPReplyError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPTemporaryError" func="yes">
			<Overload retVal="" descr="4xx errors">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPTemporaryError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPTemporaryError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_data" func="yes">
			<Overload retVal="" descr="Error in response data">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_data.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_data.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_perm" func="yes">
			<Overload retVal="" descr="5xx errors">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_perm.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_perm.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_proto" func="yes">
			<Overload retVal="" descr="Response does not begin with [1-5]">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_proto.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_proto.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_reply" func="yes">
			<Overload retVal="" descr="Unexpected [123]xx reply">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_reply.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_reply.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_temp" func="yes">
			<Overload retVal="" descr="4xx errors">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_temp.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.error_temp.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nobody_uid" func="yes">
			<Overload retVal="" descr="Function of CGIHTTPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="node" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="noheaders" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="nolog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="normalize" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="normalize_encoding" func="yes">
			<Overload retVal="" descr="Function of encodings">
			</Overload>
		</KeyWord>
		<KeyWord name="normalvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="normcase" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="normpath" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="not" />
		<KeyWord name="now" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="nr_of_items" func="yes">
			<Overload retVal="" descr="Function of turtle.Tbuffer">
			</Overload>
		</KeyWord>
		<KeyWord name="nsmallest" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="nti" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="ntohl" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="ntohs" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath" func="yes">
			<Overload retVal="" descr="Common pathname manipulations, WindowsNT/95 version.&#10;&#10;Instead of importing this module directly, import os and refer to this&#10;module as os.path.">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.abspath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.altsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.basename" func="yes">
			<Overload retVal="" descr="Returns the final component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.dirname" func="yes">
			<Overload retVal="" descr="Returns the directory component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.expanduser" func="yes">
			<Overload retVal="" descr="Expand ~ and ~user constructs.&#10;&#10;If user or $HOME is unknown, do nothing.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.expandvars" func="yes">
			<Overload retVal="" descr="Expand shell variables of the forms $var, ${var} and %var%.&#10;&#10;Unknown variables are left unchanged.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.isabs" func="yes">
			<Overload retVal="" descr="Test whether a path is absolute">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.islink" func="yes">
			<Overload retVal="" descr="Test for symbolic link.&#10;On WindowsNT/95 and OS/2 always returns false">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.ismount" func="yes">
			<Overload retVal="" descr="Test whether a path is a mount point (defined as root of drive)">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.join" func="yes">
			<Overload retVal="" descr='Join two or more pathname components, inserting "\" as needed.'>
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.normcase" func="yes">
			<Overload retVal="" descr="Normalize case of pathname.&#10;&#10;Makes all characters lowercase and all slashes into backslashes.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize path, eliminating double slashes, etc.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.realpath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.relpath" func="yes">
			<Overload retVal="" descr="Return a relative version of a path">
				<Param name="path" />
				<Param name="[start=.]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.split" func="yes">
			<Overload retVal="" descr="Split a pathname.&#10;&#10;Return tuple (head, tail) where tail is everything after the final slash.&#10;Either part may be empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.splitdrive" func="yes">
			<Overload retVal="" descr='Split a pathname into drive/UNC sharepoint and relative path specifiers.&#10;Returns a 2-tuple (drive_or_unc, path); either part may be empty.&#10;&#10;If you assign&#10;    result = splitdrive(p)&#10;It is always true that:&#10;    result[0] + result[1] == p&#10;&#10;If the path contained a drive letter, drive_or_unc will contain everything&#10;up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")&#10;&#10;If the path contained a UNC path, the drive_or_unc will contain the host name&#10;and share up to but not including the fourth directory separator character.&#10;e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")&#10;&#10;Paths cannot contain both a drive letter and a UNC path.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.splitunc" func="yes">
			<Overload retVal="" descr="Split a pathname into UNC mount point and relative path specifiers.&#10;&#10;Return a 2-tuple (unc, rest); either part may be empty.&#10;If unc is not empty, it has the form '//host/mount' (or similar&#10;using backslashes).  unc+rest is always the input path.&#10;Paths containing drive letters never have an UNC part.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.supports_unicode_filenames" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.walk" func="yes">
			<Overload retVal="" descr="Directory tree walk with callback function.&#10;&#10;For each directory in the directory tree rooted at top (including top&#10;itself, but excluding '.' and '..'), call func(arg, dirname, fnames).&#10;dirname is the name of the directory, and fnames a list of the names of&#10;the files and subdirectories in dirname (excluding '.' and '..').  func&#10;may modify the fnames list in-place (e.g. via del or slice assignment),&#10;and walk will only recurse into the subdirectories whose names remain in&#10;fnames; this can be used to implement a filter, or to impose a specific&#10;order of visiting.  No semantics are defined for, or required of, arg,&#10;beyond that arg is always passed to func.  It can be used, e.g., to pass&#10;a filename pattern, or a mutable object designed to accumulate&#10;statistics.  Passing None for arg is common.">
				<Param name="top" />
				<Param name="func" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="nts" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="nturl2path" func="yes">
			<Overload retVal="" descr="Convert a NT pathname to a file URL and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="nturl2path.pathname2url" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a file system path to a relative URL&#10;of the 'file' scheme; not recommended for general use.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="nturl2path.url2pathname" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a relative URL of the 'file' scheme&#10;to a file system path; not recommended for general use.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="number_class" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers" func="yes">
			<Overload retVal="" descr="Abstract Base Classes (ABCs) for numbers, according to PEP 3141.&#10;&#10;TODO: Fill out more detailed documentation on the operators.">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.ABCMeta" func="yes">
			<Overload retVal="" descr="Metaclass for defining Abstract Base Classes (ABCs).&#10;&#10;Use this metaclass to create an ABC.  An ABC can be subclassed&#10;directly, and then acts as a mix-in class.  You can also register&#10;unrelated concrete classes (even built-in classes) and unrelated&#10;ABCs as 'virtual subclasses' -- these and their descendants will&#10;be considered subclasses of the registering ABC by the built-in&#10;issubclass() function, but the registering ABC won't show up in&#10;their MRO (Method Resolution Order) nor will method&#10;implementations defined by the registering ABC be callable (not&#10;even via super()).">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.ABCMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.ABCMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Complex" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Integral" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Number" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Rational" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Real" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract methods.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract methods are overridden.&#10;The abstract methods can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C:&#10;        __metaclass__ = ABCMeta&#10;        @abstractmethod&#10;        def my_abstract_method(self, ...):&#10;            ...">
				<Param name="funcobj" />
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract properties.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract properties are overridden.&#10;The abstract properties can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C:&#10;        __metaclass__ = ABCMeta&#10;        @abstractproperty&#10;        def my_abstract_property(self):&#10;            ...&#10;&#10;This defines a read-only property; you can also define a read-write&#10;abstract property using the 'long' form of property declaration:&#10;&#10;    class C:&#10;        __metaclass__ = ABCMeta&#10;        def getx(self): ...&#10;        def setx(self, value): ...&#10;        x = abstractproperty(getx, setx)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty.deleter" func="yes">
			<Overload retVal="" descr="Descriptor to change the deleter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty.fdel" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty.fget" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty.fset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty.getter" func="yes">
			<Overload retVal="" descr="Descriptor to change the getter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractproperty.setter" func="yes">
			<Overload retVal="" descr="Descriptor to change the setter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.division" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="numeric" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="object" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="oct" func="yes">
			<Overload retVal="" descr="oct(number) -&gt; string&#10;&#10;Return the octal representation of an integer or long integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="offset_from_tz_string" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="onclick" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="ondrag" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="onkey" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="onrelease" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="onscreenclick" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="ontimer" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode" func="yes">
			<Overload retVal="" descr="opcode module - potentially shared between dis and other modules which&#10;operate on bytecodes (e.g. peephole optimizers).">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.EXTENDED_ARG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.HAVE_ARGUMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.cmp_op" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hascompare" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasconst" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasfree" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasjabs" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasjrel" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.haslocal" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.opmap" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.opname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="open" func="yes">
			<Overload retVal="" descr="open(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file using the file() type, returns a file object.  This is the&#10;preferred way to open a file.  See file.__doc__ for further information.">
			</Overload>
		</KeyWord>
		<KeyWord name="open_new" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="open_new_tab" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="opendir" func="yes">
			<Overload retVal="" descr="Function of dircache">
			</Overload>
		</KeyWord>
		<KeyWord name="openfp" func="yes">
			<Overload retVal="" descr="Function of sunau">
			</Overload>
		</KeyWord>
		<KeyWord name="optimize" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="option_add" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="option_clear" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="option_get" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="option_readfile" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse" func="yes">
			<Overload retVal="" descr="A powerful, extensible, and easy-to-use option parser.&#10;&#10;By Greg Ward &lt;gward@python.net&gt;&#10;&#10;Originally distributed as Optik.&#10;&#10;For support, use the optik-users@lists.sourceforge.net mailing list&#10;(http://lists.sourceforge.net/lists/listinfo/optik-users).&#10;&#10;Simple usage example:&#10;&#10;   from optparse import OptionParser&#10;&#10;   parser = OptionParser()&#10;   parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;,&#10;                     help=&quot;write report to FILE&quot;, metavar=&quot;FILE&quot;)&#10;   parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;,&#10;                     action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=True,&#10;                     help=&quot;don't print status messages to stdout&quot;)&#10;&#10;   (options, args) = parser.parse_args()">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.AmbiguousOptionError" func="yes">
			<Overload retVal="" descr="Raised if an ambiguous option is seen on the command line.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.AmbiguousOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.AmbiguousOptionError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.BadOptionError" func="yes">
			<Overload retVal="" descr="Raised if an invalid option is seen on the command line.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.BadOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.BadOptionError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.HelpFormatter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.IndentedHelpFormatter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.NO_DEFAULT" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptParseError" />
		<KeyWord name="optparse.OptParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptParseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionConflictError" func="yes">
			<Overload retVal="" descr="Raised if conflicting options are added to an OptionParser.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionConflictError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionConflictError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionContainer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionError" func="yes">
			<Overload retVal="" descr="Raised if an Option instance is created with invalid or&#10;inconsistent arguments.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionGroup" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionValueError" func="yes">
			<Overload retVal="" descr="Raised if an invalid option value is encountered on the command&#10;line.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionValueError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionValueError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.SUPPRESS_HELP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.SUPPRESS_USAGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.TitledHelpFormatter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Values" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.check_builtin" />
		<KeyWord name="optparse.check_choice" />
		<KeyWord name="optparse.gettext" />
		<KeyWord name="optparse.isbasestring" />
		<KeyWord name="optparse.make_option" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="or" />
		<KeyWord name="ord" func="yes">
			<Overload retVal="" descr="ord(c) -&gt; integer&#10;&#10;Return the integer ordinal of a one-character string.">
			</Overload>
		</KeyWord>
		<KeyWord name="os" func="yes">
			<Overload retVal="" descr="OS routines for NT or Posix depending on what system we're on.&#10;&#10;This exports:&#10;  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.&#10;  - os.path is one of the modules posixpath, or ntpath&#10;  - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos'&#10;  - os.curdir is a string representing the current directory ('.' or ':')&#10;  - os.pardir is a string representing the parent directory ('..' or '::')&#10;  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')&#10;  - os.extsep is the extension separator ('.' or '/')&#10;  - os.altsep is the alternate pathname separator (None or '/')&#10;  - os.pathsep is the component separator used in $PATH etc&#10;  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')&#10;  - os.defpath is the default search path for executables&#10;  - os.devnull is the file path of the null device ('/dev/null', etc.)&#10;&#10;Programs that import and use 'os' stand a better chance of being&#10;portable between different platforms.  Of course, they must then&#10;only use functions that are defined by all platforms (e.g., unlink&#10;and opendir), and leave all pathname manipulation to os.path&#10;(e.g., split and join).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_BINARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_CREAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_EXCL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_NOINHERIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_RANDOM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_RDWR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_SEQUENTIAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_SHORT_LIVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_TEMPORARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_TEXT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_TRUNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_WRONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_DETACH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_NOWAIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_NOWAITO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_OVERLAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.R_OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.SEEK_CUR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.SEEK_END" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.TMP_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.W_OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.X_OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.abort" func="yes">
			<Overload retVal="" descr="abort() -&gt; does not return!&#10;&#10;Abort the interpreter immediately.  This 'dumps core' or otherwise fails&#10;in the hardest way possible on the hosting operating system.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.access" func="yes">
			<Overload retVal="" descr="access(path, mode) -&gt; True if granted, False otherwise&#10;&#10;Use the real uid/gid to test for access to a path.  Note that most&#10;operations will use the effective uid/gid, therefore this routine can&#10;be used in a suid/sgid environment to test if the invoking user has the&#10;specified access to the path.  The mode argument can be F_OK to test&#10;existence, or the inclusive-OR of R_OK, W_OK, and X_OK.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.altsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.chdir" func="yes">
			<Overload retVal="" descr="chdir(path)&#10;&#10;Change the current working directory to the specified path.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.chmod" func="yes">
			<Overload retVal="" descr="chmod(path, mode)&#10;&#10;Change the access permissions of a file.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.close" func="yes">
			<Overload retVal="" descr="close(fd)&#10;&#10;Close a file descriptor (for low level IO).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.closerange" func="yes">
			<Overload retVal="" descr="closerange(fd_low, fd_high)&#10;&#10;Closes all file descriptors in [fd_low, fd_high), ignoring errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.dup" func="yes">
			<Overload retVal="" descr="dup(fd) -&gt; fd2&#10;&#10;Return a duplicate of a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.dup2" func="yes">
			<Overload retVal="" descr="dup2(old_fd, new_fd)&#10;&#10;Duplicate file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.environ" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error" func="yes">
			<Overload retVal="" descr="OS system call failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.execl" func="yes">
			<Overload retVal="" descr="execl(file, *args)&#10;&#10;Execute the executable file with argument list args, replacing the&#10;current process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execle" func="yes">
			<Overload retVal="" descr="execle(file, *args, env)&#10;&#10;Execute the executable file with argument list args and&#10;environment env, replacing the current process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execlp" func="yes">
			<Overload retVal="" descr="execlp(file, *args)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args, replacing the current process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execlpe" func="yes">
			<Overload retVal="" descr="execlpe(file, *args, env)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args and environment env, replacing the current&#10;process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execv" func="yes">
			<Overload retVal="" descr="execv(path, args)&#10;&#10;Execute an executable path with arguments, replacing current process.&#10;&#10;    path: path of executable file&#10;    args: tuple or list of strings">
			</Overload>
		</KeyWord>
		<KeyWord name="os.execve" func="yes">
			<Overload retVal="" descr="execve(path, args, env)&#10;&#10;Execute a path with arguments and environment, replacing current process.&#10;&#10;    path: path of executable file&#10;    args: tuple or list of arguments&#10;    env: dictionary of strings mapping to strings">
			</Overload>
		</KeyWord>
		<KeyWord name="os.execvp" func="yes">
			<Overload retVal="" descr="execvp(file, args)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args, replacing the current process.&#10;args may be a list or tuple of strings.">
				<Param name="file" />
				<Param name="args" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execvpe" func="yes">
			<Overload retVal="" descr="execvpe(file, args, env)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args and environment env , replacing the&#10;current process.&#10;args may be a list or tuple of strings.">
				<Param name="file" />
				<Param name="args" />
				<Param name="env" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.fdopen" func="yes">
			<Overload retVal="" descr="fdopen(fd [, mode='r' [, bufsize]]) -&gt; file_object&#10;&#10;Return an open file object connected to a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.fstat" func="yes">
			<Overload retVal="" descr="fstat(fd) -&gt; stat result&#10;&#10;Like stat(), but for an open file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.fsync" func="yes">
			<Overload retVal="" descr="fsync(fildes)&#10;&#10;force write of file with filedescriptor to disk.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getcwd" func="yes">
			<Overload retVal="" descr="getcwd() -&gt; path&#10;&#10;Return a string representing the current working directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getcwdu" func="yes">
			<Overload retVal="" descr="getcwdu() -&gt; path&#10;&#10;Return a unicode string representing the current working directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getenv" func="yes">
			<Overload retVal="" descr="Get an environment variable, return None if it doesn't exist.&#10;The optional second argument can specify an alternate default.">
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.getpid" func="yes">
			<Overload retVal="" descr="getpid() -&gt; pid&#10;&#10;Return the current process id">
			</Overload>
		</KeyWord>
		<KeyWord name="os.isatty" func="yes">
			<Overload retVal="" descr="isatty(fd) -&gt; bool&#10;&#10;Return True if the file descriptor 'fd' is an open file descriptor&#10;connected to the slave end of a terminal.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.kill" func="yes">
			<Overload retVal="" descr="kill(pid, sig)&#10;&#10;Kill a process with a signal.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.linesep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.listdir" func="yes">
			<Overload retVal="" descr="listdir(path) -&gt; list_of_strings&#10;&#10;Return a list containing the names of the entries in the directory.&#10;&#10;    path: path of directory to list&#10;&#10;The list is in arbitrary order.  It does not include the special&#10;entries '.' and '..' even if they are present in the directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.lseek" func="yes">
			<Overload retVal="" descr="lseek(fd, pos, how) -&gt; newpos&#10;&#10;Set the current position of a file descriptor.&#10;Return the new cursor position in bytes, starting from the beginning.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.lstat" func="yes">
			<Overload retVal="" descr="lstat(path) -&gt; stat result&#10;&#10;Like stat(path), but do not follow symbolic links.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.makedirs" func="yes">
			<Overload retVal="" descr="makedirs(path [, mode=0777])&#10;&#10;Super-mkdir; create a leaf directory and all intermediate ones.&#10;Works like mkdir, except that any intermediate path segment (not&#10;just the rightmost) will be created if it does not exist.  This is&#10;recursive.">
				<Param name="name" />
				<Param name="[mode=511]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.mkdir" func="yes">
			<Overload retVal="" descr="mkdir(path [, mode=0777])&#10;&#10;Create a directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.open" func="yes">
			<Overload retVal="" descr="open(filename, flag [, mode=0777]) -&gt; fd&#10;&#10;Open a file (for low level IO).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.pipe" func="yes">
			<Overload retVal="" descr="pipe() -&gt; (read_end, write_end)&#10;&#10;Create a pipe.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.popen" func="yes">
			<Overload retVal="" descr="popen(command [, mode='r' [, bufsize]]) -&gt; pipe&#10;&#10;Open a pipe to/from a command returning a file object.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.popen2" />
		<KeyWord name="os.popen3" />
		<KeyWord name="os.popen4" />
		<KeyWord name="os.putenv" func="yes">
			<Overload retVal="" descr="putenv(key, value)&#10;&#10;Change or add an environment variable.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.read" func="yes">
			<Overload retVal="" descr="read(fd, buffersize) -&gt; string&#10;&#10;Read a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.remove" func="yes">
			<Overload retVal="" descr="remove(path)&#10;&#10;Remove a file (same as unlink(path)).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.removedirs" func="yes">
			<Overload retVal="" descr="removedirs(path)&#10;&#10;Super-rmdir; remove a leaf directory and all empty intermediate&#10;ones.  Works like rmdir except that, if the leaf directory is&#10;successfully removed, directories corresponding to rightmost path&#10;segments will be pruned away until either the whole path is&#10;consumed or an error occurs.  Errors during this latter phase are&#10;ignored -- they generally mean that a directory was not empty.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.rename" func="yes">
			<Overload retVal="" descr="rename(old, new)&#10;&#10;Rename a file or directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.renames" func="yes">
			<Overload retVal="" descr="renames(old, new)&#10;&#10;Super-rename; create directories as necessary and delete any left&#10;empty.  Works like rename, except creation of any intermediate&#10;directories needed to make the new pathname good is attempted&#10;first.  After the rename, directories corresponding to rightmost&#10;path segments of the old name will be pruned until either the&#10;whole path is consumed or a nonempty directory is found.&#10;&#10;Note: this function can fail with the new directory structure made&#10;if you lack permissions needed to unlink the leaf directory or&#10;file.">
				<Param name="old" />
				<Param name="new" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.rmdir" func="yes">
			<Overload retVal="" descr="rmdir(path)&#10;&#10;Remove a directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnl" func="yes">
			<Overload retVal="" descr="spawnl(mode, file, *args) -&gt; integer&#10;&#10;Execute file with arguments from args in a subprocess.&#10;If mode == P_NOWAIT return the pid of the process.&#10;If mode == P_WAIT return the process's exit code if it exits normally;&#10;otherwise return -SIG, where SIG is the signal that killed it.">
				<Param name="mode" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnle" func="yes">
			<Overload retVal="" descr="spawnle(mode, file, *args, env) -&gt; integer&#10;&#10;Execute file with arguments from args in a subprocess with the&#10;supplied environment.&#10;If mode == P_NOWAIT return the pid of the process.&#10;If mode == P_WAIT return the process's exit code if it exits normally;&#10;otherwise return -SIG, where SIG is the signal that killed it.">
				<Param name="mode" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnv" func="yes">
			<Overload retVal="" descr="spawnv(mode, path, args)&#10;&#10;Execute the program 'path' in a new process.&#10;&#10;    mode: mode of process creation&#10;    path: path of executable file&#10;    args: tuple or list of strings">
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnve" func="yes">
			<Overload retVal="" descr="spawnve(mode, path, args, env)&#10;&#10;Execute the program 'path' in a new process.&#10;&#10;    mode: mode of process creation&#10;    path: path of executable file&#10;    args: tuple or list of arguments&#10;    env: dictionary of strings mapping to strings">
			</Overload>
		</KeyWord>
		<KeyWord name="os.startfile" func="yes">
			<Overload retVal="" descr="startfile(filepath [, operation]) - Start a file with its associated&#10;application.&#10;&#10;When &quot;operation&quot; is not specified or &quot;open&quot;, this acts like&#10;double-clicking the file in Explorer, or giving the file name as an&#10;argument to the DOS &quot;start&quot; command: the file is opened with whatever&#10;application (if any) its extension is associated.&#10;When another &quot;operation&quot; is given, it specifies what should be done with&#10;the file.  A typical operation is &quot;print&quot;.&#10;&#10;startfile returns as soon as the associated application is launched.&#10;There is no option to wait for the application to close, and no way&#10;to retrieve the application's exit status.&#10;&#10;The filepath is relative to the current directory.  If you want to use&#10;an absolute path, make sure the first character is not a slash (&quot;/&quot;);&#10;the underlying Win32 ShellExecute function doesn't work if it is.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat" func="yes">
			<Overload retVal="" descr="stat(path) -&gt; stat result&#10;&#10;Perform a stat system call on the given path.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_float_times" func="yes">
			<Overload retVal="" descr="stat_float_times([newval]) -&gt; oldval&#10;&#10;Determine whether os.[lf]stat represents time stamps as float objects.&#10;If newval is True, future calls to stat() return floats, if it is False,&#10;future calls return ints. &#10;If newval is omitted, return the current setting.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result" func="yes">
			<Overload retVal="" descr="stat_result: Result from stat or lstat.&#10;&#10;This object may be accessed either as a tuple of&#10;  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)&#10;or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.&#10;&#10;Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,&#10;or st_flags, they are available as attributes only.&#10;&#10;See os.stat for more information.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.n_unnamed_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_atime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_ctime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_dev" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_gid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_ino" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_mtime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_nlink" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_uid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result" func="yes">
			<Overload retVal="" descr="statvfs_result: Result from statvfs or fstatvfs.&#10;&#10;This object may be accessed either as a tuple of&#10;  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),&#10;or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.&#10;&#10;See os.statvfs for more information.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_bavail" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_bfree" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_blocks" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_bsize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_favail" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_ffree" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_files" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_flag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_frsize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_namemax" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.strerror" func="yes">
			<Overload retVal="" descr="strerror(code) -&gt; string&#10;&#10;Translate an error code to a message string.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.system" func="yes">
			<Overload retVal="" descr="system(command) -&gt; exit_status&#10;&#10;Execute the command (a string) in a subshell.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.tempnam" func="yes">
			<Overload retVal="" descr="tempnam([dir[, prefix]]) -&gt; string&#10;&#10;Return a unique name for a temporary file.&#10;The directory and a prefix may be specified as strings; they may be omitted&#10;or None if not needed.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times" func="yes">
			<Overload retVal="" descr="times() -&gt; (utime, stime, cutime, cstime, elapsed_time)&#10;&#10;Return a tuple of floating point numbers indicating process times.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.tmpfile" func="yes">
			<Overload retVal="" descr="tmpfile() -&gt; file object&#10;&#10;Create a temporary file with no directory entries.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.tmpnam" func="yes">
			<Overload retVal="" descr="tmpnam() -&gt; string&#10;&#10;Return a unique name for a temporary file.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.umask" func="yes">
			<Overload retVal="" descr="umask(new_mask) -&gt; old_mask&#10;&#10;Set the current numeric umask and return the previous umask.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.unlink" func="yes">
			<Overload retVal="" descr="unlink(path)&#10;&#10;Remove a file (same as remove(path)).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.unsetenv" />
		<KeyWord name="os.urandom" func="yes">
			<Overload retVal="" descr="urandom(n) -&gt; str&#10;&#10;Return n random bytes suitable for cryptographic use.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.utime" func="yes">
			<Overload retVal="" descr="utime(path, (atime, mtime))&#10;utime(path, None)&#10;&#10;Set the access and modified time of the file to the given values.  If the&#10;second form is used, set the access and modified times to the current time.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.waitpid" func="yes">
			<Overload retVal="" descr="waitpid(pid, options) -&gt; (pid, status &lt;&lt; 8)&#10;&#10;Wait for completion of a given process.  options is ignored on Windows.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.walk" func="yes">
			<Overload retVal="" descr="Directory tree generator.&#10;&#10;For each directory in the directory tree rooted at top (including top&#10;itself, but excluding '.' and '..'), yields a 3-tuple&#10;&#10;    dirpath, dirnames, filenames&#10;&#10;dirpath is a string, the path to the directory.  dirnames is a list of&#10;the names of the subdirectories in dirpath (excluding '.' and '..').&#10;filenames is a list of the names of the non-directory files in dirpath.&#10;Note that the names in the lists are just names, with no path components.&#10;To get a full path (which begins with top) to a file or directory in&#10;dirpath, do os.path.join(dirpath, name).&#10;&#10;If optional arg 'topdown' is true or not specified, the triple for a&#10;directory is generated before the triples for any of its subdirectories&#10;(directories are generated top down).  If topdown is false, the triple&#10;for a directory is generated after the triples for all of its&#10;subdirectories (directories are generated bottom up).&#10;&#10;When topdown is true, the caller can modify the dirnames list in-place&#10;(e.g., via del or slice assignment), and walk will only recurse into the&#10;subdirectories whose names remain in dirnames; this can be used to prune the&#10;search, or to impose a specific order of visiting.  Modifying dirnames when&#10;topdown is false is ineffective, since the directories in dirnames have&#10;already been generated by the time dirnames itself is generated. No matter&#10;the value of topdown, the list of subdirectories is retrieved before the&#10;tuples for the directory and its subdirectories are generated.&#10;&#10;By default errors from the os.listdir() call are ignored.  If&#10;optional arg 'onerror' is specified, it should be a function; it&#10;will be called with one argument, an os.error instance.  It can&#10;report the error to continue with the walk, or raise the exception&#10;to abort the walk.  Note that the filename is available as the&#10;filename attribute of the exception object.&#10;&#10;By default, os.walk does not follow symbolic links to subdirectories on&#10;systems that support them.  In order to get this functionality, set the&#10;optional argument 'followlinks' to true.&#10;&#10;Caution:  if you pass a relative pathname for top, don't change the&#10;current working directory between resumptions of walk.  walk never&#10;changes the current directory, and assumes that the client doesn't&#10;either.&#10;&#10;Example:&#10;&#10;import os&#10;from os.path import join, getsize&#10;for root, dirs, files in os.walk('python/Lib/email'):&#10;    print root, &quot;consumes&quot;,&#10;    print sum([getsize(join(root, name)) for name in files]),&#10;    print &quot;bytes in&quot;, len(files), &quot;non-directory files&quot;&#10;    if 'CVS' in dirs:&#10;        dirs.remove('CVS')  # don't visit CVS directories">
				<Param name="top" />
				<Param name="[topdown=True" />
				<Param name="[onerror=None" />
				<Param name="[followlinks=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.write" func="yes">
			<Overload retVal="" descr="write(fd, string) -&gt; byteswritten&#10;&#10;Write a string to a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath" func="yes">
			<Overload retVal="" descr="Common pathname manipulations, OS/2 EMX version.&#10;&#10;Instead of importing this module directly, import os and refer to this&#10;module as os.path.">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.abspath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.altsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.basename" func="yes">
			<Overload retVal="" descr="Returns the final component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.dirname" func="yes">
			<Overload retVal="" descr="Returns the directory component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.expanduser" func="yes">
			<Overload retVal="" descr="Expand ~ and ~user constructs.&#10;&#10;If user or $HOME is unknown, do nothing.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.expandvars" func="yes">
			<Overload retVal="" descr="Expand shell variables of the forms $var, ${var} and %var%.&#10;&#10;Unknown variables are left unchanged.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.isabs" func="yes">
			<Overload retVal="" descr="Test whether a path is absolute">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.islink" func="yes">
			<Overload retVal="" descr="Test for symbolic link.&#10;On WindowsNT/95 and OS/2 always returns false">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.ismount" func="yes">
			<Overload retVal="" descr="Test whether a path is a mount point (defined as root of drive)">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.join" func="yes">
			<Overload retVal="" descr="Join two or more pathname components, inserting sep as needed">
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.normcase" func="yes">
			<Overload retVal="" descr="Normalize case of pathname.&#10;&#10;Makes all characters lowercase and all altseps into seps.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize path, eliminating double slashes, etc.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.realpath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.split" func="yes">
			<Overload retVal="" descr="Split a pathname.&#10;&#10;Return tuple (head, tail) where tail is everything after the final slash.&#10;Either part may be empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.splitdrive" func="yes">
			<Overload retVal="" descr='Split a pathname into drive/UNC sharepoint and relative path specifiers.&#10;Returns a 2-tuple (drive_or_unc, path); either part may be empty.&#10;&#10;If you assign&#10;    result = splitdrive(p)&#10;It is always true that:&#10;    result[0] + result[1] == p&#10;&#10;If the path contained a drive letter, drive_or_unc will contain everything&#10;up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")&#10;&#10;If the path contained a UNC path, the drive_or_unc will contain the host name&#10;and share up to but not including the fourth directory separator character.&#10;e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")&#10;&#10;Paths cannot contain both a drive letter and a UNC path.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.splitunc" func="yes">
			<Overload retVal="" descr="Split a pathname into UNC mount point and relative path specifiers.&#10;&#10;Return a 2-tuple (unc, rest); either part may be empty.&#10;If unc is not empty, it has the form '//host/mount' (or similar&#10;using backslashes).  unc+rest is always the input path.&#10;Paths containing drive letters never have an UNC part.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="os2emxpath.walk" func="yes">
			<Overload retVal="" descr="Directory tree walk with callback function.&#10;&#10;For each directory in the directory tree rooted at top (including top&#10;itself, but excluding '.' and '..'), call func(arg, dirname, fnames).&#10;dirname is the name of the directory, and fnames a list of the names of&#10;the files and subdirectories in dirname (excluding '.' and '..').  func&#10;may modify the fnames list in-place (e.g. via del or slice assignment),&#10;and walk will only recurse into the subdirectories whose names remain in&#10;fnames; this can be used to implement a filter, or to impose a specific&#10;order of visiting.  No semantics are defined for, or required of, arg,&#10;beyond that arg is always passed to func.  It can be used, e.g., to pass&#10;a filename pattern, or a mutable object designed to accumulate&#10;statistics.  Passing None for arg is common.">
				<Param name="top" />
				<Param name="func" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="output" func="yes">
			<Overload retVal="" descr="Function of Cookie.SerialCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="pack" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_configure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_forget" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_info" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_into" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_propagate" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_slaves" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="pager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="paretovariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="parse" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="parse150" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse227" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse229" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse257" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parseArgs" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="parseFile" func="yes">
			<Overload retVal="" descr="Function of compiler">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_args" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_config_h" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_header" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_http_list" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_keqv_list" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_known_args" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_multipart" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_ns_headers" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_qs" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_qsl" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_template" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="parseaddr" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="parseargs" func="yes">
			<Overload retVal="" descr="Function of smtpd">
			</Overload>
		</KeyWord>
		<KeyWord name="parsedate" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="parsedate_tz" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="parsefield" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="parseline" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="pass" />
		<KeyWord name="pathdirs" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="pathname2url" func="yes">
			<Overload retVal="" descr="Function of macurl2path">
			</Overload>
		</KeyWord>
		<KeyWord name="pbkdf2_hmac" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="pd" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb" func="yes">
			<Overload retVal="" descr="A Python debugger.">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Repr" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Restart" func="yes">
			<Overload retVal="" descr="Causes a debugger to be restarted for the debugged python program.">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Restart.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Restart.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.TESTCMD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.find_function" />
		<KeyWord name="pdb.help" />
		<KeyWord name="pdb.line_prefix" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.main" />
		<KeyWord name="pdb.pm" />
		<KeyWord name="pdb.post_mortem" func="yes">
			<Overload retVal="" descr=>
				<Param name="[t=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="statement" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.runctx" />
		<KeyWord name="pdb.runeval" func="yes">
			<Overload retVal="" descr=>
				<Param name="expression" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.set_trace" />
		<KeyWord name="pdb.test" />
		<KeyWord name="peek" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRWPair">
			</Overload>
		</KeyWord>
		<KeyWord name="pen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="pencolor" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="pending" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="pendown" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="pensize" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="penup" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="pformat" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle" func="yes">
			<Overload retVal="" descr="Create portable serialized representations of Python objects.&#10;&#10;See module cPickle for a (much) faster implementation.&#10;See module copy_reg for a mechanism for registering custom picklers.&#10;See module pickletools source for extensive comments.&#10;&#10;Classes:&#10;&#10;    Pickler&#10;    Unpickler&#10;&#10;Functions:&#10;&#10;    dump(object, file)&#10;    dumps(object) -&gt; string&#10;    load(file) -&gt; object&#10;    loads(string) -&gt; object&#10;&#10;Misc variables:&#10;&#10;    __version__&#10;    format_version&#10;    compatible_formats">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.APPEND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.APPENDS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINFLOAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINGET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BININT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BININT1" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BININT2" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINPERSID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINPUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINSTRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINUNICODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BUILD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BuiltinFunctionType" />
		<KeyWord name="pickle.BuiltinMethodType" />
		<KeyWord name="pickle.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DICT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DUP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType" />
		<KeyWord name="pickle.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_DICT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_LIST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_TUPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EXT1" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EXT2" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EXT4" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EllipsisType" />
		<KeyWord name="pickle.FALSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FLOAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType" />
		<KeyWord name="pickle.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GLOBAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType" />
		<KeyWord name="pickle.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GetSetDescriptorType" />
		<KeyWord name="pickle.HIGHEST_PROTOCOL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.INST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.INT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LIST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG1" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG4" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG_BINGET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG_BINPUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MARK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MemberDescriptorType" />
		<KeyWord name="pickle.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWFALSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWOBJ" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWTRUE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NoneType" />
		<KeyWord name="pickle.NotImplementedType" />
		<KeyWord name="pickle.OBJ" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PERSID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.POP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.POP_MARK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PROTO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PickleError" func="yes">
			<Overload retVal="" descr="A common base class for the other pickling exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PickleError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PickleError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PicklingError" func="yes">
			<Overload retVal="" descr="This exception is raised when an unpicklable object is passed to the&#10;dump() method.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PicklingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PicklingError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.REDUCE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SETITEM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SETITEMS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SHORT_BINSTRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.STOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TRUE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE1" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE2" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE3" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TracebackType" />
		<KeyWord name="pickle.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UNICODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Unpickler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnpicklingError" func="yes">
			<Overload retVal="" descr="This exception is raised when there is a problem unpickling an object,&#10;such as a security violation.&#10;&#10;Note that other exceptions may also be raised during unpickling, including&#10;(but not necessarily limited to) AttributeError, EOFError, ImportError,&#10;and IndexError.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnpicklingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnpicklingError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.compatible_formats" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.decode_long" func="yes">
			<Overload retVal="" descr="Decode a long from a two's complement little-endian binary string.&#10;&#10;&gt;&gt;&gt; decode_long('')&#10;0L&#10;&gt;&gt;&gt; decode_long(&quot;\xff\x00&quot;)&#10;255L&#10;&gt;&gt;&gt; decode_long(&quot;\xff\x7f&quot;)&#10;32767L&#10;&gt;&gt;&gt; decode_long(&quot;\x00\xff&quot;)&#10;-256L&#10;&gt;&gt;&gt; decode_long(&quot;\x00\x80&quot;)&#10;-32768L&#10;&gt;&gt;&gt; decode_long(&quot;\x80&quot;)&#10;-128L&#10;&gt;&gt;&gt; decode_long(&quot;\x7f&quot;)&#10;127L">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.dispatch_table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.dump" func="yes">
			<Overload retVal="" descr=>
				<Param name="obj" />
				<Param name="file" />
				<Param name="[protocol=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.dumps" func="yes">
			<Overload retVal="" descr=>
				<Param name="obj" />
				<Param name="[protocol=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.encode_long" func="yes">
			<Overload retVal="" descr="Encode a long to a two's complement little-endian binary string.&#10;Note that 0L is a special case, returning an empty string, to save a&#10;byte in the LONG1 pickling context.&#10;&#10;&gt;&gt;&gt; encode_long(0L)&#10;''&#10;&gt;&gt;&gt; encode_long(255L)&#10;'\xff\x00'&#10;&gt;&gt;&gt; encode_long(32767L)&#10;'\xff\x7f'&#10;&gt;&gt;&gt; encode_long(-256L)&#10;'\x00\xff'&#10;&gt;&gt;&gt; encode_long(-32768L)&#10;'\x00\x80'&#10;&gt;&gt;&gt; encode_long(-128L)&#10;'\x80'&#10;&gt;&gt;&gt; encode_long(127L)&#10;'\x7f'&#10;&gt;&gt;&gt;">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.format_version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.load" />
		<KeyWord name="pickle.loads" />
		<KeyWord name="pickle.mloads" func="yes">
			<Overload retVal="" descr="loads(string)&#10;&#10;Convert the string to a value. If no valid value is found, raise&#10;EOFError, ValueError or TypeError. Extra characters in the string are&#10;ignored.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.whichmodule" func="yes">
			<Overload retVal="" descr='Figure out the module in which a function occurs.&#10;&#10;Search sys.modules for the module.&#10;Cache in classmap.&#10;Return a module name.&#10;If the function cannot be found, return "__main__".'>
				<Param name="func" />
				<Param name="funcname" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle_complex" func="yes">
			<Overload retVal="" descr="Function of copy_reg">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools" func="yes">
			<Overload retVal="" descr='"Executable documentation" for the pickle module.&#10;&#10;Extensive comments about the pickle protocols and pickle-machine opcodes&#10;can be found here.  Some functions meant for external use:&#10;&#10;genops(pickle)&#10;   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.&#10;&#10;dis(pickle, out=None, memo=None, indentlevel=4)&#10;   Print a symbolic disassembly of a pickle.'>
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor" />
		<KeyWord name="pickletools.ArgumentDescriptor.doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor.n" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor.reader" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo" />
		<KeyWord name="pickletools.OpcodeInfo.arg" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.proto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.stack_after" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.stack_before" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.StackObject" />
		<KeyWord name="pickletools.StackObject.doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.StackObject.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.StackObject.obtype" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.TAKEN_FROM_ARGUMENT1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.TAKEN_FROM_ARGUMENT4" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.UP_TO_NEWLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.anyobject" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.code2op" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.decimalnl_long" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.decimalnl_short" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.decode_long" func="yes">
			<Overload retVal="" descr="Decode a long from a two's complement little-endian binary string.&#10;&#10;&gt;&gt;&gt; decode_long('')&#10;0L&#10;&gt;&gt;&gt; decode_long(&quot;\xff\x00&quot;)&#10;255L&#10;&gt;&gt;&gt; decode_long(&quot;\xff\x7f&quot;)&#10;32767L&#10;&gt;&gt;&gt; decode_long(&quot;\x00\xff&quot;)&#10;-256L&#10;&gt;&gt;&gt; decode_long(&quot;\x00\x80&quot;)&#10;-32768L&#10;&gt;&gt;&gt; decode_long(&quot;\x80&quot;)&#10;-128L&#10;&gt;&gt;&gt; decode_long(&quot;\x7f&quot;)&#10;127L">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.dis" func="yes">
			<Overload retVal="" descr="Produce a symbolic disassembly of a pickle.&#10;&#10;'pickle' is a file-like object, or string, containing a (at least one)&#10;pickle.  The pickle is disassembled from the current position, through&#10;the first STOP opcode encountered.&#10;&#10;Optional arg 'out' is a file-like object to which the disassembly is&#10;printed.  It defaults to sys.stdout.&#10;&#10;Optional arg 'memo' is a Python dict, used as the pickle's memo.  It&#10;may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.&#10;Passing the same memo object to another dis() call then allows disassembly&#10;to proceed across multiple pickles that were all created by the same&#10;pickler with the same memo.  Ordinarily you don't need to worry about this.&#10;&#10;Optional arg indentlevel is the number of blanks by which to indent&#10;a new MARK level.  It defaults to 4.&#10;&#10;In addition to printing the disassembly, some sanity checks are made:&#10;&#10;+ All embedded opcode arguments &quot;make sense&quot;.&#10;&#10;+ Explicit and implicit pop operations have enough items on the stack.&#10;&#10;+ When an opcode implicitly refers to a markobject, a markobject is&#10;  actually on the stack.&#10;&#10;+ A memo entry isn't referenced before it's defined.&#10;&#10;+ The markobject isn't stored in the memo.&#10;&#10;+ A memo entry isn't redefined.">
				<Param name="pickle" />
				<Param name="[out=None" />
				<Param name="[memo=None" />
				<Param name="[indentlevel=4]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.float8" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.floatnl" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.genops" func="yes">
			<Overload retVal="" descr="Generate all the opcodes in a pickle.&#10;&#10;'pickle' is a file-like object, or string, containing the pickle.&#10;&#10;Each opcode in the pickle is generated, from the current pickle position,&#10;stopping after a STOP opcode is delivered.  A triple is generated for&#10;each opcode:&#10;&#10;    opcode, arg, pos&#10;&#10;opcode is an OpcodeInfo record, describing the current opcode.&#10;&#10;If the opcode has an argument embedded in the pickle, arg is its decoded&#10;value, as a Python object.  If the opcode doesn't have an argument, arg&#10;is None.&#10;&#10;If the pickle has a tell() method, pos was the value of pickle.tell()&#10;before reading the current opcode.  If the pickle is a string object,&#10;it's wrapped in a StringIO object, and the latter's tell() result is&#10;used.  Else (the pickle doesn't have a tell(), and it's not obvious how&#10;to query its current position) pos is None.">
				<Param name="pickle" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.int4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.long1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.long4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.markobject" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.opcodes" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.optimize" func="yes">
			<Overload retVal="" descr="Optimize a pickle string by removing unused PUT opcodes">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pybool" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pydict" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyfloat" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyint" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyinteger_or_bool" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pylist" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pylong" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pynone" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pystring" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pytuple" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyunicode" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_decimalnl_long" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&#10;&gt;&gt;&gt; read_decimalnl_long(StringIO.StringIO(&quot;1234\n56&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: trailing 'L' required in '1234'&#10;&#10;Someday the trailing 'L' will probably go away from this output.&#10;&#10;&gt;&gt;&gt; read_decimalnl_long(StringIO.StringIO(&quot;1234L\n56&quot;))&#10;1234L&#10;&#10;&gt;&gt;&gt; read_decimalnl_long(StringIO.StringIO(&quot;123456789012345678901234L\n6&quot;))&#10;123456789012345678901234L">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_decimalnl_short" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_decimalnl_short(StringIO.StringIO(&quot;1234\n56&quot;))&#10;1234&#10;&#10;&gt;&gt;&gt; read_decimalnl_short(StringIO.StringIO(&quot;1234L\n56&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: trailing 'L' not allowed in '1234L'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_float8" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO, struct&#10;&gt;&gt;&gt; raw = struct.pack(&quot;&gt;d&quot;, -1.25)&#10;&gt;&gt;&gt; raw&#10;'\xbf\xf4\x00\x00\x00\x00\x00\x00'&#10;&gt;&gt;&gt; read_float8(StringIO.StringIO(raw + &quot;\n&quot;))&#10;-1.25">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_floatnl" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_floatnl(StringIO.StringIO("-1.25\n6"))&#10;-1.25'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_int4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_int4(StringIO.StringIO('\xff\x00\x00\x00'))&#10;255&#10;&gt;&gt;&gt; read_int4(StringIO.StringIO('\x00\x00\x00\x80')) == -(2**31)&#10;True">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_long1" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_long1(StringIO.StringIO("\x00"))&#10;0L&#10;&gt;&gt;&gt; read_long1(StringIO.StringIO("\x02\xff\x00"))&#10;255L&#10;&gt;&gt;&gt; read_long1(StringIO.StringIO("\x02\xff\x7f"))&#10;32767L&#10;&gt;&gt;&gt; read_long1(StringIO.StringIO("\x02\x00\xff"))&#10;-256L&#10;&gt;&gt;&gt; read_long1(StringIO.StringIO("\x02\x00\x80"))&#10;-32768L'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_long4" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x00"))&#10;255L&#10;&gt;&gt;&gt; read_long4(StringIO.StringIO("\x02\x00\x00\x00\xff\x7f"))&#10;32767L&#10;&gt;&gt;&gt; read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\xff"))&#10;-256L&#10;&gt;&gt;&gt; read_long4(StringIO.StringIO("\x02\x00\x00\x00\x00\x80"))&#10;-32768L&#10;&gt;&gt;&gt; read_long1(StringIO.StringIO("\x00\x00\x00\x00"))&#10;0L'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_string1" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_string1(StringIO.StringIO(&quot;\x00&quot;))&#10;''&#10;&gt;&gt;&gt; read_string1(StringIO.StringIO(&quot;\x03abcdef&quot;))&#10;'abc'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_string4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_string4(StringIO.StringIO(&quot;\x00\x00\x00\x00abc&quot;))&#10;''&#10;&gt;&gt;&gt; read_string4(StringIO.StringIO(&quot;\x03\x00\x00\x00abcdef&quot;))&#10;'abc'&#10;&gt;&gt;&gt; read_string4(StringIO.StringIO(&quot;\x00\x00\x00\x03abcdef&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 50331648 bytes in a string4, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_stringnl" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;'abcd'\nefg\n&quot;))&#10;'abcd'&#10;&#10;&gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;\n&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: no string quotes around ''&#10;&#10;&gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;\n&quot;), stripquotes=False)&#10;''&#10;&#10;&gt;&gt;&gt; read_stringnl(StringIO.StringIO(&quot;''\n&quot;))&#10;''&#10;&#10;&gt;&gt;&gt; read_stringnl(StringIO.StringIO('&quot;abcd&quot;'))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: no newline found when trying to read stringnl&#10;&#10;Embedded escapes are undone in the result.&#10;&gt;&gt;&gt; read_stringnl(StringIO.StringIO(r&quot;'a\n\\b\x00c\td'&quot; + &quot;\n'e'&quot;))&#10;'a\n\\b\x00c\td'">
				<Param name="f" />
				<Param name="[decode=True" />
				<Param name="[stripquotes=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_stringnl_noescape" />
		<KeyWord name="pickletools.read_stringnl_noescape_pair" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_stringnl_noescape_pair(StringIO.StringIO(&quot;Queue\nEmpty\njunk&quot;))&#10;'Queue Empty'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_uint1" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_uint1(StringIO.StringIO('\xff'))&#10;255">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_uint2" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_uint2(StringIO.StringIO('\xff\x00'))&#10;255&#10;&gt;&gt;&gt; read_uint2(StringIO.StringIO('\xff\xff'))&#10;65535">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_unicodestring4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; s = u'abcd\uabcd'&#10;&gt;&gt;&gt; enc = s.encode('utf-8')&#10;&gt;&gt;&gt; enc&#10;'abcd\xea\xaf\x8d'&#10;&gt;&gt;&gt; n = chr(len(enc)) + chr(0) * 3  # little-endian 4-byte length&#10;&gt;&gt;&gt; t = read_unicodestring4(StringIO.StringIO(n + enc + 'junk'))&#10;&gt;&gt;&gt; s == t&#10;True&#10;&#10;&gt;&gt;&gt; read_unicodestring4(StringIO.StringIO(n + enc[:-1]))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 7 bytes in a unicodestring4, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_unicodestringnl" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import StringIO&#10;&gt;&gt;&gt; read_unicodestringnl(StringIO.StringIO(&quot;abc\uabcd\njunk&quot;))&#10;u'abc\uabcd'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stackslice" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.string1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.string4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stringnl" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stringnl_noescape" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stringnl_noescape_pair" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.uint1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.uint2" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.unicodestring4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.unicodestringnl" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickline" func="yes">
			<Overload retVal="" descr="Function of mhlib">
			</Overload>
		</KeyWord>
		<KeyWord name="pipe" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="pipepager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes" func="yes">
			<Overload retVal="" descr="Conversion pipeline templates.&#10;&#10;The problem:&#10;------------&#10;&#10;Suppose you have some data that you want to convert to another format,&#10;such as from GIF image format to PPM image format.  Maybe the&#10;conversion involves several steps (e.g. piping it through compress or&#10;uuencode).  Some of the conversion steps may require that their input&#10;is a disk file, others may be able to read standard input; similar for&#10;their output.  The input to the entire conversion may also be read&#10;from a disk file or from an open file, and similar for its output.&#10;&#10;The module lets you construct a pipeline template by sticking one or&#10;more conversion steps together.  It will take care of creating and&#10;removing temporary files if they are necessary to hold intermediate&#10;data.  You can then use the template to do conversions from many&#10;different sources to many different destinations.  The temporary&#10;file names used are different each time the template is used.&#10;&#10;The templates are objects so you can create templates for many&#10;different conversion steps and store them in a dictionary, for&#10;instance.&#10;&#10;&#10;Directions:&#10;-----------&#10;&#10;To create a template:&#10;    t = Template()&#10;&#10;To add a conversion step to a template:&#10;   t.append(command, kind)&#10;where kind is a string of two characters: the first is '-' if the&#10;command reads its standard input or 'f' if it requires a file; the&#10;second likewise for the output. The command must be valid /bin/sh&#10;syntax.  If input or output files are required, they are passed as&#10;$IN and $OUT; otherwise, it must be  possible to use the command in&#10;a pipeline.&#10;&#10;To add a conversion step at the beginning:&#10;   t.prepend(command, kind)&#10;&#10;To convert a file to another file using a template:&#10;  sts = t.copy(infile, outfile)&#10;If infile or outfile are the empty string, standard input is read or&#10;standard output is written, respectively.  The return value is the&#10;exit status of the conversion pipeline.&#10;&#10;To open a file for reading or writing through a conversion pipeline:&#10;   fp = t.open(file, mode)&#10;where mode is 'r' to read the file, or 'w' to write it -- just like&#10;for the built-in function open() or for os.popen().&#10;&#10;To create a new template object initialized to a given one:&#10;   t2 = t.clone()">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.FILEIN_FILEOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.FILEIN_STDOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.SINK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.SOURCE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.STDIN_FILEOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.STDIN_STDOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.makepipeline" />
		<KeyWord name="pipes.quote" func="yes">
			<Overload retVal="" descr="Return a shell-escaped version of the file string.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.stepkinds" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipethrough" func="yes">
			<Overload retVal="" descr="Function of mimetools">
			</Overload>
		</KeyWord>
		<KeyWord name="pipeto" func="yes">
			<Overload retVal="" descr="Function of mimetools">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil" func="yes">
			<Overload retVal="" descr="Utilities to support packages.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpImporter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpLoader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.extend_path" func="yes">
			<Overload retVal="" descr="Extend a package's path.&#10;&#10;Intended use is to place the following code in a package's __init__.py:&#10;&#10;    from pkgutil import extend_path&#10;    __path__ = extend_path(__path__, __name__)&#10;&#10;This will add to the package's __path__ all subdirectories of&#10;directories on sys.path named after the package.  This is useful&#10;if one wants to distribute different parts of a single logical&#10;package as multiple directories.&#10;&#10;It also looks for *.pkg files beginning where * matches the name&#10;argument.  This feature is similar to *.pth files (see site.py),&#10;except that it doesn't special-case lines starting with 'import'.&#10;A *.pkg file is trusted at face value: apart from checking for&#10;duplicates, all entries found in a *.pkg file are added to the&#10;path, regardless of whether they are exist the filesystem.  (This&#10;is a feature.)&#10;&#10;If the input path is not a list (as is the case for frozen&#10;packages) it is returned unchanged.  The input path is not&#10;modified; an extended copy is returned.  Items are only appended&#10;to the copy at the end.&#10;&#10;It is assumed that sys.path is a sequence.  Items of sys.path that&#10;are not (unicode or 8-bit) strings referring to existing&#10;directories are ignored.  Unicode items of sys.path that cause&#10;errors when used as filenames may cause this function to raise an&#10;exception (in line with os.path.isdir() behavior).">
				<Param name="path" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.find_loader" func="yes">
			<Overload retVal="" descr="Find a PEP 302 &quot;loader&quot; object for fullname&#10;&#10;If fullname contains dots, path must be the containing package's __path__.&#10;Returns None if the module cannot be found or imported. This function uses&#10;iter_importers(), and is thus subject to the same limitations regarding&#10;platform-specific special import locations such as the Windows registry.">
				<Param name="fullname" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.get_data" func="yes">
			<Overload retVal="" descr="Get a resource from a package.&#10;&#10;This is a wrapper round the PEP 302 loader get_data API. The package&#10;argument should be the name of a package, in standard module format&#10;(foo.bar). The resource argument should be in the form of a relative&#10;filename, using '/' as the path separator. The parent directory name '..'&#10;is not allowed, and nor is a rooted name (starting with a '/').&#10;&#10;The function returns a binary string, which is the contents of the&#10;specified resource.&#10;&#10;For packages located in the filesystem, which have already been imported,&#10;this is the rough equivalent of&#10;&#10;    d = os.path.dirname(sys.modules[package].__file__)&#10;    data = open(os.path.join(d, resource), 'rb').read()&#10;&#10;If the package cannot be located or loaded, or it uses a PEP 302 loader&#10;which does not support get_data(), then None is returned.">
				<Param name="package" />
				<Param name="resource" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.get_importer" func="yes">
			<Overload retVal="" descr="Retrieve a PEP 302 importer for the given path item&#10;&#10;The returned importer is cached in sys.path_importer_cache&#10;if it was newly created by a path hook.&#10;&#10;If there is no importer, a wrapper around the basic import&#10;machinery is returned. This wrapper is never inserted into&#10;the importer cache (None is inserted instead).&#10;&#10;The cache (or part of it) can be cleared manually if a&#10;rescan of sys.path_hooks is necessary.">
				<Param name="path_item" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.get_loader" func="yes">
			<Overload retVal="" descr='Get a PEP 302 "loader" object for module_or_name&#10;&#10;If the module or package is accessible via the normal import&#10;mechanism, a wrapper around the relevant part of that machinery&#10;is returned.  Returns None if the module cannot be found or imported.&#10;If the named module is not already imported, its containing package&#10;(if any) is imported, in order to establish the package __path__.&#10;&#10;This function uses iter_importers(), and is thus subject to the same&#10;limitations regarding platform-specific special import locations such&#10;as the Windows registry.'>
				<Param name="module_or_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_importer_modules" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_importers" func="yes">
			<Overload retVal="" descr="Yield PEP 302 importers for the given module name&#10;&#10;If fullname contains a '.', the importers will be for the package&#10;containing fullname, otherwise they will be importers for sys.meta_path,&#10;sys.path, and Python's &quot;classic&quot; import machinery, in that order.  If&#10;the named module is in a package, that package is imported as a side&#10;effect of invoking this function.&#10;&#10;Non PEP 302 mechanisms (e.g. the Windows registry) used by the&#10;standard import machinery to find files in alternative locations&#10;are partially supported, but are searched AFTER sys.path. Normally,&#10;these locations are searched BEFORE sys.path, preventing sys.path&#10;entries from shadowing them.&#10;&#10;For this to cause a visible difference in behaviour, there must&#10;be a module or package name that is accessible via both sys.path&#10;and one of the non PEP 302 file system mechanisms. In this case,&#10;the emulation will find the former version, while the builtin&#10;import mechanism will find the latter.&#10;&#10;Items of the following types can be affected by this discrepancy:&#10;    imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY">
				<Param name="[fullname]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_modules" func="yes">
			<Overload retVal="" descr="Yields (module_loader, name, ispkg) for all submodules on path,&#10;or, if path is None, all top-level modules on sys.path.&#10;&#10;'path' should be either None or a list of paths to look for&#10;modules in.&#10;&#10;'prefix' is a string to output on the front of every module name&#10;on output.">
				<Param name="[path=None" />
				<Param name="[prefix]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_zipimport_modules" func="yes">
			<Overload retVal="" descr=>
				<Param name="importer" />
				<Param name="[prefix]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.read_code" />
		<KeyWord name="pkgutil.simplegeneric" func="yes">
			<Overload retVal="" descr="Make a trivial single-dispatch generic function">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.walk_packages" func="yes">
			<Overload retVal="" descr="Yields (module_loader, name, ispkg) for all modules recursively&#10;on path, or, if path is None, all accessible modules.&#10;&#10;'path' should be either None or a list of paths to look for&#10;modules in.&#10;&#10;'prefix' is a string to output on the front of every module name&#10;on output.&#10;&#10;Note that this function must import all *packages* (NOT all&#10;modules!) on the given path, in order to access the __path__&#10;attribute to find submodules.&#10;&#10;'onerror' is a function which gets called with one argument (the&#10;name of the package which was being imported) if any exception&#10;occurs while trying to import a package.  If no onerror function is&#10;supplied, ImportErrors are caught and ignored, while all other&#10;exceptions are propagated, terminating the search.&#10;&#10;Examples:&#10;&#10;# list all modules python can access&#10;walk_packages()&#10;&#10;# list all submodules of ctypes&#10;walk_packages(ctypes.__path__, ctypes.__name__+'.')">
				<Param name="[path=None" />
				<Param name="[prefix" />
				<Param name="[onerror=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter" func="yes">
			<Overload retVal="" descr="zipimporter(archivepath) -&gt; zipimporter object&#10;&#10;Create a new zipimporter instance. 'archivepath' must be a path to&#10;a zipfile, or to a specific path inside a zipfile. For example, it can be&#10;'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a&#10;valid directory inside the archive.&#10;&#10;'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip&#10;archive.&#10;&#10;The 'archive' attribute of zipimporter objects contains the name of the&#10;zipfile targeted.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.archive" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.find_module" func="yes">
			<Overload retVal="" descr="find_module(fullname, path=None) -&gt; self or None.&#10;&#10;Search for a module specified by 'fullname'. 'fullname' must be the&#10;fully qualified (dotted) module name. It returns the zipimporter&#10;instance itself if the module was found, or None if it wasn't.&#10;The optional 'path' argument is ignored -- it's there for compatibility&#10;with the importer protocol.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_code" func="yes">
			<Overload retVal="" descr="get_code(fullname) -&gt; code object.&#10;&#10;Return the code object for the specified module. Raise ZipImportError&#10;if the module couldn't be found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_data" func="yes">
			<Overload retVal="" descr="get_data(pathname) -&gt; string with file data.&#10;&#10;Return the data associated with 'pathname'. Raise IOError if&#10;the file wasn't found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_filename" func="yes">
			<Overload retVal="" descr="get_filename(fullname) -&gt; filename string.&#10;&#10;Return the filename for the specified module.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_source" func="yes">
			<Overload retVal="" descr="get_source(fullname) -&gt; source string.&#10;&#10;Return the source code for the specified module. Raise ZipImportError&#10;if the module couldn't be found, return None if the archive does&#10;contain the module, but has no source for it.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.is_package" func="yes">
			<Overload retVal="" descr="is_package(fullname) -&gt; bool.&#10;&#10;Return True if the module specified by fullname is a package.&#10;Raise ZipImportError if the module couldn't be found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.load_module" func="yes">
			<Overload retVal="" descr="load_module(fullname) -&gt; module.&#10;&#10;Load the module specified by 'fullname'. 'fullname' must be the&#10;fully qualified (dotted) module name. It returns the imported&#10;module, or raises ZipImportError if it wasn't found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.prefix" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="place" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="place_configure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="place_forget" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="place_info" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="place_slaves" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="plain" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="plainpager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="platform" func="yes">
			<Overload retVal="" descr="This module tries to retrieve as much platform-identifying data as&#10;possible. It makes this information available via function APIs.&#10;&#10;If called from the command line, it prints the platform&#10;information concatenated as single string to stdout. The output&#10;format is useable as part of a filename.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.DEV_NULL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.dist" func="yes">
			<Overload retVal="" descr="Tries to determine the name of the Linux OS distribution name.&#10;&#10;The function first looks for a distribution release file in&#10;/etc and then reverts to _dist_try_harder() in case no&#10;suitable files are found.&#10;&#10;Returns a tuple (distname,version,id) which default to the&#10;args given as parameters.">
				<Param name="[distname" />
				<Param name="[version" />
				<Param name="[id" />
				<Param name="[supported_dists=('SuSE', 'debian', 'fedora', 'redhat', 'centos', 'mandrake', 'mandriva', 'rocks', 'slackware', 'yellowdog', 'gentoo', 'UnitedLinux', 'turbolinux')]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.java_ver" func="yes">
			<Overload retVal="" descr="Version interface for Jython.&#10;&#10;Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being&#10;a tuple (vm_name,vm_release,vm_vendor) and osinfo being a&#10;tuple (os_name,os_version,os_arch).&#10;&#10;Values which cannot be determined are set to the defaults&#10;given as parameters (which all default to '').">
				<Param name="[release" />
				<Param name="[vendor" />
				<Param name="[vminfo=('', '', '')" />
				<Param name="[osinfo=('', '', '')]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.linux_distribution" func="yes">
			<Overload retVal="" descr="Tries to determine the name of the Linux OS distribution name.&#10;&#10;The function first looks for a distribution release file in&#10;/etc and then reverts to _dist_try_harder() in case no&#10;suitable files are found.&#10;&#10;supported_dists may be given to define the set of Linux&#10;distributions to look for. It defaults to a list of currently&#10;supported Linux distributions identified by their release file&#10;name.&#10;&#10;If full_distribution_name is true (default), the full&#10;distribution read from the OS is returned. Otherwise the short&#10;name taken from supported_dists is used.&#10;&#10;Returns a tuple (distname,version,id) which default to the&#10;args given as parameters.">
				<Param name="[distname" />
				<Param name="[version" />
				<Param name="[id" />
				<Param name="[supported_dists=('SuSE', 'debian', 'fedora', 'redhat', 'centos', 'mandrake', 'mandriva', 'rocks', 'slackware', 'yellowdog', 'gentoo', 'UnitedLinux', 'turbolinux')" />
				<Param name="[full_distribution_name=1]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.mac_ver" func="yes">
			<Overload retVal="" descr="Get MacOS version information and return it as tuple (release,&#10;versioninfo, machine) with versioninfo being a tuple (version,&#10;dev_stage, non_release_version).&#10;&#10;Entries which cannot be determined are set to the parameter values&#10;which default to ''. All tuple entries are strings.">
				<Param name="[release" />
				<Param name="[versioninfo=('', '', '')" />
				<Param name="[machine]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.machine" func="yes">
			<Overload retVal="" descr="Returns the machine type, e.g. 'i386'&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.node" func="yes">
			<Overload retVal="" descr="Returns the computer's network name (which may not be fully&#10;qualified)&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.platform" func="yes">
			<Overload retVal="" descr='Returns a single string identifying the underlying platform&#10;with as much useful information as possible (but no more :).&#10;&#10;The output is intended to be human readable rather than&#10;machine parseable. It may look different on different&#10;platforms and this is intended.&#10;&#10;If "aliased" is true, the function will use aliases for&#10;various platforms that report system names which differ from&#10;their common names, e.g. SunOS will be reported as&#10;Solaris. The system_alias() function is used to implement&#10;this.&#10;&#10;Setting terse to true causes the function to return only the&#10;absolute minimum information needed to identify the platform.'>
				<Param name="[aliased=0" />
				<Param name="[terse=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.popen" func="yes">
			<Overload retVal="" descr="Portable popen() interface.">
				<Param name="cmd" />
				<Param name="[mode=r" />
				<Param name="[bufsize=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.processor" func="yes">
			<Overload retVal="" descr="Returns the (true) processor name, e.g. 'amdk6'&#10;&#10;An empty string is returned if the value cannot be&#10;determined. Note that many platforms do not provide this&#10;information or simply return the same value as for machine(),&#10;e.g.  NetBSD does this.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_branch" func="yes">
			<Overload retVal="" descr="Returns a string identifying the Python implementation&#10;branch.&#10;&#10;For CPython this is the Subversion branch from which the&#10;Python binary was built.&#10;&#10;If not available, an empty string is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_build" func="yes">
			<Overload retVal="" descr="Returns a tuple (buildno, builddate) stating the Python&#10;build number and date as strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_compiler" func="yes">
			<Overload retVal="" descr="Returns a string identifying the compiler used for compiling&#10;Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_implementation" func="yes">
			<Overload retVal="" descr="Returns a string identifying the Python implementation.&#10;&#10;Currently, the following implementations are identified:&#10;  'CPython' (C implementation of Python),&#10;  'IronPython' (.NET implementation of Python),&#10;  'Jython' (Java implementation of Python),&#10;  'PyPy' (Python implementation of Python).">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_revision" func="yes">
			<Overload retVal="" descr="Returns a string identifying the Python implementation&#10;revision.&#10;&#10;For CPython this is the Subversion revision from which the&#10;Python binary was built.&#10;&#10;If not available, an empty string is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_version" func="yes">
			<Overload retVal="" descr="Returns the Python version as string 'major.minor.patchlevel'&#10;&#10;Note that unlike the Python sys.version, the returned value&#10;will always include the patchlevel (it defaults to 0).">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_version_tuple" func="yes">
			<Overload retVal="" descr="Returns the Python version as tuple (major, minor, patchlevel)&#10;of strings.&#10;&#10;Note that unlike the Python sys.version, the returned value&#10;will always include the patchlevel (it defaults to 0).">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.release" func="yes">
			<Overload retVal="" descr="Returns the system's release, e.g. '2.2.0' or 'NT'&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.system" func="yes">
			<Overload retVal="" descr="Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.system_alias" func="yes">
			<Overload retVal="" descr="Returns (system,release,version) aliased to common&#10;marketing names used for some systems.&#10;&#10;It also does some reordering of the information in some cases&#10;where it would otherwise cause confusion.">
				<Param name="system" />
				<Param name="release" />
				<Param name="version" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname" func="yes">
			<Overload retVal="" descr="Fairly portable uname interface. Returns a tuple&#10;of strings (system,node,release,version,machine,processor)&#10;identifying the underlying platform.&#10;&#10;Note that unlike the os.uname function this also returns&#10;possible processor information as an additional tuple entry.&#10;&#10;Entries which cannot be determined are set to ''.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.version" func="yes">
			<Overload retVal="" descr="Returns the system's release version, e.g. '#3 on degas'&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.win32_ver" func="yes">
			<Overload retVal="" descr="Get additional version information from the Windows Registry&#10;and return a tuple (version,csd,ptype) referring to version&#10;number, CSD level (service pack), and OS type (multi/single&#10;processor).&#10;&#10;As a hint: ptype returns 'Uniprocessor Free' on single&#10;processor NT machines and 'Multiprocessor Free' on multi&#10;processor machines. The 'Free' refers to the OS version being&#10;free of debugging code. It could also state 'Checked' which&#10;means the OS version uses debugging code, i.e. code that&#10;checks arguments, ranges, etc. (Thomas Heller).&#10;&#10;Note: this function works best with Mark Hammond's win32&#10;package installed, but also on Python 2.3 and later. It&#10;obviously only runs on Win32 compatible platforms.">
				<Param name="[release" />
				<Param name="[version" />
				<Param name="[csd" />
				<Param name="[ptype]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib" func="yes">
			<Overload retVal="" descr="plistlib.py -- a tool to generate and parse MacOSX .plist files.&#10;&#10;The PropertyList (.plist) file format is a simple XML pickle supporting&#10;basic object types, like dictionaries, lists, numbers and strings.&#10;Usually the top level object is a dictionary.&#10;&#10;To write out a plist file, use the writePlist(rootObject, pathOrFile)&#10;function. 'rootObject' is the top level object, 'pathOrFile' is a&#10;filename or a (writable) file object.&#10;&#10;To parse a plist from a file, use the readPlist(pathOrFile) function,&#10;with a file name or a (readable) file object as the only argument. It&#10;returns the top level object (again, usually a dictionary).&#10;&#10;To work with plist data in strings, you can use readPlistFromString()&#10;and writePlistToString().&#10;&#10;Values can be strings, integers, floats, booleans, tuples, lists,&#10;dictionaries, Data or datetime.datetime objects. String values (including&#10;dictionary keys) may be unicode strings -- they will be written out as&#10;UTF-8.&#10;&#10;The &lt;data&gt; plist type is supported through the Data class. This is a&#10;thin wrapper around a Python string.&#10;&#10;Generate Plist example:&#10;&#10;    pl = dict(&#10;        aString=&quot;Doodah&quot;,&#10;        aList=[&quot;A&quot;, &quot;B&quot;, 12, 32.1, [1, 2, 3]],&#10;        aFloat=0.1,&#10;        anInt=728,&#10;        aDict=dict(&#10;            anotherString=&quot;&lt;hello &amp; hi there!&gt;&quot;,&#10;            aUnicodeValue=u'M\xe4ssig, Ma\xdf',&#10;            aTrueValue=True,&#10;            aFalseValue=False,&#10;        ),&#10;        someData=Data(&quot;&lt;binary gunk&gt;&quot;),&#10;        someMoreData=Data(&quot;&lt;lots of binary gunk&gt;&quot; * 10),&#10;        aDate=datetime.datetime.fromtimestamp(time.mktime(time.gmtime())),&#10;    )&#10;    # unicode keys are possible, but a little awkward to use:&#10;    pl[u'\xc5benraa'] = &quot;That was a unicode key.&quot;&#10;    writePlist(pl, fileName)&#10;&#10;Parse Plist example:&#10;&#10;    pl = readPlist(pathOrFile)&#10;    print pl[&quot;aKey&quot;]">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Data" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict" />
		<KeyWord name="plistlib.Dict.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.DumbXMLWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.PLISTHEADER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist" func="yes">
			<Overload retVal="" descr="This class has been deprecated. Use readPlist() and writePlist()&#10;functions instead, together with regular dict objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.fromFile" func="yes">
			<Overload retVal="" descr="Deprecated. Use the readPlist() function instead.">
				<Param name="cls" />
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.write" func="yes">
			<Overload retVal="" descr="Deprecated. Use the writePlist() function instead.">
				<Param name="self" />
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.PlistParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.PlistWriter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.readPlist" func="yes">
			<Overload retVal="" descr="Read a .plist file. 'pathOrFile' may either be a file name or a&#10;(readable) file object. Return the unpacked root object (which&#10;usually is a dictionary).">
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.readPlistFromResource" func="yes">
			<Overload retVal="" descr="Read plst resource from the resource fork of path.">
				<Param name="path" />
				<Param name="[restype=plst" />
				<Param name="[resid=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.readPlistFromString" func="yes">
			<Overload retVal="" descr="Read a plist data from a string. Return the root object.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.writePlist" func="yes">
			<Overload retVal="" descr="Write 'rootObject' to a .plist file. 'pathOrFile' may either be a&#10;file name or a (writable) file object.">
				<Param name="rootObject" />
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.writePlistToResource" func="yes">
			<Overload retVal="" descr="Write 'rootObject' as a plst resource to the resource fork of path.">
				<Param name="rootObject" />
				<Param name="path" />
				<Param name="[restype=plst" />
				<Param name="[resid=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.writePlistToString" func="yes">
			<Overload retVal="" descr="Return 'rootObject' as a plist-formatted string.">
				<Param name="rootObject" />
			</Overload>
		</KeyWord>
		<KeyWord name="plus" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="pm" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="pointer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="poll" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="poll2" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="poll3" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="popen" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="popen2" func="yes">
			<Overload retVal="" descr="Spawn a command with pipes to its stdin, stdout, and optionally stderr.&#10;&#10;The normal os.popen(cmd, mode) call spawns a shell command and provides a&#10;file interface to just the input or output of the process depending on&#10;whether mode is 'r' or 'w'.  This module provides the functions popen2(cmd)&#10;and popen3(cmd) which return two or three pipes to the spawned command.">
			</Overload>
		</KeyWord>
		<KeyWord name="popen2.MAXFD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="popen2.popen2" func="yes">
			<Overload retVal="" descr="Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may&#10;be a sequence, in which case arguments will be passed directly to the&#10;program without shell intervention (as with os.spawnv()). If 'cmd' is a&#10;string it will be passed to the shell (as with os.system()). If&#10;'bufsize' is specified, it sets the buffer size for the I/O pipes. The&#10;file objects (child_stdout, child_stdin) are returned.">
				<Param name="cmd" />
				<Param name="[bufsize=-1" />
				<Param name="[mode=t]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="popen2.popen3" func="yes">
			<Overload retVal="" descr="Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may&#10;be a sequence, in which case arguments will be passed directly to the&#10;program without shell intervention (as with os.spawnv()). If 'cmd' is a&#10;string it will be passed to the shell (as with os.system()). If&#10;'bufsize' is specified, it sets the buffer size for the I/O pipes. The&#10;file objects (child_stdout, child_stdin, child_stderr) are returned.">
				<Param name="cmd" />
				<Param name="[bufsize=-1" />
				<Param name="[mode=t]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="popen2.popen4" func="yes">
			<Overload retVal="" descr="Execute the shell command 'cmd' in a sub-process. On UNIX, 'cmd' may&#10;be a sequence, in which case arguments will be passed directly to the&#10;program without shell intervention (as with os.spawnv()). If 'cmd' is a&#10;string it will be passed to the shell (as with os.system()). If&#10;'bufsize' is specified, it sets the buffer size for the I/O pipes. The&#10;file objects (child_stdout_stderr, child_stdin) are returned.">
				<Param name="cmd" />
				<Param name="[bufsize=-1" />
				<Param name="[mode=t]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="popen3" func="yes">
			<Overload retVal="" descr="Function of popen2">
			</Overload>
		</KeyWord>
		<KeyWord name="popen4" func="yes">
			<Overload retVal="" descr="Function of popen2">
			</Overload>
		</KeyWord>
		<KeyWord name="popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="popleft" func="yes">
			<Overload retVal="" descr="Function of Queue.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib" func="yes">
			<Overload retVal="" descr="A POP3 client class.&#10;&#10;Based on the J. Myers POP3 draft, Jan. 96">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.CR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.LF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.error_proto" />
		<KeyWord name="poplib.error_proto.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.error_proto.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pos" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="position" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="posixfile" func="yes">
			<Overload retVal="" descr="Extended file operations available in POSIX.&#10;&#10;f = posixfile.open(filename, [mode, [bufsize]])&#10;      will create a new posixfile object&#10;&#10;f = posixfile.fileopen(fileobject)&#10;      will create a posixfile object from a builtin file object&#10;&#10;f.file()&#10;      will return the original builtin file object&#10;&#10;f.dup()&#10;      will return a new file object based on a new filedescriptor&#10;&#10;f.dup2(fd)&#10;      will return a new file object based on the given filedescriptor&#10;&#10;f.flags(mode)&#10;      will turn on the associated flag (merge)&#10;      mode can contain the following characters:&#10;&#10;  (character representing a flag)&#10;      a       append only flag&#10;      c       close on exec flag&#10;      n       no delay flag&#10;      s       synchronization flag&#10;  (modifiers)&#10;      !       turn flags 'off' instead of default 'on'&#10;      =       copy flags 'as is' instead of default 'merge'&#10;      ?       return a string in which the characters represent the flags&#10;              that are set&#10;&#10;      note: - the '!' and '=' modifiers are mutually exclusive.&#10;            - the '?' modifier will return the status of the flags after they&#10;              have been changed by other characters in the mode string&#10;&#10;f.lock(mode [, len [, start [, whence]]])&#10;      will (un)lock a region&#10;      mode can contain the following characters:&#10;&#10;  (character representing type of lock)&#10;      u       unlock&#10;      r       read lock&#10;      w       write lock&#10;  (modifiers)&#10;      |       wait until the lock can be granted&#10;      ?       return the first lock conflicting with the requested lock&#10;              or 'None' if there is no conflict. The lock returned is in the&#10;              format (mode, len, start, whence, pid) where mode is a&#10;              character representing the type of lock ('r' or 'w')&#10;&#10;      note: - the '?' modifier prevents a region from being locked; it is&#10;              query only">
			</Overload>
		</KeyWord>
		<KeyWord name="posixfile.SEEK_CUR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixfile.SEEK_END" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixfile.fileopen" func="yes">
			<Overload retVal="" descr="Public routine to get a posixfile object from a Python file object.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixfile.open" func="yes">
			<Overload retVal="" descr="Public routine to open a file as a posixfile object.">
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[bufsize=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath" func="yes">
			<Overload retVal="" descr='Common operations on Posix pathnames.&#10;&#10;Instead of importing this module directly, import os and refer to&#10;this module as os.path.  The "os.path" name is an alias for this&#10;module on Posix systems; on other systems (e.g. Mac, Windows),&#10;os.path provides the same operations in a manner specific to that&#10;platform, and is an alias to another module (e.g. macpath, ntpath).&#10;&#10;Some of this can actually be useful on non-Posix systems too, e.g.&#10;for manipulation of the pathname component of URLs.'>
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.abspath" func="yes">
			<Overload retVal="" descr="Return an absolute path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.basename" func="yes">
			<Overload retVal="" descr="Returns the final component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.dirname" func="yes">
			<Overload retVal="" descr="Returns the directory component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.expanduser" func="yes">
			<Overload retVal="" descr="Expand ~ and ~user constructions.  If user or $HOME is unknown,&#10;do nothing.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.expandvars" func="yes">
			<Overload retVal="" descr="Expand shell variables of form $var and ${var}.  Unknown variables&#10;are left unchanged.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.isabs" func="yes">
			<Overload retVal="" descr="Test whether a path is absolute">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.islink" func="yes">
			<Overload retVal="" descr="Test whether a path is a symbolic link">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.ismount" func="yes">
			<Overload retVal="" descr="Test whether a path is a mount point">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.join" func="yes">
			<Overload retVal="" descr="Join two or more pathname components, inserting '/' as needed.&#10;If any component is an absolute path, all previous path components&#10;will be discarded.  An empty last part will result in a path that&#10;ends with a separator.">
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns True for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.normcase" func="yes">
			<Overload retVal="" descr="Normalize case of pathname.  Has no effect under Posix">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize path, eliminating double slashes, etc.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.realpath" func="yes">
			<Overload retVal="" descr="Return the canonical path of the specified filename, eliminating any&#10;symbolic links encountered in the path.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.relpath" func="yes">
			<Overload retVal="" descr="Return a relative version of a path">
				<Param name="path" />
				<Param name="[start=.]" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.samefile" func="yes">
			<Overload retVal="" descr="Test whether two pathnames reference the same actual file">
				<Param name="f1" />
				<Param name="f2" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.sameopenfile" func="yes">
			<Overload retVal="" descr="Test whether two open file objects reference the same file">
				<Param name="fp1" />
				<Param name="fp2" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.samestat" func="yes">
			<Overload retVal="" descr="Test whether two stat buffers reference the same file">
				<Param name="s1" />
				<Param name="s2" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.split" func="yes">
			<Overload retVal="" descr='Split a pathname.  Returns tuple "(head, tail)" where "tail" is&#10;everything after the final slash.  Either part may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.splitdrive" func="yes">
			<Overload retVal="" descr="Split a pathname into drive and path. On Posix, drive is always&#10;empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.walk" func="yes">
			<Overload retVal="" descr="Directory tree walk with callback function.&#10;&#10;For each directory in the directory tree rooted at top (including top&#10;itself, but excluding '.' and '..'), call func(arg, dirname, fnames).&#10;dirname is the name of the directory, and fnames a list of the names of&#10;the files and subdirectories in dirname (excluding '.' and '..').  func&#10;may modify the fnames list in-place (e.g. via del or slice assignment),&#10;and walk will only recurse into the subdirectories whose names remain in&#10;fnames; this can be used to implement a filter, or to impose a specific&#10;order of visiting.  No semantics are defined for, or required of, arg,&#10;beyond that arg is always passed to func.  It can be used, e.g., to pass&#10;a filename pattern, or a mutable object designed to accumulate&#10;statistics.  Passing None for arg is common.">
				<Param name="top" />
				<Param name="func" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="post_mortem" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="pow" func="yes">
			<Overload retVal="" descr="pow(x, y[, z]) -&gt; number&#10;&#10;With two arguments, equivalent to x**y.  With three arguments,&#10;equivalent to (x**y) % z, but may be more efficient (e.g. for longs).">
			</Overload>
		</KeyWord>
		<KeyWord name="power" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint" func="yes">
			<Overload retVal="" descr="Support to pretty-print lists, tuples, &amp; dictionaries recursively.&#10;&#10;Very simple, but useful, especially in debugging data structures.&#10;&#10;Classes&#10;-------&#10;&#10;PrettyPrinter()&#10;    Handle pretty-printing operations onto a stream using a configured&#10;    set of formatting parameters.&#10;&#10;Functions&#10;---------&#10;&#10;pformat()&#10;    Format a Python object into a pretty-printed representation.&#10;&#10;pprint()&#10;    Pretty-print a Python object to a stream [default is sys.stdout].&#10;&#10;saferepr()&#10;    Generate a 'standard' repr()-like value, but protect against recursive&#10;    data structures.">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.PrettyPrinter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.isreadable" func="yes">
			<Overload retVal="" descr="Determine if saferepr(object) is readable by eval().">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.isrecursive" func="yes">
			<Overload retVal="" descr="Determine if object requires a recursive representation.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.pformat" func="yes">
			<Overload retVal="" descr="Format a Python object into a pretty-printed representation.">
				<Param name="object" />
				<Param name="[indent=1" />
				<Param name="[width=80" />
				<Param name="[depth=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.pprint" func="yes">
			<Overload retVal="" descr="Pretty-print a Python object to a stream [default is sys.stdout].">
				<Param name="object" />
				<Param name="[stream=None" />
				<Param name="[indent=1" />
				<Param name="[width=80" />
				<Param name="[depth=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.saferepr" func="yes">
			<Overload retVal="" descr="Version of repr() which can handle recursive data structures.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="prcal" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="print" />
		<KeyWord name="printErrorList" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="printErrors" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="print_arguments" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_directory" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_environ" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_environ_usage" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_exc" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_exception" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_form" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_help" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="print_last" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_line" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="print_list" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="print_tb" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_usage" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="print_version" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="printdir" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="printhdr" func="yes">
			<Overload retVal="" descr="Function of sunaudio">
			</Overload>
		</KeyWord>
		<KeyWord name="printtoken" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="prmonth" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="process" func="yes">
			<Overload retVal="" descr="Function of logging.LoggerAdapter">
			</Overload>
		</KeyWord>
		<KeyWord name="process_tokens" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="processor" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="profile" func="yes">
			<Overload retVal="" descr="Class for profiling Python code.">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Profile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Stats" />
		<KeyWord name="profile.help" />
		<KeyWord name="profile.main" />
		<KeyWord name="profile.run" func="yes">
			<Overload retVal="" descr='Run statement under profiler optionally saving results in filename&#10;&#10;This function takes a single argument that can be passed to the&#10;"exec" statement, and an optional file name.  In all cases this&#10;routine attempts to "exec" its first argument and gather profiling&#10;statistics from the execution. If no file name is present, then this&#10;function automatically prints a simple profiling report, sorted by the&#10;standard name string (file/line/function-name) that is presented in&#10;each line.'>
				<Param name="statement" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.runctx" func="yes">
			<Overload retVal="" descr="Run statement under profiler, supplying your own globals and locals,&#10;optionally saving results in filename.&#10;&#10;statement and filename have the same semantics as profile.run">
				<Param name="statement" />
				<Param name="globals" />
				<Param name="locals" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="propagate" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="property" func="yes">
			<Overload retVal="" descr="property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute&#10;&#10;fget is a function to be used for getting an attribute value, and likewise&#10;fset is a function for setting, and fdel a function for del'ing, an&#10;attribute.  Typical use is to define a managed attribute x:&#10;&#10;class C(object):&#10;    def getx(self): return self._x&#10;    def setx(self, value): self._x = value&#10;    def delx(self): del self._x&#10;    x = property(getx, setx, delx, &quot;I'm the 'x' property.&quot;)&#10;&#10;Decorators make defining new properties or modifying existing ones easy:&#10;&#10;class C(object):&#10;    @property&#10;    def x(self):&#10;        &quot;I am the 'x' property.&quot;&#10;        return self._x&#10;    @x.setter&#10;    def x(self, value):&#10;        self._x = value&#10;    @x.deleter&#10;    def x(self):&#10;        del self._x">
			</Overload>
		</KeyWord>
		<KeyWord name="proxy" func="yes">
			<Overload retVal="" descr="Function of weakref">
			</Overload>
		</KeyWord>
		<KeyWord name="proxy_bypass" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="proxy_bypass_environment" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="proxy_bypass_registry" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="prweek" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="pryear" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats" func="yes">
			<Overload retVal="" descr="Class for printing reports on profiled python code.">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.TupleComp" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.add_callers" func="yes">
			<Overload retVal="" descr="Combine two caller lists in a single list.">
				<Param name="target" />
				<Param name="source" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.add_func_stats" func="yes">
			<Overload retVal="" descr="Add together all the stats for two profile entries.">
				<Param name="target" />
				<Param name="source" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.cmp_to_key" func="yes">
			<Overload retVal="" descr="Convert a cmp= function into a key= function">
				<Param name="mycmp" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.count_calls" func="yes">
			<Overload retVal="" descr="Sum the caller statistics to get total number of calls received.">
				<Param name="callers" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.f8" />
		<KeyWord name="pstats.func_get_function_name" />
		<KeyWord name="pstats.func_std_string" />
		<KeyWord name="pstats.func_strip_path" />
		<KeyWord name="pu" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="purge" func="yes">
			<Overload retVal="" descr="Function of sre">
			</Overload>
		</KeyWord>
		<KeyWord name="push" func="yes">
			<Overload retVal="" descr="Function of turtle.Tbuffer">
			</Overload>
		</KeyWord>
		<KeyWord name="putenv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile" func="yes">
			<Overload retVal="" descr='Routine to "compile" a .py file to a .pyc (or .pyo) file.&#10;&#10;This module has intimate knowledge of the format of .pyc files.'>
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.MAGIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.PyCompileError" func="yes">
			<Overload retVal="" descr="Exception raised when an error occurs while attempting to&#10;compile the file.&#10;&#10;To raise this exception, use&#10;&#10;    raise PyCompileError(exc_type,exc_value,file[,msg])&#10;&#10;where&#10;&#10;    exc_type:   exception type to be used in error message&#10;                type name can be accesses as class variable&#10;                'exc_type_name'&#10;&#10;    exc_value:  exception value to be used in error message&#10;                can be accesses as class variable 'exc_value'&#10;&#10;    file:       name of file being compiled to be used in error message&#10;                can be accesses as class variable 'file'&#10;&#10;    msg:        string message to be written as error message&#10;                If no value is given, a default exception message will be given,&#10;                consistent with 'standard' py_compile output.&#10;                message (or default) can be accesses as class variable 'msg'">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.PyCompileError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.PyCompileError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.compile" func="yes">
			<Overload retVal="" descr="Byte-compile one Python source file to Python bytecode.&#10;&#10;Arguments:&#10;&#10;file:    source filename&#10;cfile:   target filename; defaults to source with 'c' or 'o' appended&#10;         ('c' normally, 'o' in optimizing mode, giving .pyc or .pyo)&#10;dfile:   purported filename; defaults to source (this is the filename&#10;         that will show up in error messages)&#10;doraise: flag indicating whether or not an exception should be&#10;         raised when a compile error is found. If an exception&#10;         occurs and this flag is set to False, a string&#10;         indicating the nature of the exception will be printed,&#10;         and the function will return to the caller. If an&#10;         exception occurs and this flag is set to True, a&#10;         PyCompileError exception will be raised.&#10;&#10;Note that it isn't necessary to byte-compile Python modules for&#10;execution efficiency -- Python itself byte-compiles a module when&#10;it is loaded, and if it can, writes out the bytecode to the&#10;corresponding .pyc (or .pyo) file.&#10;&#10;However, if a Python installation is shared between users, it is a&#10;good idea to byte-compile all modules upon installation, since&#10;other users may not be able to write in the source directories,&#10;and thus they won't be able to write the .pyc/.pyo file, and then&#10;they would be byte-compiling every module each time it is loaded.&#10;This can slow down program start-up considerably.&#10;&#10;See compileall.py for a script/module that uses this module to&#10;byte-compile all installed files (or all files in selected&#10;directories).">
				<Param name="file" />
				<Param name="[cfile=None" />
				<Param name="[dfile=None" />
				<Param name="[doraise=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.main" func="yes">
			<Overload retVal="" descr="Compile several source files.&#10;&#10;The files named in 'args' (or on the command line, if 'args' is&#10;not specified) are compiled and the resulting bytecode is cached&#10;in the normal manner.  This function does not search a directory&#10;structure to locate source files; it only compiles files named&#10;explicitly.  If '-' is the only parameter in args, the list of&#10;files is taken from standard input.">
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.wr_long" func="yes">
			<Overload retVal="" descr="Internal; write a 32-bit int to a file in little-endian order.">
				<Param name="f" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="py_suffix_importer" func="yes">
			<Overload retVal="" descr="Function of imputil">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr" func="yes">
			<Overload retVal="" descr="Parse a Python module and describe its classes and methods.&#10;&#10;Parse enough of a Python file to recognize imports and class and&#10;method definitions, and to find out the superclasses of a class.&#10;&#10;The interface consists of a single function:&#10;        readmodule_ex(module [, path])&#10;where module is the name of a Python module, and path is an optional&#10;list of directories where the module is to be searched.  If present,&#10;path is prepended to the system search path sys.path.  The return&#10;value is a dictionary.  The keys of the dictionary are the names of&#10;the classes defined in the module (including classes that are defined&#10;via the from XXX import YYY construct).  The values are class&#10;instances of the class Class defined here.  One special key/value pair&#10;is present for packages: the key '__path__' has a list as its value&#10;which contains the package search path.&#10;&#10;A class is described by the class Class in this module.  Instances&#10;of this class have the following instance variables:&#10;        module -- the module name&#10;        name -- the name of the class&#10;        super -- a list of super classes (Class instances)&#10;        methods -- a dictionary of methods&#10;        file -- the file in which the class was defined&#10;        lineno -- the line in the file on which the class statement occurred&#10;The dictionary of methods uses the method names as keys and the line&#10;numbers on which the method was defined as values.&#10;If the name of a super class is not recognized, the corresponding&#10;entry in the list of super classes is not a class instance but a&#10;string giving the name of the super class.  Since import statements&#10;are recognized and imported modules are scanned as well, this&#10;shouldn't happen often.&#10;&#10;A function is described by the class Function in this module.&#10;Instances of this class have the following instance variables:&#10;        module -- the module name&#10;        name -- the name of the class&#10;        file -- the file in which the class was defined&#10;        lineno -- the line in the file on which the class statement occurred">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.Class" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.Function" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.OP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.itemgetter" func="yes">
			<Overload retVal="" descr="itemgetter(item, ...) --&gt; itemgetter object&#10;&#10;Return a callable object that fetches the given item(s) from its operand.&#10;After f = itemgetter(2), the call f(r) returns r[2].&#10;After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.readmodule" func="yes">
			<Overload retVal="" descr="Backwards compatible interface.&#10;&#10;Call readmodule_ex() and then only keep Class objects from the&#10;resulting dictionary.">
				<Param name="module" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.readmodule_ex" func="yes">
			<Overload retVal="" descr="Read a module file and return a dictionary of classes.&#10;&#10;Search for MODULE in PATH and sys.path, read and parse the&#10;module and return a dictionary with one entry for each class&#10;found in the module.">
				<Param name="module" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc" func="yes">
			<Overload retVal="" descr='Generate Python documentation in HTML or text for interactive use.&#10;&#10;In the Python interpreter, do "from pydoc import help" to provide online&#10;help.  Calling help(thing) on a Python object documents the object.&#10;&#10;Or, at the shell command line outside of Python:&#10;&#10;Run "pydoc &lt;name&gt;" to show documentation on something.  &lt;name&gt; may be&#10;the name of a function, module, package, or a dotted reference to a&#10;class or function within a module or module in a package.  If the&#10;argument contains a path segment delimiter (e.g. slash on Unix,&#10;backslash on Windows) it is treated as the path to a Python source file.&#10;&#10;Run "pydoc -k &lt;keyword&gt;" to search for a keyword in the synopsis lines&#10;of all available modules.&#10;&#10;Run "pydoc -p &lt;port&gt;" to start an HTTP server on a given port on the&#10;local machine to generate documentation web pages.  Port number 0 can be&#10;used to get an arbitrary unused port.&#10;&#10;For platforms without a command line, "pydoc -g" starts the HTTP server&#10;and also pops up a little window for controlling it.&#10;&#10;Run "pydoc -w &lt;name&gt;" to write out the HTML documentation for a module&#10;to a file named "&lt;name&gt;.html".&#10;&#10;Module docs for core modules are assumed to be in&#10;&#10;    http://docs.python.org/library/&#10;&#10;This can be overridden by setting the PYTHONDOCS environment variable&#10;to a different URL or to a local directory containing the Library&#10;Reference Manual pages.'>
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ErrorDuringImport" func="yes">
			<Overload retVal="" descr="Errors that occurred while trying to import something to document it.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ErrorDuringImport.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ErrorDuringImport.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLRepr" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ModuleScanner" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Repr" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Scanner" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextRepr" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.allmethods" />
		<KeyWord name="pydoc.apropos" func="yes">
			<Overload retVal="" descr="Print all the one-line module summaries that contain a substring.">
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.classify_class_attrs" func="yes">
			<Overload retVal="" descr="Wrap inspect.classify_class_attrs, with fixup for data descriptors.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.classname" func="yes">
			<Overload retVal="" descr="Get a class name and qualify it with a module name if necessary.">
				<Param name="object" />
				<Param name="modname" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.cli" func="yes">
			<Overload retVal="" descr="Command-line interface (looks at sys.argv to decide what to do).">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.cram" func="yes">
			<Overload retVal="" descr="Omit part of a string if needed to make it fit in a maximum length.">
				<Param name="text" />
				<Param name="maxlen" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;Build an ordered collection with optimized access from its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.describe" func="yes">
			<Overload retVal="" descr="Produce a short description of the given thing.">
				<Param name="thing" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.doc" func="yes">
			<Overload retVal="" descr="Display text documentation, given an object or a path to an object.">
				<Param name="thing" />
				<Param name="[title=Python Library Documentation: %s" />
				<Param name="[forceload=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.expandtabs" func="yes">
			<Overload retVal="" descr="expandtabs(s [,tabsize]) -&gt; string&#10;&#10;Return a copy of the string s with all tab characters replaced&#10;by the appropriate number of spaces, depending on the current&#10;column, and the tabsize (default 8).">
				<Param name="s" />
				<Param name="[tabsize=8]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.extract_tb" func="yes">
			<Overload retVal="" descr="Return list of up to limit pre-processed entries from traceback.&#10;&#10;This is useful for alternate formatting of stack traces.  If&#10;'limit' is omitted or None, all entries are extracted.  A&#10;pre-processed stack trace entry is a quadruple (filename, line&#10;number, function name, text) representing the information that is&#10;usually printed for a stack trace.  The text is a string with&#10;leading and trailing whitespace stripped; if the source is not&#10;available it is None.">
				<Param name="tb" />
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.find" func="yes">
			<Overload retVal="" descr="find(s, sub [,start [,end]]) -&gt; in&#10;&#10;Return the lowest index in s where substring sub is found,&#10;such that sub is contained within s[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.getdoc" func="yes">
			<Overload retVal="" descr="Get the doc string or comments for an object.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.getpager" func="yes">
			<Overload retVal="" descr="Decide what method to use for paging through text.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.gui" func="yes">
			<Overload retVal="" descr="Graphical interface (starts web server and pops up a control window).">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.help" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.html" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.importfile" func="yes">
			<Overload retVal="" descr="Import a Python source file or compiled file given its path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.isdata" func="yes">
			<Overload retVal="" descr="Check if an object is of a type that probably means it's data.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ispackage" func="yes">
			<Overload retVal="" descr="Guess whether a path refers to a package directory.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ispath" />
		<KeyWord name="pydoc.join" func="yes">
			<Overload retVal="" descr="join(list [,sep]) -&gt; string&#10;&#10;Return a string composed of the words in list, with&#10;intervening occurrences of sep.  The default separator is a&#10;single space.&#10;&#10;(joinfields and join are synonymous)">
				<Param name="words" />
				<Param name="[sep= ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.locate" func="yes">
			<Overload retVal="" descr="Locate an object by name or dotted path, importing as necessary.">
				<Param name="path" />
				<Param name="[forceload=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.lower" func="yes">
			<Overload retVal="" descr="lower(s) -&gt; string&#10;&#10;Return a copy of the string s converted to lowercase.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.pager" func="yes">
			<Overload retVal="" descr="The first time this is called, determine what kind of pager to use.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.pathdirs" func="yes">
			<Overload retVal="" descr="Convert sys.path into a list of absolute, existing, unique paths.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.pipepager" func="yes">
			<Overload retVal="" descr="Page through text by feeding it to another program.">
				<Param name="text" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.plain" func="yes">
			<Overload retVal="" descr="Remove boldface formatting from text.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.plainpager" func="yes">
			<Overload retVal="" descr="Simply print unformatted text.  This is the ultimate fallback.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.render_doc" func="yes">
			<Overload retVal="" descr="Render text documentation, given an object or a path to an object.">
				<Param name="thing" />
				<Param name="[title=Python Library Documentation: %s" />
				<Param name="[forceload=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.replace" func="yes">
			<Overload retVal="" descr="Do a series of global replacements on a string.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.resolve" func="yes">
			<Overload retVal="" descr="Given an object or a path to an object, get the object and its name.">
				<Param name="thing" />
				<Param name="[forceload=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.rfind" func="yes">
			<Overload retVal="" descr="rfind(s, sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in s where substring sub is found,&#10;such that sub is contained within s[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.rstrip" func="yes">
			<Overload retVal="" descr="rstrip(s [,chars]) -&gt; string&#10;&#10;Return a copy of the string s with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
				<Param name="s" />
				<Param name="[chars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.safeimport" func="yes">
			<Overload retVal="" descr="Import a module; handle errors; return None if the module isn't found.&#10;&#10;If the module *is* found but an exception occurs, it's wrapped in an&#10;ErrorDuringImport exception and reraised.  Unlike __import__, if a&#10;package path is specified, the module at the end of the path is returned,&#10;not the package at the beginning.  If the optional 'forceload' argument&#10;is 1, we reload the module from disk (unless it's a dynamic extension).">
				<Param name="path" />
				<Param name="[forceload=0" />
				<Param name="[cache={}]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.serve" func="yes">
			<Overload retVal="" descr=>
				<Param name="port" />
				<Param name="[callback=None" />
				<Param name="[completer=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.source_synopsis" />
		<KeyWord name="pydoc.split" func="yes">
			<Overload retVal="" descr="split(s [,sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string s, using sep as the&#10;delimiter string.  If maxsplit is given, splits at no more than&#10;maxsplit places (resulting in at most maxsplit+1 words).  If sep&#10;is not specified or is None, any whitespace string is a separator.&#10;&#10;(split and splitfields are synonymous)">
				<Param name="s" />
				<Param name="[sep=None" />
				<Param name="[maxsplit=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.splitdoc" func="yes">
			<Overload retVal="" descr="Split a doc string into a synopsis line (if any) and the rest.">
				<Param name="doc" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.strip" func="yes">
			<Overload retVal="" descr="strip(s [,chars]) -&gt; string&#10;&#10;Return a copy of the string s with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping.">
				<Param name="s" />
				<Param name="[chars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.stripid" func="yes">
			<Overload retVal="" descr="Remove the hexadecimal id from a Python object representation.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.synopsis" func="yes">
			<Overload retVal="" descr="Get the one-line summary out of a module file.">
				<Param name="filename" />
				<Param name="[cache={}]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.tempfilepager" func="yes">
			<Overload retVal="" descr="Page through text by invoking a program on a temporary file.">
				<Param name="text" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.text" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ttypager" func="yes">
			<Overload retVal="" descr="Page through text on a text terminal.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.visiblename" func="yes">
			<Overload retVal="" descr="Decide whether to show documentation on a variable.">
				<Param name="name" />
				<Param name="[all=None" />
				<Param name="[obj=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.writedoc" func="yes">
			<Overload retVal="" descr="Write HTML documentation to a file in the current directory.">
				<Param name="thing" />
				<Param name="[forceload=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.writedocs" func="yes">
			<Overload retVal="" descr="Write out HTML documentation for all modules in a directory tree.">
				<Param name="dir" />
				<Param name="[pkgpath" />
				<Param name="[done=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc_data" />
		<KeyWord name="pyexpat" func="yes">
			<Overload retVal="" descr="Python wrapper for Expat parser.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.EXPAT_VERSION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ErrorString" func="yes">
			<Overload retVal="" descr="ErrorString(errno) -&gt; string&#10;Returns string error for given number.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ExpatError" />
		<KeyWord name="pyexpat.ExpatError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ExpatError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ParserCreate" func="yes">
			<Overload retVal="" descr="ParserCreate([encoding[, namespace_separator]]) -&gt; parser&#10;Return a new XML parser object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType" func="yes">
			<Overload retVal="" descr="XML parser">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XML_PARAM_ENTITY_PARSING_ALWAYS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.error" />
		<KeyWord name="pyexpat.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.expat_CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.features" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.native_encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.version_info" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="python_branch" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_build" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_compiler" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_implementation" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_revision" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_version" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_version_tuple" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="quantize" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="quit" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri" func="yes">
			<Overload retVal="" descr="Conversions to/from quoted-printable transport encoding as per RFC 1521.">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.ESCAPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.HEX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.MAXLINESIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.a2b_qp" func="yes">
			<Overload retVal="" descr="Decode a string of qp-encoded data">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.b2a_qp" func="yes">
			<Overload retVal="" descr="b2a_qp(data, quotetabs=0, istext=1, header=0) -&gt; s; &#10; Encode a string using quoted-printable encoding. &#10;&#10;On encoding, when istext is set, newlines are not encoded, and white &#10;space at end of lines is.  When istext is not set, \r and \n (CR/LF) are &#10;both encoded.  When quotetabs is set, space and tabs are encoded.">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.decode" func="yes">
			<Overload retVal="" descr="Read 'input', apply quoted-printable decoding, and write to 'output'.&#10;'input' and 'output' are files with readline() and write() methods.&#10;If 'header' is true, decode underscore as space (per RFC 1522).">
				<Param name="input" />
				<Param name="output" />
				<Param name="[header=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.decodestring" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[header=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.encode" func="yes">
			<Overload retVal="" descr="Read 'input', apply quoted-printable encoding, and write to 'output'.&#10;&#10;'input' and 'output' are files with readline() and write() methods.&#10;The 'quotetabs' flag indicates whether embedded tabs and spaces should be&#10;quoted.  Note that line-ending tabs and spaces are always encoded, as per&#10;RFC 1521.&#10;The 'header' flag indicates whether we are encoding spaces as _ as per&#10;RFC 1522.">
				<Param name="input" />
				<Param name="output" />
				<Param name="quotetabs" />
				<Param name="[header=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.encodestring" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[quotetabs=0" />
				<Param name="[header=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.ishex" func="yes">
			<Overload retVal="" descr="Return true if the character 'c' is a hexadecimal digit.">
				<Param name="c" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.main" />
		<KeyWord name="quopri.needsquoting" func="yes">
			<Overload retVal="" descr="Decide whether a particular character needs to be quoted.&#10;&#10;The 'quotetabs' flag indicates whether embedded tabs and spaces should be&#10;quoted.  Note that line-ending tabs and spaces are always encoded, as per&#10;RFC 1521.">
				<Param name="c" />
				<Param name="quotetabs" />
				<Param name="header" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.quote" func="yes">
			<Overload retVal="" descr="Quote a single character.">
				<Param name="c" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.unhex" func="yes">
			<Overload retVal="" descr="Get the integer value of a hexadecimal number.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="quote" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="quote_plus" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="quoteaddr" func="yes">
			<Overload retVal="" descr="Function of smtplib">
			</Overload>
		</KeyWord>
		<KeyWord name="quotedata" func="yes">
			<Overload retVal="" descr="Function of smtplib">
			</Overload>
		</KeyWord>
		<KeyWord name="radians" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="radix" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="raise" />
		<KeyWord name="raise_conversion_error" func="yes">
			<Overload retVal="" descr="Function of xdrlib">
			</Overload>
		</KeyWord>
		<KeyWord name="randint" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="random" func="yes">
			<Overload retVal="" descr="Random variable generators.&#10;&#10;    integers&#10;    --------&#10;           uniform within range&#10;&#10;    sequences&#10;    ---------&#10;           pick random element&#10;           pick random sample&#10;           generate random permutation&#10;&#10;    distributions on the real line:&#10;    ------------------------------&#10;           uniform&#10;           triangular&#10;           normal (Gaussian)&#10;           lognormal&#10;           negative exponential&#10;           gamma&#10;           beta&#10;           pareto&#10;           Weibull&#10;&#10;    distributions on the circle (angles 0 to 2pi)&#10;    ---------------------------------------------&#10;           circular uniform&#10;           von Mises&#10;&#10;General notes on the underlying Mersenne Twister core generator:&#10;&#10;* The period is 2**19937-1.&#10;* It is one of the most extensively tested generators in existence.&#10;* Without a direct way to compute N steps forward, the semantics of&#10;  jumpahead(n) are weakened to simply jump to another distant state and rely&#10;  on the large period to avoid overlapping sequences.&#10;* The random() method is implemented in C, executes in a single Python step,&#10;  and is, therefore, threadsafe.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.BPF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.LOG4" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.NV_MAGICCONST" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.RECIP_BPF" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random" func="yes">
			<Overload retVal="" descr="Random number generator base class used by bound module functions.&#10;&#10;Used to instantiate instances of Random to get generators that don't&#10;share state.  Especially useful for multi-threaded programs, creating&#10;a different instance of Random for each thread, and using the jumpahead()&#10;method to ensure that the generated sequences seen by each thread don't&#10;overlap.&#10;&#10;Class Random can also be subclassed if you want to use a different basic&#10;generator of your own devising: in that case, override the following&#10;methods: random(), seed(), getstate(), setstate() and jumpahead().&#10;Optionally, implement a getrandbits() method so that randrange() can cover&#10;arbitrarily large ranges.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates a long int with k random bits.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.getstate" func="yes">
			<Overload retVal="" descr="Return internal state; can be passed to setstate() later.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.jumpahead" func="yes">
			<Overload retVal="" descr="Change the internal state to one that is likely far away&#10;from the current state.  This method will not be in Py3.x,&#10;so it is better to simply reseed.">
				<Param name="self" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.random" func="yes">
			<Overload retVal="" descr="random() -&gt; x in the interval [0, 1).">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<type 'int'>" />
				<Param name="[_maxwidth=9007199254740992]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use xrange as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(xrange(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.seed" func="yes">
			<Overload retVal="" descr="Initialize internal state from hashable object.&#10;&#10;None or no argument seeds from current time or from an operating&#10;system specific randomness source if available.&#10;&#10;If a is not None or an int or long, hash(a) is used instead.">
				<Param name="self" />
				<Param name="[a=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.setstate" func="yes">
			<Overload retVal="" descr="Restore internal state from object returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.shuffle" func="yes">
			<Overload retVal="" descr="x, random=random.random -&gt; shuffle list x in place; return None.&#10;&#10;Optional arg random is a 0-argument function returning a random&#10;float in [0.0, 1.0); by default, the standard random.random.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SG_MAGICCONST" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom" func="yes">
			<Overload retVal="" descr="Alternate random number generator using sources provided&#10;by the operating system (such as /dev/urandom on Unix or&#10;CryptGenRandom on Windows).&#10;&#10; Not available on all systems (see os.urandom() for details).">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates a long int with k random bits.">
				<Param name="self" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.getstate" func="yes">
			<Overload retVal="" descr="Method should not be called for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.jumpahead" func="yes">
			<Overload retVal="" descr="Stub method.  Not used for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.random" func="yes">
			<Overload retVal="" descr="Get the next random number in the range [0.0, 1.0).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<type 'int'>" />
				<Param name="[_maxwidth=9007199254740992]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use xrange as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(xrange(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.seed" func="yes">
			<Overload retVal="" descr="Stub method.  Not used for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.setstate" func="yes">
			<Overload retVal="" descr="Method should not be called for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.shuffle" func="yes">
			<Overload retVal="" descr="x, random=random.random -&gt; shuffle list x in place; return None.&#10;&#10;Optional arg random is a 0-argument function returning a random&#10;float in [0.0, 1.0); by default, the standard random.random.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.TWOPI" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill" />
		<KeyWord name="random.WichmannHill.VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates a long int with k random bits.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.getstate" func="yes">
			<Overload retVal="" descr="Return internal state; can be passed to setstate() later.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.jumpahead" func="yes">
			<Overload retVal="" descr="Act as if n calls to random() were made, but quickly.&#10;&#10;n is an int, greater than or equal to 0.&#10;&#10;Example use:  If you have 2 threads and know that each will&#10;consume no more than a million random numbers, create two Random&#10;objects r1 and r2, then do&#10;    r2.setstate(r1.getstate())&#10;    r2.jumpahead(1000000)&#10;Then r1 and r2 will use guaranteed-disjoint segments of the full&#10;period.">
				<Param name="self" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.random" func="yes">
			<Overload retVal="" descr="Get the next random number in the range [0.0, 1.0).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<type 'int'>" />
				<Param name="[_maxwidth=9007199254740992]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use xrange as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(xrange(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.seed" func="yes">
			<Overload retVal="" descr="Initialize internal state from hashable object.&#10;&#10;None or no argument seeds from current time or from an operating&#10;system specific randomness source if available.&#10;&#10;If a is not None or an int or long, hash(a) is used instead.&#10;&#10;If a is an int or long, a is used directly.  Distinct values between&#10;0 and 27814431486575L inclusive are guaranteed to yield distinct&#10;internal states (this guarantee is specific to the default&#10;Wichmann-Hill generator).">
				<Param name="self" />
				<Param name="[a=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.setstate" func="yes">
			<Overload retVal="" descr="Restore internal state from object returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.shuffle" func="yes">
			<Overload retVal="" descr="x, random=random.random -&gt; shuffle list x in place; return None.&#10;&#10;Optional arg random is a 0-argument function returning a random&#10;float in [0.0, 1.0); by default, the standard random.random.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.WichmannHill.whseed" func="yes">
			<Overload retVal="" descr="Seed from hashable object's hash code.&#10;&#10;None or no argument seeds from current time.  It is not guaranteed&#10;that objects with distinct hash codes lead to distinct internal&#10;states.&#10;&#10;This is obsolete, provided for compatibility with the seed routine&#10;used prior to Python 2.1.  Use the .seed() method instead.">
				<Param name="self" />
				<Param name="[a=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.division" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates a long int with k random bits.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.getstate" func="yes">
			<Overload retVal="" descr="Return internal state; can be passed to setstate() later.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.jumpahead" func="yes">
			<Overload retVal="" descr="Change the internal state to one that is likely far away&#10;from the current state.  This method will not be in Py3.x,&#10;so it is better to simply reseed.">
				<Param name="self" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.random" func="yes">
			<Overload retVal="" descr="random() -&gt; x in the interval [0, 1).">
			</Overload>
		</KeyWord>
		<KeyWord name="random.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<type 'int'>" />
				<Param name="[_maxwidth=9007199254740992]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use xrange as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(xrange(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.seed" func="yes">
			<Overload retVal="" descr="Initialize internal state from hashable object.&#10;&#10;None or no argument seeds from current time or from an operating&#10;system specific randomness source if available.&#10;&#10;If a is not None or an int or long, hash(a) is used instead.">
				<Param name="self" />
				<Param name="[a=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.setstate" func="yes">
			<Overload retVal="" descr="Restore internal state from object returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.shuffle" func="yes">
			<Overload retVal="" descr="x, random=random.random -&gt; shuffle list x in place; return None.&#10;&#10;Optional arg random is a 0-argument function returning a random&#10;float in [0.0, 1.0); by default, the standard random.random.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="randombytes" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="randrange" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="range" func="yes">
			<Overload retVal="" descr="range(stop) -&gt; list of integers&#10;range(start, stop[, step]) -&gt; list of integers&#10;&#10;Return a list containing an arithmetic progression of integers.&#10;range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.&#10;When step is given, it specifies the increment (or decrement).&#10;For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!&#10;These are exactly the valid indices for a list of 4 elements.">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_decode" func="yes">
			<Overload retVal="" descr="Function of json.JSONDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_input" func="yes">
			<Overload retVal="" descr="raw_input([prompt]) -&gt; string&#10;&#10;Read a string from standard input.  The trailing newline is stripped.&#10;If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.&#10;On Unix, GNU readline is used if enabled.  The prompt string, if given,&#10;is printed without a trailing newline before reading.">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_unicode_escape_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_unicode_escape_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="re" func="yes">
			<Overload retVal="" descr="Support for regular expressions (RE).&#10;&#10;This module provides regular expression matching operations similar to&#10;those found in Perl.  It supports both 8-bit and Unicode strings; both&#10;the pattern and the strings being processed can contain null bytes and&#10;characters outside the US ASCII range.&#10;&#10;Regular expressions can contain both special and ordinary characters.&#10;Most ordinary characters, like &quot;A&quot;, &quot;a&quot;, or &quot;0&quot;, are the simplest&#10;regular expressions; they simply match themselves.  You can&#10;concatenate ordinary characters, so last matches the string 'last'.&#10;&#10;The special characters are:&#10;    &quot;.&quot;      Matches any character except a newline.&#10;    &quot;^&quot;      Matches the start of the string.&#10;    &quot;$&quot;      Matches the end of the string or just before the newline at&#10;             the end of the string.&#10;    &quot;*&quot;      Matches 0 or more (greedy) repetitions of the preceding RE.&#10;             Greedy means that it will match as many repetitions as possible.&#10;    &quot;+&quot;      Matches 1 or more (greedy) repetitions of the preceding RE.&#10;    &quot;?&quot;      Matches 0 or 1 (greedy) of the preceding RE.&#10;    *?,+?,?? Non-greedy versions of the previous three special characters.&#10;    {m,n}    Matches from m to n repetitions of the preceding RE.&#10;    {m,n}?   Non-greedy version of the above.&#10;    &quot;\\&quot;     Either escapes special characters or signals a special sequence.&#10;    []       Indicates a set of characters.&#10;             A &quot;^&quot; as the first character indicates a complementing set.&#10;    &quot;|&quot;      A|B, creates an RE that will match either A or B.&#10;    (...)    Matches the RE inside the parentheses.&#10;             The contents can be retrieved or matched later in the string.&#10;    (?iLmsux) Set the I, L, M, S, U, or X flag for the RE (see below).&#10;    (?:...)  Non-grouping version of regular parentheses.&#10;    (?P&lt;name&gt;...) The substring matched by the group is accessible by name.&#10;    (?P=name)     Matches the text matched earlier by the group named name.&#10;    (?#...)  A comment; ignored.&#10;    (?=...)  Matches if ... matches next, but doesn't consume the string.&#10;    (?!...)  Matches if ... doesn't match next.&#10;    (?&lt;=...) Matches if preceded by ... (must be fixed length).&#10;    (?&lt;!...) Matches if not preceded by ... (must be fixed length).&#10;    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,&#10;                       the (optional) no pattern otherwise.&#10;&#10;The special sequences consist of &quot;\\&quot; and a character from the list&#10;below.  If the ordinary character is not on the list, then the&#10;resulting RE will match the second character.&#10;    \number  Matches the contents of the group of the same number.&#10;    \A       Matches only at the start of the string.&#10;    \Z       Matches only at the end of the string.&#10;    \b       Matches the empty string, but only at the start or end of a word.&#10;    \B       Matches the empty string, but not at the start or end of a word.&#10;    \d       Matches any decimal digit; equivalent to the set [0-9].&#10;    \D       Matches any non-digit character; equivalent to the set [^0-9].&#10;    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v].&#10;    \S       Matches any non-whitespace character; equiv. to [^ \t\n\r\f\v].&#10;    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_].&#10;             With LOCALE, it will match the set [0-9_] plus characters defined&#10;             as letters for the current locale.&#10;    \W       Matches the complement of \w.&#10;    \\       Matches a literal backslash.&#10;&#10;This module exports the following functions:&#10;    match    Match a regular expression pattern to the beginning of a string.&#10;    search   Search a string for the presence of a pattern.&#10;    sub      Substitute occurrences of a pattern found in a string.&#10;    subn     Same as sub, but also return the number of substitutions made.&#10;    split    Split a string by the occurrences of a pattern.&#10;    findall  Find all occurrences of a pattern in a string.&#10;    finditer Return an iterator yielding a match object for each match.&#10;    compile  Compile a pattern into a RegexObject.&#10;    purge    Clear the regular expression cache.&#10;    escape   Backslash all non-alphanumerics in a string.&#10;&#10;Some of the functions in this module takes flags as optional parameters:&#10;    I  IGNORECASE  Perform case-insensitive matching.&#10;    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.&#10;    M  MULTILINE   &quot;^&quot; matches the beginning of lines (after a newline)&#10;                   as well as the string.&#10;                   &quot;$&quot; matches the end of lines (before a newline) as well&#10;                   as the end of the string.&#10;    S  DOTALL      &quot;.&quot; matches any character at all, including the newline.&#10;    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.&#10;    U  UNICODE     Make \w, \W, \b, \B, dependent on the Unicode locale.&#10;&#10;This module also defines an exception 'error'.">
			</Overload>
		</KeyWord>
		<KeyWord name="re.DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.I" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.L" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.M" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.S" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.Scanner" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.T" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.U" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.X" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.compile" func="yes">
			<Overload retVal="" descr="Compile a regular expression pattern, returning a pattern object.">
				<Param name="pattern" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.error" />
		<KeyWord name="re.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.escape" func="yes">
			<Overload retVal="" descr="Escape all non-alphanumeric characters in pattern.">
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.findall" func="yes">
			<Overload retVal="" descr="Return a list of all non-overlapping matches in the string.&#10;&#10;If one or more groups are present in the pattern, return a&#10;list of groups; this will be a list of tuples if the pattern&#10;has more than one group.&#10;&#10;Empty matches are included in the result.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.finditer" func="yes">
			<Overload retVal="" descr="Return an iterator over all non-overlapping matches in the&#10;string.  For each match, the iterator returns a match object.&#10;&#10;Empty matches are included in the result.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.match" func="yes">
			<Overload retVal="" descr="Try to apply the pattern at the start of the string, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.purge" func="yes">
			<Overload retVal="" descr="Clear the regular expression cache">
			</Overload>
		</KeyWord>
		<KeyWord name="re.search" func="yes">
			<Overload retVal="" descr="Scan through string looking for a match to the pattern, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.split" func="yes">
			<Overload retVal="" descr="Split the source string by the occurrences of the pattern,&#10;returning a list containing the resulting substrings.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[maxsplit=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.sub" func="yes">
			<Overload retVal="" descr="Return the string obtained by replacing the leftmost&#10;non-overlapping occurrences of the pattern in string by the&#10;replacement repl.  repl can be either a string or a callable;&#10;if a string, backslash escapes in it are processed.  If it is&#10;a callable, it's passed the match object and must return&#10;a replacement string to be used.">
				<Param name="pattern" />
				<Param name="repl" />
				<Param name="string" />
				<Param name="[count=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.subn" func="yes">
			<Overload retVal="" descr="Return a 2-tuple containing (new_string, number).&#10;new_string is the string obtained by replacing the leftmost&#10;non-overlapping occurrences of the pattern in the source&#10;string by the replacement repl.  number is the number of&#10;substitutions that were made. repl can be either a string or a&#10;callable; if a string, backslash escapes in it are processed.&#10;If it is a callable, it's passed the match object and must&#10;return a replacement string to be used.">
				<Param name="pattern" />
				<Param name="repl" />
				<Param name="string" />
				<Param name="[count=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.template" func="yes">
			<Overload retVal="" descr="Compile a template pattern, returning a pattern object">
				<Param name="pattern" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="reach" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="read1" func="yes">
			<Overload retVal="" descr="Function of io.BufferedReader">
			</Overload>
		</KeyWord>
		<KeyWord name="read32" func="yes">
			<Overload retVal="" descr="Function of gzip">
			</Overload>
		</KeyWord>
		<KeyWord name="readPlist" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="readPlistFromResource" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="readPlistFromString" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="read_code" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="read_decimalnl_long" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_decimalnl_short" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_docstrings" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="read_float8" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_floatnl" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_int4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_long1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_long4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_mime_types" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="read_string1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_string4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_stringnl" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_stringnl_noescape" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_stringnl_noescape_pair" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_uint1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_uint2" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_unicodestring4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_unicodestringnl" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="readable" func="yes">
			<Overload retVal="" descr="Function of io.StringIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readall" func="yes">
			<Overload retVal="" descr="Function of io.FileIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readbuffer_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="readconfig" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="reader" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="readmailcapfile" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="readmodule" func="yes">
			<Overload retVal="" descr="Function of pyclbr">
			</Overload>
		</KeyWord>
		<KeyWord name="readmodule_ex" func="yes">
			<Overload retVal="" descr="Function of pyclbr">
			</Overload>
		</KeyWord>
		<KeyWord name="readwrite" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="realpath" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="recv" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="recv_into" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="recvfrom" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="recvfrom_into" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="reduce" func="yes">
			<Overload retVal="" descr="reduce(function, sequence[, initial]) -&gt; value&#10;&#10;Apply a function of two arguments cumulatively to the items of a sequence,&#10;from left to right, so as to reduce the sequence to a single value.&#10;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#10;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#10;of the sequence in the calculation, and serves as a default when the&#10;sequence is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="register" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="registerResult" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="register_X_browsers" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="register_adapter" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="register_archive_format" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="register_converter" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="register_dialect" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="register_error" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="register_optionflag" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="register_shape" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="reindent" func="yes">
			<Overload retVal="" descr="Function of timeit">
			</Overload>
		</KeyWord>
		<KeyWord name="release" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="reload" func="yes">
			<Overload retVal="" descr="reload(module) -&gt; module&#10;&#10;Reload the module.  The module must have been successfully imported before.">
			</Overload>
		</KeyWord>
		<KeyWord name="relpath" func="yes">
			<Overload retVal="" descr="Function of posixpath">
			</Overload>
		</KeyWord>
		<KeyWord name="remainder" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="remainder_near" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="remove" func="yes">
			<Overload retVal="" descr="B.remove(int) -&gt; None&#10;&#10;Remove the first occurance of a value in B.">
			</Overload>
		</KeyWord>
		<KeyWord name="removeFilter" func="yes">
			<Overload retVal="" descr="Function of logging.Handler">
			</Overload>
		</KeyWord>
		<KeyWord name="removeHandler" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="removeResult" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_duplicates" func="yes">
			<Overload retVal="" descr="Function of SimpleXMLRPCServer">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_extension" func="yes">
			<Overload retVal="" descr="Function of copy_reg">
			</Overload>
		</KeyWord>
		<KeyWord name="removedirs" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="removeduppaths" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="rename" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="renames" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="render_doc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="repeat" func="yes">
			<Overload retVal="" descr="Function of timeit">
			</Overload>
		</KeyWord>
		<KeyWord name="replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="replace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="reporthook" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="repr" func="yes">
			<Overload retVal="" descr="repr(object) -&gt; string&#10;&#10;Return the canonical string representation of the object.&#10;For most object types, eval(repr(object)) == object.">
			</Overload>
		</KeyWord>
		<KeyWord name="repr.Repr" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="repr.aRepr" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="repr.islice" func="yes">
			<Overload retVal="" descr="islice(iterable, [start,] stop [, step]) --&gt; islice object&#10;&#10;Return an iterator whose next() method returns selected values from an&#10;iterable.  If start is specified, will skip all preceding elements;&#10;otherwise, start defaults to zero.  Step defaults to one.  If&#10;specified as another value, step determines how many values are &#10;skipped between successive calls.  Works like a slice() on a list&#10;but returns an iterator.">
			</Overload>
		</KeyWord>
		<KeyWord name="repr.islice.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="repr.repr" />
		<KeyWord name="request_host" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="request_path" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="request_port" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="reset" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="resetlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="resetscreen" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="resetwarnings" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="resize" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="resizemode" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="resolve" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="resolve_dotted_attribute" func="yes">
			<Overload retVal="" descr="Function of SimpleXMLRPCServer">
			</Overload>
		</KeyWord>
		<KeyWord name="restore" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="return" />
		<KeyWord name="reverse" func="yes">
			<Overload retVal="" descr="B.reverse() -&gt; None&#10;&#10;Reverse the order of the values in B in place.">
			</Overload>
		</KeyWord>
		<KeyWord name="reversed" func="yes">
			<Overload retVal="" descr="reversed(sequence) -&gt; reverse iterator over values of the sequence&#10;&#10;Return a reverse iterator">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec" func="yes">
			<Overload retVal="" descr="Restricted execution facilities.&#10;&#10;The class RExec exports methods r_exec(), r_eval(), r_execfile(), and&#10;r_import(), which correspond roughly to the built-in operations&#10;exec, eval(), execfile() and import, but executing the code in an&#10;environment that only exposes those built-in operations that are&#10;deemed safe.  To this end, a modest collection of 'fake' modules is&#10;created which mimics the standard modules by the same names.  It is a&#10;policy decision which built-in modules and operations are made&#10;available; this module provides a reasonable default, but derived&#10;classes can change the policies e.g. by overriding or extending class&#10;variables like ok_builtin_modules or methods like make_sys().&#10;&#10;XXX To do:&#10;- r_open should allow writing tmp dir&#10;- r_exec etc. with explicit globals/locals? (Use rexec(&quot;exec ... in ...&quot;)?)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.FileBase" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.FileDelegate" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.FileWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.RExec" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.RHooks" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.RModuleImporter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.RModuleLoader" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.TEMPLATE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="rexec.test" />
		<KeyWord name="rfc822" func="yes">
			<Overload retVal="" descr="RFC 2822 message manipulation.&#10;&#10;Note: This is only a very rough sketch of a full RFC-822 parser; in particular&#10;the tokenizing of addresses does not adhere to all the quoting rules.&#10;&#10;Note: RFC 2822 is a long awaited update to RFC 822.  This module should&#10;conform to RFC 2822, and is thus mis-named (it's not worth renaming it).  Some&#10;effort at RFC 2822 updates have been made, but a thorough audit has not been&#10;performed.  Consider any RFC 2822 non-conformance to be a bug.&#10;&#10;    RFC 2822: http://www.faqs.org/rfcs/rfc2822.html&#10;    RFC 822 : http://www.faqs.org/rfcs/rfc822.html (obsolete)&#10;&#10;Directions for use:&#10;&#10;To create a Message object: first open a file, e.g.:&#10;&#10;  fp = open(file, 'r')&#10;&#10;You can use any other legal way of getting an open file object, e.g. use&#10;sys.stdin or call os.popen().  Then pass the open file object to the Message()&#10;constructor:&#10;&#10;  m = Message(fp)&#10;&#10;This class can work with any input object that supports a readline method.  If&#10;the input object has seek and tell capability, the rewindbody method will&#10;work; also illegal lines will be pushed back onto the input stream.  If the&#10;input object lacks seek but has an `unread' method that can push back a line&#10;of input, Message will use that to push back illegal lines.  Thus this class&#10;can be used to parse messages coming from a buffered stream.&#10;&#10;The optional `seekable' argument is provided as a workaround for certain stdio&#10;libraries in which tell() discards buffered data before discovering that the&#10;lseek() system call doesn't work.  For maximum portability, you should set the&#10;seekable argument to zero to prevent that initial \code{tell} when passing in&#10;an unseekable object such as a file object created from a socket object.  If&#10;it is 1 on entry -- which it is by default -- the tell() method of the open&#10;file object is called once; if this raises an exception, seekable is reset to&#10;0.  For other nonzero values of seekable, this test is not made.&#10;&#10;To get the text of a particular header there are several methods:&#10;&#10;  str = m.getheader(name)&#10;  str = m.getrawheader(name)&#10;&#10;where name is the name of the header, e.g. 'Subject'.  The difference is that&#10;getheader() strips the leading and trailing whitespace, while getrawheader()&#10;doesn't.  Both functions retain embedded whitespace (including newlines)&#10;exactly as they are specified in the header, and leave the case of the text&#10;unchanged.&#10;&#10;For addresses and address lists there are functions&#10;&#10;  realname, mailaddress = m.getaddr(name)&#10;  list = m.getaddrlist(name)&#10;&#10;where the latter returns a list of (realname, mailaddr) tuples.&#10;&#10;There is also a method&#10;&#10;  time = m.getdate(name)&#10;&#10;which parses a Date-like field and returns a time-compatible tuple,&#10;i.e. a tuple such as returned by time.localtime() or accepted by&#10;time.mktime().&#10;&#10;See the class definition for lower level access methods.&#10;&#10;There are also some utility functions here.">
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.AddressList" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.AddrlistClass" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.dump_address_pair" func="yes">
			<Overload retVal="" descr="Dump a (name, address) pair in a canonicalized form.">
				<Param name="pair" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.formatdate" func="yes">
			<Overload retVal="" descr="Returns time format preferred for Internet standards.&#10;&#10;Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123&#10;&#10;According to RFC 1123, day and month names must always be in&#10;English.  If not for that, this code could use strftime().  It&#10;can't because strftime() honors the locale and could generated&#10;non-English names.">
				<Param name="[timeval=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.mktime_tz" func="yes">
			<Overload retVal="" descr="Turn a 10-tuple as returned by parsedate_tz() into a UTC timestamp.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.parseaddr" func="yes">
			<Overload retVal="" descr="Parse an address into a (realname, mailaddr) tuple.">
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.parsedate" func="yes">
			<Overload retVal="" descr="Convert a time string to a time tuple.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.parsedate_tz" func="yes">
			<Overload retVal="" descr="Convert a date string to a time tuple.&#10;&#10;Accounts for military timezones.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.quote" func="yes">
			<Overload retVal="" descr="Add quotes around a string.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.unquote" func="yes">
			<Overload retVal="" descr="Remove quotes from a string.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfc822.warnpy3k" func="yes">
			<Overload retVal="" descr="Issue a deprecation warning for Python 3.x related changes.&#10;&#10;Warnings are omitted unless Python is started with the -3 option.">
				<Param name="message" />
				<Param name="[category=None" />
				<Param name="[stacklevel=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="rgb_to_hls" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="rgb_to_hsv" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="rgb_to_yiq" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="right" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="rindex" func="yes">
			<Overload retVal="" descr="B.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like B.rfind() but raise ValueError when the subsection is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="rjust" func="yes">
			<Overload retVal="" descr="B.rjust(width[, fillchar]) -&gt; copy of B&#10;&#10;Return B right justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter" func="yes">
			<Overload retVal="" descr="Word completion for GNU readline.&#10;&#10;The completer completes keywords, built-ins and globals in a selectable&#10;namespace (which defaults to __main__); when completing NAME.NAME..., it&#10;evaluates (!) the expression up to the last dot and completes its attributes.&#10;&#10;It's very cool to do &quot;import sys&quot; type &quot;sys.&quot;, hit the completion key (twice),&#10;and see the list of names defined by the sys module!&#10;&#10;Tip: to use the tab key as the completion key, call&#10;&#10;    readline.parse_and_bind(&quot;tab: complete&quot;)&#10;&#10;Notes:&#10;&#10;- Exceptions raised by the completer function are *ignored* (and generally cause&#10;  the completion to fail).  This is a feature -- since readline sets the tty&#10;  device in raw (or cbreak) mode, printing a traceback wouldn't work well&#10;  without some complicated hoopla to save, reset and restore the tty state.&#10;&#10;- The evaluation of the NAME.NAME... form may cause arbitrary application&#10;  defined code to be executed if an object with a __getattr__ hook is found.&#10;  Since it is the responsibility of the application (or the user) to enable this&#10;  feature, I consider this an acceptable risk.  More complicated expressions&#10;  (e.g. function calls or indexing operations) are *not* evaluated.&#10;&#10;- GNU readline is also used by the built-in functions input() and&#10;raw_input(), and thus these also benefit/suffer from the completer&#10;features.  Clearly an interactive application can benefit by&#10;specifying its own completer function and using raw_input() for all&#10;its input.&#10;&#10;- When the original stdin is not a tty device, GNU readline is never&#10;  used, and this module (and the readline module) are silently inactive.">
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter.Completer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter.get_class_members" />
		<KeyWord name="rmdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="rmtree" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="rnopen" func="yes">
			<Overload retVal="" descr="Function of bsddb">
			</Overload>
		</KeyWord>
		<KeyWord name="robotparser" func="yes">
			<Overload retVal="" descr="robotparser.py&#10;&#10;Copyright (C) 2000  Bastian Kleineidam&#10;&#10;You can choose between two licenses when using this package:&#10;1) GNU GPLv2&#10;2) PSF license for Python 2.2&#10;&#10;The robots.txt Exclusion Protocol is implemented as specified in&#10;http://www.robotstxt.org/norobots-rfc.txt">
			</Overload>
		</KeyWord>
		<KeyWord name="robotparser.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="robotparser.RobotFileParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="robotparser.RuleLine" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="robotparser.URLopener" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="rollback" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="rotate" func="yes">
			<Overload retVal="" descr="Function of shlex.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="round" func="yes">
			<Overload retVal="" descr="round(number[, ndigits]) -&gt; floating point number&#10;&#10;Round a number to a given precision in decimal digits (default 0 digits).&#10;This always returns a floating point number.  Precision may be negative.">
			</Overload>
		</KeyWord>
		<KeyWord name="roundfrac" func="yes">
			<Overload retVal="" descr="Function of fpformat">
			</Overload>
		</KeyWord>
		<KeyWord name="rowconfigure" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="rstrip" func="yes">
			<Overload retVal="" descr="B.rstrip([bytes]) -&gt; bytearray&#10;&#10;Strip trailing bytes contained in the argument.&#10;If the argument is omitted, strip trailing ASCII whitespace.">
			</Overload>
		</KeyWord>
		<KeyWord name="rt" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="run" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="runTest" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="runTests" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="run_docstring_examples" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="run_module" func="yes">
			<Overload retVal="" descr="Function of runpy">
			</Overload>
		</KeyWord>
		<KeyWord name="run_path" func="yes">
			<Overload retVal="" descr="Function of runpy">
			</Overload>
		</KeyWord>
		<KeyWord name="runcall" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="runctx" func="yes">
			<Overload retVal="" descr="Function of profile">
			</Overload>
		</KeyWord>
		<KeyWord name="runeval" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="runpy" func="yes">
			<Overload retVal="" descr="runpy.py - locating and running Python code using the module namespace&#10;&#10;Provides support for locating and running Python scripts using the Python&#10;module namespace instead of the native filesystem.&#10;&#10;This allows Python code to play nicely with non-filesystem based PEP 302&#10;importers when locating support scripts as well as when importing modules.">
			</Overload>
		</KeyWord>
		<KeyWord name="runpy.get_loader" func="yes">
			<Overload retVal="" descr='Get a PEP 302 "loader" object for module_or_name&#10;&#10;If the module or package is accessible via the normal import&#10;mechanism, a wrapper around the relevant part of that machinery&#10;is returned.  Returns None if the module cannot be found or imported.&#10;If the named module is not already imported, its containing package&#10;(if any) is imported, in order to establish the package __path__.&#10;&#10;This function uses iter_importers(), and is thus subject to the same&#10;limitations regarding platform-specific special import locations such&#10;as the Windows registry.'>
				<Param name="module_or_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="runpy.read_code" />
		<KeyWord name="runpy.run_module" func="yes">
			<Overload retVal="" descr="Execute a module's code without importing it&#10;&#10;Returns the resulting top level namespace dictionary">
				<Param name="mod_name" />
				<Param name="[init_globals=None" />
				<Param name="[run_name=None" />
				<Param name="[alter_sys=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="runpy.run_path" func="yes">
			<Overload retVal="" descr="Execute code located at the specified filesystem location&#10;&#10;Returns the resulting top level namespace dictionary&#10;&#10;The file path may refer directly to a Python script (i.e.&#10;one that could be directly executed with execfile) or else&#10;it may refer to a zipfile or directory containing a top&#10;level __main__.py script.">
				<Param name="path_name" />
				<Param name="[init_globals=None" />
				<Param name="[run_name=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="safeimport" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="saferepr" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="same_quantum" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="samefile" func="yes">
			<Overload retVal="" descr="Function of posixpath">
			</Overload>
		</KeyWord>
		<KeyWord name="sameopenfile" func="yes">
			<Overload retVal="" descr="Function of posixpath">
			</Overload>
		</KeyWord>
		<KeyWord name="samestat" func="yes">
			<Overload retVal="" descr="Function of posixpath">
			</Overload>
		</KeyWord>
		<KeyWord name="sample" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="scaleb" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="scanvars" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="sched" func="yes">
			<Overload retVal="" descr='A generally useful event scheduler class.&#10;&#10;Each instance of this class manages its own queue.&#10;No multi-threading is implied; you are supposed to hack that&#10;yourself, or use a single instance per application.&#10;&#10;Each instance is parametrized with two functions, one that is&#10;supposed to return the current time, one that is supposed to&#10;implement a delay.  You can implement real-time scheduling by&#10;substituting time and sleep from built-in module time, or you can&#10;implement simulated time by writing your own functions.  This can&#10;also be used to integrate scheduling with STDWIN events; the delay&#10;function is allowed to modify the queue.  Time can be expressed as&#10;integers or floating point numbers, as long as it is consistent.&#10;&#10;Events are specified by tuples (time, priority, action, argument).&#10;As in UNIX, lower priority numbers mean higher priority; in this&#10;way the queue can be maintained as a priority queue.  Execution of the&#10;event means calling the action function, passing it the argument&#10;sequence in "argument" (remember that in Python, multiple function&#10;arguments are be packed in a sequence).&#10;The action function may be an instance method so it&#10;has another way to reference private data (besides global variables).'>
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event" func="yes">
			<Overload retVal="" descr="Event(time, priority, action, argument)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.action" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.argument" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.priority" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.time" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
				<Param name="typename" />
				<Param name="field_names" />
				<Param name="[verbose=False" />
				<Param name="[rename=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sci" func="yes">
			<Overload retVal="" descr="Function of fpformat">
			</Overload>
		</KeyWord>
		<KeyWord name="screensize" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="script_from_examples" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="search" func="yes">
			<Overload retVal="" descr="Function of sre">
			</Overload>
		</KeyWord>
		<KeyWord name="search_function" func="yes">
			<Overload retVal="" descr="Function of encodings">
			</Overload>
		</KeyWord>
		<KeyWord name="seed" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="seekable" func="yes">
			<Overload retVal="" descr="Function of io.StringIO">
			</Overload>
		</KeyWord>
		<KeyWord name="select" func="yes">
			<Overload retVal="" descr="This module supports asynchronous I/O on multiple file descriptors.&#10;&#10;*** IMPORTANT NOTICE ***&#10;On Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors.">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error" />
		<KeyWord name="select.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.select" func="yes">
			<Overload retVal="" descr="select(rlist, wlist, xlist[, timeout]) -&gt; (rlist, wlist, xlist)&#10;&#10;Wait until one or more file descriptors are ready for some kind of I/O.&#10;The first three arguments are sequences of file descriptors to be waited for:&#10;rlist -- wait until ready for reading&#10;wlist -- wait until ready for writing&#10;xlist -- wait for an ``exceptional condition''&#10;If only one kind of condition is required, pass [] for the other lists.&#10;A file descriptor is either a socket or file object, or a small integer&#10;gotten from a fileno() method call on one of those.&#10;&#10;The optional 4th argument specifies a timeout in seconds; it may be&#10;a floating point number to specify fractions of seconds.  If it is absent&#10;or None, the call will never time out.&#10;&#10;The return value is a tuple of three lists corresponding to the first three&#10;arguments; each contains the subset of the corresponding file descriptors&#10;that are ready.&#10;&#10;*** IMPORTANT NOTICE ***&#10;On Windows and OpenVMS, only sockets are supported; on Unix, all file&#10;descriptors can be used.">
			</Overload>
		</KeyWord>
		<KeyWord name="selected_alpn_protocol" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="selected_npn_protocol" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="selection_clear" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="selection_get" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="selection_handle" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="selection_own" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="selection_own_get" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="send" func="yes">
			<Overload retVal="" descr="Function of SimpleDialog.GeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="send_signal" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="sendall" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="sendto" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="serve" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="session_stats" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set" func="yes">
			<Overload retVal="" descr="set() -&gt; new empty set object&#10;set(iterable) -&gt; new set object&#10;&#10;Build an unordered collection of unique elements.">
			</Overload>
		</KeyWord>
		<KeyWord name="setBEGINLIBPATH" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setDaemon" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="setFormatter" func="yes">
			<Overload retVal="" descr="Function of logging.StreamHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="setLevel" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="setLoggerClass" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="setName" func="yes">
			<Overload retVal="" descr="Function of threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="setUp" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="setUpClass" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="set_alpn_protocols" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_authorizer" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="set_ciphers" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_conversion_mode" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="set_default_verify_paths" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_defaults" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="set_ecdh_curve" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_errno" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="set_executable" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="set_last_error" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="set_name" func="yes">
			<Overload retVal="" descr="Function of logging.NullHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="set_npn_protocols" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_progress_handler" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="set_servername_callback" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_trace" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_unittest_reportflags" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="setattr" func="yes">
			<Overload retVal="" descr="setattr(object, name, value)&#10;&#10;Set a named attribute on an object; setattr(x, 'y', v) is equivalent to&#10;``x.y = v''.">
			</Overload>
		</KeyWord>
		<KeyWord name="setblocking" func="yes">
			<Overload retVal="" descr="Function of ssl.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="setcontext" func="yes">
			<Overload retVal="" descr="Function of decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="setcopyright" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="setdefaulttimeout" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="setencoding" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setfirstweekday" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="seth" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="setheading" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="sethelper" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setinputsizes" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="setlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="setoutputsize" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="setpassword" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="setpos" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="setposition" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="setprofile" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="setquit" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="sets" func="yes">
			<Overload retVal="" descr="Classes to represent arbitrary sets (including sets of sets).&#10;&#10;This module implements sets using dictionaries whose values are&#10;ignored.  The usual operations (union, intersection, deletion, etc.)&#10;are provided as both methods and operators.&#10;&#10;Important: sets are not sequences!  While they support 'x in s',&#10;'len(s)', and 'for x in s', none of those operations are unique for&#10;sequences; for example, mappings support all three as well.  The&#10;characteristic operation for sequences is subscripting with small&#10;integers: s[i], for i in range(len(s)).  Sets don't support&#10;subscripting at all.  Also, sequences allow multiple occurrences and&#10;their elements have a definite order; sets on the other hand don't&#10;record multiple occurrences and don't remember the order of element&#10;insertion (which is why they don't support s[i]).&#10;&#10;The following classes are provided:&#10;&#10;BaseSet -- All the operations common to both mutable and immutable&#10;    sets. This is an abstract class, not meant to be directly&#10;    instantiated.&#10;&#10;Set -- Mutable sets, subclass of BaseSet; not hashable.&#10;&#10;ImmutableSet -- Immutable sets, subclass of BaseSet; hashable.&#10;    An iterable argument is mandatory to create an ImmutableSet.&#10;&#10;_TemporarilyImmutableSet -- A wrapper around a Set, hashable,&#10;    giving the same hash value as the immutable set equivalent&#10;    would have.  Do not use this class directly.&#10;&#10;Only hashable objects can be added to a Set. In particular, you cannot&#10;really add a Set as an element to another Set; if you try, what is&#10;actually added is an ImmutableSet built from it (it compares equal to&#10;the one you tried adding).&#10;&#10;When you ask if `x in y' where x is a Set and y is a Set or&#10;ImmutableSet, x is wrapped into a _TemporarilyImmutableSet z, and&#10;what's tested is actually `z in y'.">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet" func="yes">
			<Overload retVal="" descr="Common base class for mutable and immutable sets.">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.difference" func="yes">
			<Overload retVal="" descr="Return the difference of two sets as a new Set.&#10;&#10;(I.e. all elements that are in this set and not in the other.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.intersection" func="yes">
			<Overload retVal="" descr="Return the intersection of two sets as a new set.&#10;&#10;(I.e. all elements that are in both sets.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.issubset" func="yes">
			<Overload retVal="" descr="Report whether another set contains this set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.issuperset" func="yes">
			<Overload retVal="" descr="Report whether this set contains another set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.symmetric_difference" func="yes">
			<Overload retVal="" descr="Return the symmetric difference of two sets as a new set.&#10;&#10;(I.e. all elements that are in exactly one of the sets.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.BaseSet.union" func="yes">
			<Overload retVal="" descr="Return the union of two sets as a new set.&#10;&#10;(I.e. all elements that are in either set.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet" func="yes">
			<Overload retVal="" descr="Immutable set class.">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.difference" func="yes">
			<Overload retVal="" descr="Return the difference of two sets as a new Set.&#10;&#10;(I.e. all elements that are in this set and not in the other.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.intersection" func="yes">
			<Overload retVal="" descr="Return the intersection of two sets as a new set.&#10;&#10;(I.e. all elements that are in both sets.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.issubset" func="yes">
			<Overload retVal="" descr="Report whether another set contains this set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.issuperset" func="yes">
			<Overload retVal="" descr="Report whether this set contains another set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.symmetric_difference" func="yes">
			<Overload retVal="" descr="Return the symmetric difference of two sets as a new set.&#10;&#10;(I.e. all elements that are in exactly one of the sets.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ImmutableSet.union" func="yes">
			<Overload retVal="" descr="Return the union of two sets as a new set.&#10;&#10;(I.e. all elements that are in either set.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set" func="yes">
			<Overload retVal="" descr="Mutable set class.">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.add" func="yes">
			<Overload retVal="" descr="Add an element to a set.&#10;&#10;This has no effect if the element is already present.">
				<Param name="self" />
				<Param name="element" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from this set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.difference" func="yes">
			<Overload retVal="" descr="Return the difference of two sets as a new Set.&#10;&#10;(I.e. all elements that are in this set and not in the other.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.difference_update" func="yes">
			<Overload retVal="" descr="Remove all elements of another set from this set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.discard" func="yes">
			<Overload retVal="" descr="Remove an element from a set if it is a member.&#10;&#10;If the element is not a member, do nothing.">
				<Param name="self" />
				<Param name="element" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.intersection" func="yes">
			<Overload retVal="" descr="Return the intersection of two sets as a new set.&#10;&#10;(I.e. all elements that are in both sets.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.intersection_update" func="yes">
			<Overload retVal="" descr="Update a set with the intersection of itself and another.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.issubset" func="yes">
			<Overload retVal="" descr="Report whether another set contains this set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.issuperset" func="yes">
			<Overload retVal="" descr="Report whether this set contains another set.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.pop" func="yes">
			<Overload retVal="" descr="Remove and return an arbitrary set element.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.remove" func="yes">
			<Overload retVal="" descr="Remove an element from a set; it must be a member.&#10;&#10;If the element is not a member, raise a KeyError.">
				<Param name="self" />
				<Param name="element" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.symmetric_difference" func="yes">
			<Overload retVal="" descr="Return the symmetric difference of two sets as a new set.&#10;&#10;(I.e. all elements that are in exactly one of the sets.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.symmetric_difference_update" func="yes">
			<Overload retVal="" descr="Update a set with the symmetric difference of itself and another.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.union" func="yes">
			<Overload retVal="" descr="Return the union of two sets as a new set.&#10;&#10;(I.e. all elements that are in either set.)">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.union_update" func="yes">
			<Overload retVal="" descr="Update a set with the union of itself and another.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.Set.update" func="yes">
			<Overload retVal="" descr="Add all values from an iterable (such as a list or file).">
				<Param name="self" />
				<Param name="iterable" />
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ifilter" func="yes">
			<Overload retVal="" descr="ifilter(function or None, sequence) --&gt; ifilter object&#10;&#10;Return those items of sequence for which function(item) is true.&#10;If function is None, return the items that are true.">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ifilter.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ifilterfalse" func="yes">
			<Overload retVal="" descr="ifilterfalse(function or None, sequence) --&gt; ifilterfalse object&#10;&#10;Return those items of sequence for which function(item) is false.&#10;If function is None, return the items that are false.">
			</Overload>
		</KeyWord>
		<KeyWord name="sets.ifilterfalse.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="setsockopt" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="setstate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="setter" func="yes">
			<Overload retVal="" descr="Descriptor to change the setter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="settiltangle" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="settimeout" func="yes">
			<Overload retVal="" descr="Function of ssl.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="settrace" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="setundobuffer" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="setup" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="setup_master" func="yes">
			<Overload retVal="" descr="Function of ttk">
			</Overload>
		</KeyWord>
		<KeyWord name="setvar" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="setworldcoordinates" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="setx" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="sety" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib" func="yes">
			<Overload retVal="" descr="A parser for SGML, using the derived class as a static DTD.">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.SGMLParseError" func="yes">
			<Overload retVal="" descr="Exception raised for all parse errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.SGMLParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.SGMLParseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.SGMLParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.TestSGMLParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.attrfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.charref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.endbracket" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.entityref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.incomplete" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.interesting" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.piclose" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.shorttag" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.shorttagopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.starttagopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.tagfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="sgmllib.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sha" />
		<KeyWord name="sha.blocksize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sha.digest_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sha.digestsize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sha.new" func="yes">
			<Overload retVal="" descr="Returns a sha1 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="sha.sha" func="yes">
			<Overload retVal="" descr="Returns a sha1 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="sha1" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha224" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha256" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha384" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha512" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="shape" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="shapesize" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve" func="yes">
			<Overload retVal="" descr="Manage shelves of pickled objects.&#10;&#10;A &quot;shelf&quot; is a persistent, dictionary-like object.  The difference&#10;with dbm databases is that the values (not the keys!) in a shelf can&#10;be essentially arbitrary Python objects -- anything that the &quot;pickle&quot;&#10;module can handle.  This includes most class instances, recursive data&#10;types, and objects containing lots of shared sub-objects.  The keys&#10;are ordinary strings.&#10;&#10;To summarize the interface (key is a string, data is an arbitrary&#10;object):&#10;&#10;        import shelve&#10;        d = shelve.open(filename) # open, with (g)dbm filename -- no suffix&#10;&#10;        d[key] = data   # store data at key (overwrites old data if&#10;                        # using an existing key)&#10;        data = d[key]   # retrieve a COPY of the data at key (raise&#10;                        # KeyError if no such key) -- NOTE that this&#10;                        # access returns a *copy* of the entry!&#10;        del d[key]      # delete data stored at key (raises KeyError&#10;                        # if no such key)&#10;        flag = d.has_key(key)   # true if the key exists; same as &quot;key in d&quot;&#10;        list = d.keys() # a list of all existing keys (slow!)&#10;&#10;        d.close()       # close it&#10;&#10;Dependent on the implementation, closing a persistent dictionary may&#10;or may not be necessary to flush changes to disk.&#10;&#10;Normally, d[key] returns a COPY of the entry.  This needs care when&#10;mutable entries are mutated: for example, if d[key] is a list,&#10;        d[key].append(anitem)&#10;does NOT modify the entry d[key] itself, as stored in the persistent&#10;mapping -- it only modifies the copy, which is then immediately&#10;discarded, so that the append has NO effect whatsoever.  To append an&#10;item to d[key] in a way that will affect the persistent mapping, use:&#10;        data = d[key]&#10;        data.append(anitem)&#10;        d[key] = data&#10;&#10;To avoid the problem with mutable entries, you may pass the keyword&#10;argument writeback=True in the call to shelve.open.  When you use:&#10;        d = shelve.open(filename, writeback=True)&#10;then d keeps a cache of all entries you access, and writes them all back&#10;to the persistent mapping when you call d.close().  This ensures that&#10;such usage as d[key].append(anitem) works as intended.&#10;&#10;However, using keyword argument writeback=True may consume vast amount&#10;of memory for the cache, and it may make d.close() very slow, if you&#10;access many of d's entries after opening it in this way: d has no way to&#10;check which of the entries you access are mutable and/or which ones you&#10;actually mutate, so it must cache, and write back at close, all of the&#10;entries that you access.  You can call d.sync() to write back all the&#10;entries in the cache, and empty the cache (d.sync() also synchronizes&#10;the persistent dictionary on disk, if feasible).">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BsdDbShelf" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.DbfilenameShelf" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler" func="yes">
			<Overload retVal="" descr="Pickler(file, protocol=0) -- Create a pickler.&#10;&#10;This takes a file-like object for writing a pickle data stream.&#10;The optional proto argument tells the pickler to use the given&#10;protocol; supported protocols are 0, 1, 2.  The default&#10;protocol is 0, to be backwards compatible.  (Protocol 0 is the&#10;only protocol that can be written to a file opened in text&#10;mode and read back successfully.  When using a protocol higher&#10;than 0, make sure the file is opened in binary mode, both when&#10;pickling and unpickling.)&#10;&#10;Protocol 1 is more efficient than protocol 0; protocol 2 is&#10;more efficient than protocol 1.&#10;&#10;Specifying a negative protocol version selects the highest&#10;protocol version supported.  The higher the protocol used, the&#10;more recent the version of Python needed to read the pickle&#10;produced.&#10;&#10;The file parameter must have a write() method that accepts a single&#10;string argument.  It can thus be an open file object, a StringIO&#10;object, or any other custom object that meets this interface.">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Shelf" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Unpickler" func="yes">
			<Overload retVal="" descr="Unpickler(file) -- Create an unpickler.">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.open" func="yes">
			<Overload retVal="" descr="Open a persistent dictionary for reading and writing.&#10;&#10;The filename parameter is the base filename for the underlying&#10;database.  As a side-effect, an extension may be added to the&#10;filename and more than one file may be created.  The optional flag&#10;parameter has the same interpretation as the flag parameter of&#10;anydbm.open(). The optional protocol parameter specifies the&#10;version of the pickle protocol (0, 1, or 2).&#10;&#10;See the module's __doc__ string for an overview of the interface.">
				<Param name="filename" />
				<Param name="[flag=c" />
				<Param name="[protocol=None" />
				<Param name="[writeback=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shift" func="yes">
			<Overload retVal="" descr="Function of fractions.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex" func="yes">
			<Overload retVal="" descr="A lexical analyzer class for simple shell-like syntaxes.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;Build an ordered collection with optimized access from its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.split" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[comments=False" />
				<Param name="[posix=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shortDescription" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="short_has_arg" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="show" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="showerror" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="showinfo" func="yes">
			<Overload retVal="" descr="Function of tkMessageBox">
			</Overload>
		</KeyWord>
		<KeyWord name="showturtle" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="showwarning" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="shuffle" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="shutdown" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil" func="yes">
			<Overload retVal="" descr="Utility functions for copying and archiving files and directory trees.&#10;&#10;XXX The functions here don't copy the resource fork or other metadata on Mac.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error" />
		<KeyWord name="shutil.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError" func="yes">
			<Overload retVal="" descr="Raised when a command could not be executed">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError" func="yes">
			<Overload retVal="" descr="Raised when trying to do a kind of operation (e.g. copying) which is&#10;not supported on a special file (e.g. a named pipe)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.abspath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copy" func="yes">
			<Overload retVal="" descr='Copy data and mode bits ("cp src dst").&#10;&#10;The destination may be a directory.'>
				<Param name="src" />
				<Param name="dst" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copy2" func="yes">
			<Overload retVal="" descr='Copy data and all stat info ("cp -p src dst").&#10;&#10;The destination may be a directory.'>
				<Param name="src" />
				<Param name="dst" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copyfile" func="yes">
			<Overload retVal="" descr="Copy data from src to dst">
				<Param name="src" />
				<Param name="dst" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copyfileobj" func="yes">
			<Overload retVal="" descr="copy data from file-like object fsrc to file-like object fdst">
				<Param name="fsrc" />
				<Param name="fdst" />
				<Param name="[length=16384]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copymode" func="yes">
			<Overload retVal="" descr="Copy mode bits from src to dst">
				<Param name="src" />
				<Param name="dst" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copystat" func="yes">
			<Overload retVal="" descr="Copy all stat info (mode bits, atime, mtime, flags) from src to dst">
				<Param name="src" />
				<Param name="dst" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copytree" func="yes">
			<Overload retVal="" descr="Recursively copy a directory tree using copy2().&#10;&#10;The destination directory must not already exist.&#10;If exception(s) occur, an Error is raised with a list of reasons.&#10;&#10;If the optional symlinks flag is true, symbolic links in the&#10;source tree result in symbolic links in the destination tree; if&#10;it is false, the contents of the files pointed to by symbolic&#10;links are copied.&#10;&#10;The optional ignore argument is a callable. If given, it&#10;is called with the `src` parameter, which is the directory&#10;being visited by copytree(), and `names` which is the list of&#10;`src` contents, as returned by os.listdir():&#10;&#10;    callable(src, names) -&gt; ignored_names&#10;&#10;Since copytree() is called recursively, the callable will be&#10;called once for each directory that is copied. It returns a&#10;list of names relative to the `src` directory that should&#10;not be copied.&#10;&#10;XXX Consider this example code rather than the ultimate tool.">
				<Param name="src" />
				<Param name="dst" />
				<Param name="[symlinks=False" />
				<Param name="[ignore=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.get_archive_formats" func="yes">
			<Overload retVal="" descr="Returns a list of supported formats for archiving and unarchiving.&#10;&#10;Each element of the returned sequence is a tuple (name, description)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ignore_patterns" func="yes">
			<Overload retVal="" descr="Function that can be used as copytree() ignore parameter.&#10;&#10;Patterns is a sequence of glob-style patterns&#10;that are used to exclude files">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.make_archive" func="yes">
			<Overload retVal="" descr="Create an archive file (eg. zip or tar).&#10;&#10;'base_name' is the name of the file to create, minus any format-specific&#10;extension; 'format' is the archive format: one of &quot;zip&quot;, &quot;tar&quot;, &quot;bztar&quot;&#10;or &quot;gztar&quot;.&#10;&#10;'root_dir' is a directory that will be the root directory of the&#10;archive; ie. we typically chdir into 'root_dir' before creating the&#10;archive.  'base_dir' is the directory where we start archiving from;&#10;ie. 'base_dir' will be the common prefix of all files and&#10;directories in the archive.  'root_dir' and 'base_dir' both default&#10;to the current directory.  Returns the name of the archive file.&#10;&#10;'owner' and 'group' are used when creating a tar archive. By default,&#10;uses the current owner and group.">
				<Param name="base_name" />
				<Param name="format" />
				<Param name="[root_dir=None" />
				<Param name="[base_dir=None" />
				<Param name="[verbose=0" />
				<Param name="[dry_run=0" />
				<Param name="[owner=None" />
				<Param name="[group=None" />
				<Param name="[logger=None]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.move" func="yes">
			<Overload retVal="" descr='Recursively move a file or directory to another location. This is&#10;similar to the Unix "mv" command.&#10;&#10;If the destination is a directory or a symlink to a directory, the source&#10;is moved inside the directory. The destination path must not already&#10;exist.&#10;&#10;If the destination already exists but is not a directory, it may be&#10;overwritten depending on os.rename() semantics.&#10;&#10;If the destination is on our current filesystem, then rename() is used.&#10;Otherwise, src is copied to the destination and then removed.&#10;A lot more could be done here...  A look at a mv.c shows a lot of&#10;the issues this implementation glosses over.'>
				<Param name="src" />
				<Param name="dst" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.register_archive_format" func="yes">
			<Overload retVal="" descr="Registers an archive format.&#10;&#10;name is the name of the format. function is the callable that will be&#10;used to create archives. If provided, extra_args is a sequence of&#10;(name, value) tuples that will be passed as arguments to the callable.&#10;description can be provided to describe the format, and will be returned&#10;by the get_archive_formats() function.">
				<Param name="name" />
				<Param name="function" />
				<Param name="[extra_args=None" />
				<Param name="[description]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.rmtree" func="yes">
			<Overload retVal="" descr="Recursively delete a directory tree.&#10;&#10;If ignore_errors is set, errors are ignored; otherwise, if onerror&#10;is set, it is called to handle the error with arguments (func,&#10;path, exc_info) where func is os.listdir, os.remove, or os.rmdir;&#10;path is the argument to that function that caused it to fail; and&#10;exc_info is a tuple returned by sys.exc_info().  If ignore_errors&#10;is false and onerror is None, an exception is raised.">
				<Param name="path" />
				<Param name="[ignore_errors=False" />
				<Param name="[onerror=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.unregister_archive_format" />
		<KeyWord name="simplefilter" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="simplegeneric" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="sin" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="sinh" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="site" func="yes">
			<Overload retVal="" descr="Append module search paths for third-party packages to sys.path.&#10;&#10;****************************************************************&#10;* This module is automatically imported during initialization. *&#10;****************************************************************&#10;&#10;In earlier versions of Python (up to 1.5a3), scripts or modules that&#10;needed to use site-specific modules would place ``import site''&#10;somewhere near the top of their code.  Because of the automatic&#10;import, this is no longer necessary (but code that does it still&#10;works).&#10;&#10;This will append site-specific paths to the module search path.  On&#10;Unix (including Mac OSX), it starts with sys.prefix and&#10;sys.exec_prefix (if different) and appends&#10;lib/python&lt;version&gt;/site-packages as well as lib/site-python.&#10;On other platforms (such as Windows), it tries each of the&#10;prefixes directly, as well as with lib/site-packages appended.  The&#10;resulting directories, if they exist, are appended to sys.path, and&#10;also inspected for path configuration files.&#10;&#10;A path configuration file is a file whose name has the form&#10;&lt;package&gt;.pth; its contents are additional directories (one per line)&#10;to be added to sys.path.  Non-existing directories (or&#10;non-directories) are never added to sys.path; no directory is added to&#10;sys.path more than once.  Blank lines and lines beginning with&#10;'#' are skipped. Lines starting with 'import' are executed.&#10;&#10;For example, suppose sys.prefix and sys.exec_prefix are set to&#10;/usr/local and there is a directory /usr/local/lib/python2.5/site-packages&#10;with three subdirectories, foo, bar and spam, and two path&#10;configuration files, foo.pth and bar.pth.  Assume foo.pth contains the&#10;following:&#10;&#10;  # foo package configuration&#10;  foo&#10;  bar&#10;  bletch&#10;&#10;and bar.pth contains:&#10;&#10;  # bar package configuration&#10;  bar&#10;&#10;Then the following directories are added to sys.path, in this order:&#10;&#10;  /usr/local/lib/python2.5/site-packages/bar&#10;  /usr/local/lib/python2.5/site-packages/foo&#10;&#10;Note that bletch is omitted because it doesn't exist; bar precedes foo&#10;because bar.pth comes alphabetically before foo.pth; and spam is&#10;omitted because it is not mentioned in either path configuration file.&#10;&#10;After these path manipulations, an attempt is made to import a module&#10;named sitecustomize, which can perform arbitrary additional&#10;site-specific customizations.  If this import fails with an&#10;ImportError exception, it is silently ignored.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.ENABLE_USER_SITE" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.PREFIXES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.USER_BASE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.USER_SITE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.addpackage" func="yes">
			<Overload retVal="" descr="Process a .pth file within the site-packages directory:&#10;For each line in the file, either combine it with sitedir to a path&#10;and add that to known_paths, or execute it if it starts with 'import '.">
				<Param name="sitedir" />
				<Param name="name" />
				<Param name="known_paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.addsitedir" func="yes">
			<Overload retVal="" descr="Add 'sitedir' argument to sys.path if missing and handle .pth files in&#10;'sitedir'">
				<Param name="sitedir" />
				<Param name="[known_paths=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.addsitepackages" func="yes">
			<Overload retVal="" descr="Add site-packages (and possibly site-python) to sys.path">
				<Param name="known_paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.addusersitepackages" func="yes">
			<Overload retVal="" descr="Add a per user site-package to sys.path&#10;&#10;Each user has its own python directory with site-packages in the&#10;home directory.">
				<Param name="known_paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.aliasmbcs" func="yes">
			<Overload retVal="" descr='On Windows, some default encodings are not provided by Python,&#10;while they are always available as "mbcs" in each locale. Make&#10;them usable by aliasing to "mbcs" in such a case.'>
			</Overload>
		</KeyWord>
		<KeyWord name="site.check_enableusersite" func="yes">
			<Overload retVal="" descr="Check if user site directory is safe for inclusion&#10;&#10;The function tests for the command line flag (including environment var),&#10;process uid/gid equal to effective uid/gid.&#10;&#10;None: Disabled for security reasons&#10;False: Disabled by user (command line option)&#10;True: Safe and enabled">
			</Overload>
		</KeyWord>
		<KeyWord name="site.execsitecustomize" func="yes">
			<Overload retVal="" descr="Run custom site specific code, if available.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.execusercustomize" func="yes">
			<Overload retVal="" descr="Run custom user specific code, if available.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.getsitepackages" func="yes">
			<Overload retVal="" descr="Returns a list containing all global site-packages directories&#10;(and possibly site-python).&#10;&#10;For each directory present in the global ``PREFIXES``, this function&#10;will find its `site-packages` subdirectory depending on the system&#10;environment, and will return a list of full paths.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.getuserbase" func="yes">
			<Overload retVal="" descr="Returns the `user base` directory path.&#10;&#10;The `user base` directory can be used to store data. If the global&#10;variable ``USER_BASE`` is not initialized yet, this function will also set&#10;it.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.getusersitepackages" func="yes">
			<Overload retVal="" descr="Returns the user-specific site-packages directory path.&#10;&#10;If the global variable ``USER_SITE`` is not initialized yet, this&#10;function will also set it.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.main" />
		<KeyWord name="site.makepath" />
		<KeyWord name="site.removeduppaths" func="yes">
			<Overload retVal="" descr="Remove duplicate entries from sys.path along with making them&#10;absolute">
			</Overload>
		</KeyWord>
		<KeyWord name="site.setBEGINLIBPATH" func="yes">
			<Overload retVal="" descr="The OS/2 EMX port has optional extension modules that do double duty&#10;as DLLs (and must use the .DLL file extension) for other extensions.&#10;The library search path needs to be amended so these will be found&#10;during module import.  Use BEGINLIBPATH so that these are at the start&#10;of the library search path.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.setcopyright" func="yes">
			<Overload retVal="" descr="Set 'copyright' and 'credits' in __builtin__">
			</Overload>
		</KeyWord>
		<KeyWord name="site.setencoding" func="yes">
			<Overload retVal="" descr="Set the string encoding used by the Unicode implementation.  The&#10;default is 'ascii', but if you're willing to experiment, you can&#10;change this.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.sethelper" />
		<KeyWord name="site.setquit" func="yes">
			<Overload retVal="" descr="Define new builtins 'quit' and 'exit'.&#10;&#10;These are objects which make the interpreter exit when called.&#10;The repr of each object contains a hint at how it works.">
			</Overload>
		</KeyWord>
		<KeyWord name="size" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="sizeof" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="skip" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="skipIf" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="skipTest" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="skipUnless" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="slaves" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="slice" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="small" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd" func="yes">
			<Overload retVal="" descr="An RFC 2821 smtp proxy.&#10;&#10;Usage: %(program)s [options] [localhost:localport [remotehost:remoteport]]&#10;&#10;Options:&#10;&#10;    --nosetuid&#10;    -n&#10;        This program generally tries to setuid `nobody', unless this flag is&#10;        set.  The setuid call will fail if this program is not run as root (in&#10;        which case, use this flag).&#10;&#10;    --version&#10;    -V&#10;        Print the version number and exit.&#10;&#10;    --class classname&#10;    -c classname&#10;        Use `classname' as the concrete SMTP proxy class.  Uses `PureProxy' by&#10;        default.&#10;&#10;    --debug&#10;    -d&#10;        Turn on debugging prints.&#10;&#10;    --help&#10;    -h&#10;        Print this message and exit.&#10;&#10;Version: %(__version__)s&#10;&#10;If localhost is not given then `localhost' is used, and if localport is not&#10;given then 8025 is used.  If remotehost is not given then `localhost' is used,&#10;and if remoteport is not given, then 25 is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.COMMASPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DEBUGSTREAM" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.Devnull" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.NEWLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.Options" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.parseargs" />
		<KeyWord name="smtpd.program" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="code" />
				<Param name="[msg]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib" func="yes">
			<Overload retVal="" descr='SMTP/ESMTP client class.&#10;&#10;This should follow RFC 821 (SMTP), RFC 1869 (ESMTP), RFC 2554 (SMTP&#10;Authentication) and RFC 2487 (Secure SMTP over TLS).&#10;&#10;Notes:&#10;&#10;Please remember, when doing ESMTP, that the names of the SMTP service&#10;extensions are NOT the same thing as the option keywords for the RCPT&#10;and MAIL commands!&#10;&#10;Example:&#10;&#10;  &gt;&gt;&gt; import smtplib&#10;  &gt;&gt;&gt; s=smtplib.SMTP("localhost")&#10;  &gt;&gt;&gt; print s.help()&#10;  This is Sendmail version 8.8.4&#10;  Topics:&#10;      HELO    EHLO    MAIL    RCPT    DATA&#10;      RSET    NOOP    QUIT    HELP    VRFY&#10;      EXPN    VERB    ETRN    DSN&#10;  For more info use "HELP &lt;topic&gt;".&#10;  To report bugs in the implementation send email to&#10;      sendmail-bugs@sendmail.org.&#10;  For local information send email to Postmaster at your site.&#10;  End of HELP info&#10;  &gt;&gt;&gt; s.putcmd("vrfy","someone@here")&#10;  &gt;&gt;&gt; s.getreply()&#10;  (250, "Somebody OverHere &lt;somebody@here.my.org&gt;")&#10;  &gt;&gt;&gt; s.quit()'>
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.OLDSTYLE_AUTH" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError" func="yes">
			<Overload retVal="" descr="Authentication error.&#10;&#10;Most probably the server didn't accept the username/password&#10;combination provided.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError" func="yes">
			<Overload retVal="" descr="Error during connection establishment.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError" func="yes">
			<Overload retVal="" descr="The SMTP server didn't accept the data.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException" func="yes">
			<Overload retVal="" descr="Base class for all exceptions raised by this module.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError" func="yes">
			<Overload retVal="" descr="The server refused our HELO reply.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused" func="yes">
			<Overload retVal="" descr="All recipient addresses refused.&#10;&#10;The errors for each recipient are accessible through the attribute&#10;'recipients', which is a dictionary of exactly the same sort as&#10;SMTP.sendmail() returns.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException" func="yes">
			<Overload retVal="" descr="Base class for all exceptions that include an SMTP error code.&#10;&#10;These exceptions are generated in some instances when the SMTP&#10;server returns an error code.  The error code is stored in the&#10;`smtp_code' attribute of the error, and the `smtp_error' attribute&#10;is set to the error message.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused" func="yes">
			<Overload retVal="" descr="Sender address refused.&#10;&#10;In addition to the attributes set by on all SMTPResponseException&#10;exceptions, this sets `sender' to the string that the SMTP refused.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected" func="yes">
			<Overload retVal="" descr="Not connected to any SMTP server.&#10;&#10;This exception is raised when the server unexpectedly disconnects,&#10;or when an attempt is made to use the SMTP instance before&#10;connecting it to a server.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SSLFakeFile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.encode_base64" func="yes">
			<Overload retVal="" descr='Encode a string with base64.&#10;&#10;Each line will be wrapped at, at most, maxlinelen characters (defaults to&#10;76 characters).&#10;&#10;If binary is False, end-of-line characters will be converted to the&#10;canonical email end-of-line sequence \r\n.  Otherwise they will be left&#10;verbatim (this is the default).&#10;&#10;Each line of encoded text will end with eol, which defaults to "\n".  Set&#10;this to "\r\n" if you will be using the result of this function directly&#10;in an email.'>
				<Param name="s" />
				<Param name="[binary=True" />
				<Param name="[maxlinelen=76" />
				<Param name="[eol=
]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.quoteaddr" func="yes">
			<Overload retVal="" descr="Quote a subset of the email addresses defined by RFC 821.&#10;&#10;Should be able to handle anything rfc822.parseaddr can handle.">
				<Param name="addr" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.quotedata" func="yes">
			<Overload retVal="" descr="Quote data for email.&#10;&#10;Double leading '.', and change Unix newline '\n', or Mac '\r' into&#10;Internet CRLF end-of-line.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.stderr" func="yes">
			<Overload retVal="" descr="(file)">
			</Overload>
		</KeyWord>
		<KeyWord name="snapshot_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr" func="yes">
			<Overload retVal="" descr="Routines to help recognizing sound files.&#10;&#10;Function whathdr() recognizes various types of sound file headers.&#10;It understands almost all headers that SOX can decode.&#10;&#10;The return tuple contains the following items, in this order:&#10;- file type (as SOX understands it)&#10;- sampling rate (0 if unknown or hard to decode)&#10;- number of channels (0 if unknown or hard to decode)&#10;- number of frames in the file (-1 if unknown or hard to decode)&#10;- number of bits/sample, or 'U' for U-LAW, or 'A' for A-LAW&#10;&#10;If the file doesn't have a recognizable type, it returns None.&#10;If the file can't be opened, IOError is raised.&#10;&#10;To compute the total time, divide the number of frames by the&#10;sampling rate (a frame contains a sample for each channel).&#10;&#10;Function what() calls whathdr().  (It used to also use some&#10;heuristics for raw data, but this doesn't work very well.)&#10;&#10;Finally, the function test() is a simple main program that calls&#10;what() for all files mentioned on the argument list.  For directory&#10;arguments it calls what() for all files in that directory.  Default&#10;argument is &quot;.&quot; (testing all files in the current directory).  The&#10;option -r tells it to recurse down directories found inside&#10;explicitly given directories.">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.get_long_be" />
		<KeyWord name="sndhdr.get_long_le" />
		<KeyWord name="sndhdr.get_short_be" />
		<KeyWord name="sndhdr.get_short_le" />
		<KeyWord name="sndhdr.test" />
		<KeyWord name="sndhdr.test_8svx" />
		<KeyWord name="sndhdr.test_aifc" />
		<KeyWord name="sndhdr.test_au" />
		<KeyWord name="sndhdr.test_hcom" />
		<KeyWord name="sndhdr.test_sndr" />
		<KeyWord name="sndhdr.test_sndt" />
		<KeyWord name="sndhdr.test_voc" />
		<KeyWord name="sndhdr.test_wav" />
		<KeyWord name="sndhdr.testall" />
		<KeyWord name="sndhdr.tests" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.what" func="yes">
			<Overload retVal="" descr="Guess the type of a sound file">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.whathdr" func="yes">
			<Overload retVal="" descr="Recognize sound headers">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket" func="yes">
			<Overload retVal="" descr="This module provides socket operations and some related functions.&#10;On Unix, it supports IP (Internet Protocol) and Unix domain sockets.&#10;On other systems, it only supports IP. Functions specific for a&#10;socket are available as methods of the socket object.&#10;&#10;Functions:&#10;&#10;socket() -- create a new socket object&#10;socketpair() -- create a pair of new socket objects [*]&#10;fromfd() -- create a socket object from an open file descriptor [*]&#10;gethostname() -- return the current hostname&#10;gethostbyname() -- map a hostname to its IP number&#10;gethostbyaddr() -- map an IP number or hostname to DNS info&#10;getservbyname() -- map a service name and a protocol name to a port number&#10;getprotobyname() -- map a protocol name (e.g. 'tcp') to a number&#10;ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order&#10;htons(), htonl() -- convert 16, 32 bit int from host to network byte order&#10;inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format&#10;inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)&#10;ssl() -- secure socket layer support (only available if configured)&#10;socket.getdefaulttimeout() -- get the default timeout value&#10;socket.setdefaulttimeout() -- set the default timeout value&#10;create_connection() -- connects to an address, with an optional timeout and&#10;                       optional source address.&#10;&#10; [*] not available on all platforms!&#10;&#10;Special objects:&#10;&#10;SocketType -- type object for socket objects&#10;error -- exception raised for I/O errors&#10;has_ipv6 -- boolean value indicating if IPv6 is supported&#10;&#10;Integer constants:&#10;&#10;AF_INET, AF_UNIX -- socket domains (first argument to socket() call)&#10;SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)&#10;&#10;Many other constants may be defined; these may be used in calls to&#10;the setsockopt() and getsockopt() methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_APPLETALK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_DECnet" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_INET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_INET6" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_IPX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_IRDA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_SNA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_ADDRCONFIG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_ALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_CANONNAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_NUMERICHOST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_NUMERICSERV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_PASSIVE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_V4MAPPED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_AGAIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_BADFLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_FAIL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_FAMILY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_MEMORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_NODATA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_NONAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_SERVICE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_SOCKTYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EBADF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EINTR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_ALLHOSTS_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_BROADCAST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_LOOPBACK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_MAX_LOCAL_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_NONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_UNSPEC_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPORT_RESERVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPORT_USERRESERVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_ICMP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_RAW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_TCP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_UDP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_CHECKSUM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_DONTFRAG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_HOPLIMIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_HOPOPTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_JOIN_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_LEAVE_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_MULTICAST_HOPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_MULTICAST_IF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_MULTICAST_LOOP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_PKTINFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_RECVRTHDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_RECVTCLASS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_RTHDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_TCLASS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_UNICAST_HOPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_V6ONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_ADD_MEMBERSHIP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_DROP_MEMBERSHIP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_HDRINCL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_MULTICAST_IF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_MULTICAST_LOOP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_MULTICAST_TTL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_OPTIONS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_RECVDSTADDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_TOS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_TTL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_CTRUNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_DONTROUTE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_OOB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_PEEK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_TRUNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_DGRAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_MAXHOST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_MAXSERV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NAMEREQD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NOFQDN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NUMERICHOST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NUMERICSERV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RAND_add" func="yes">
			<Overload retVal="" descr="RAND_add(string, entropy)&#10;&#10;Mix string into the OpenSSL PRNG state.  entropy (a float) is a lower&#10;bound on the entropy contained in string.  See RFC 1750.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RAND_status" func="yes">
			<Overload retVal="" descr="RAND_status() -&gt; 0 or 1&#10;&#10;Returns 1 if the OpenSSL PRNG has been seeded with enough data and 0 if not.&#10;It is necessary to seed the PRNG with RAND_add() on some platforms before&#10;using the ssl() function.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RCVALL_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RCVALL_ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RCVALL_SOCKETLEVELONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SHUT_RDWR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SHUT_WR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SIO_KEEPALIVE_VALS" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SIO_RCVALL" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_DGRAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_RAW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_RDM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_SEQPACKET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_STREAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOL_SOCKET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOL_TCP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOL_UDP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOMAXCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_ACCEPTCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_BROADCAST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_DONTROUTE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_EXCLUSIVEADDRUSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_KEEPALIVE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_LINGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_OOBINLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_RCVBUF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_RCVLOWAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_RCVTIMEO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_REUSEADDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_SNDBUF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_SNDLOWAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_SNDTIMEO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_TYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_USELOOPBACK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_EOF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_INVALID_ERROR_CODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_SSL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_SYSCALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_WANT_CONNECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_WANT_READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_WANT_WRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_WANT_X509_LOOKUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SSL_ERROR_ZERO_RETURN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType" func="yes">
			<Overload retVal="" descr="socket([family[, type[, proto]]]) -&gt; socket object&#10;&#10;Open a socket of the given type.  The family argument specifies the&#10;address family; it defaults to AF_INET.  The type argument specifies&#10;whether this is a stream (SOCK_STREAM, this is the default)&#10;or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,&#10;specifying the default protocol.  Keyword arguments are accepted.&#10;&#10;A socket object represents one endpoint of a network connection.&#10;&#10;Methods of socket objects (keyword arguments not allowed):&#10;&#10;accept() -- accept a connection, returning new socket and client address&#10;bind(addr) -- bind the socket to a local address&#10;close() -- close the socket&#10;connect(addr) -- connect the socket to a remote address&#10;connect_ex(addr) -- connect, return an error code instead of an exception&#10;dup() -- return a new socket object identical to the current one [*]&#10;fileno() -- return underlying file descriptor&#10;getpeername() -- return remote address [*]&#10;getsockname() -- return local address&#10;getsockopt(level, optname[, buflen]) -- get socket options&#10;gettimeout() -- return timeout or None&#10;listen(n) -- start listening for incoming connections&#10;makefile([mode, [bufsize]]) -- return a file object for the socket [*]&#10;recv(buflen[, flags]) -- receive data&#10;recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)&#10;recvfrom(buflen[, flags]) -- receive data and sender's address&#10;recvfrom_into(buffer[, nbytes, [, flags])&#10;  -- receive data and sender's address (into a buffer)&#10;sendall(data[, flags]) -- send all data&#10;send(data[, flags]) -- send data, may not send all of it&#10;sendto(data[, flags], addr) -- send data to a given address&#10;setblocking(0 | 1) -- set or clear the blocking I/O flag&#10;setsockopt(level, optname, value) -- set socket options&#10;settimeout(None | float) -- set or clear the timeout&#10;shutdown(how) -- shut down traffic in one or both directions&#10;&#10; [*] not available on all platforms!">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.accept" func="yes">
			<Overload retVal="" descr="accept() -&gt; (socket object, address info)&#10;&#10;Wait for an incoming connection.  Return a new socket representing the&#10;connection, and the address of the client.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
				<Param name="self" />
				<Param name="[_closedsocket=<class 'socket._closedsocket'>" />
				<Param name="[_delegate_methods=('recv', 'recvfrom', 'recv_into', 'recvfrom_into', 'send', 'sendto')" />
				<Param name="[setattr=<built-in function setattr>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.connect" func="yes">
			<Overload retVal="" descr="connect(address)&#10;&#10;Connect the socket to a remote address.  For IP sockets, the address&#10;is a pair (host, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.connect_ex" func="yes">
			<Overload retVal="" descr="connect_ex(address) -&gt; errno&#10;&#10;This is like connect(address), but returns an error code (the errno value)&#10;instead of raising an exception when an error occurs.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.dup" func="yes">
			<Overload retVal="" descr="dup() -&gt; socket object&#10;&#10;Return a new socket object connected to the same system resource.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.listen" func="yes">
			<Overload retVal="" descr="listen(backlog)&#10;&#10;Enable a server to accept connections.  The backlog argument must be at&#10;least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.makefile" func="yes">
			<Overload retVal="" descr="makefile([mode[, bufsize]]) -&gt; file object&#10;&#10;Return a regular file object corresponding to the socket.  The mode&#10;and bufsize arguments are as for the built-in open() function.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[bufsize=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.proto" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recv" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recv_into" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recvfrom" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recvfrom_into" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.send" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.sendto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer or a string.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.TCP_MAXSEG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.TCP_NODELAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.create_connection" func="yes">
			<Overload retVal="" descr="Connect to *address* and return the socket object.&#10;&#10;Convenience function.  Connect to *address* (a 2-tuple ``(host,&#10;port)``) and return the socket object.  Passing the optional&#10;*timeout* parameter will set the timeout on the socket instance&#10;before attempting to connect.  If no *timeout* is supplied, the&#10;global default timeout setting returned by :func:`getdefaulttimeout`&#10;is used.  If *source_address* is set it must be a tuple of (host, port)&#10;for the socket to bind as a source address before making the connection.&#10;An host of '' or port 0 tells the OS to use the default.">
				<Param name="address" />
				<Param name="[timeout=<object object at 0x00000000024AA130>" />
				<Param name="[source_address=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error" />
		<KeyWord name="socket.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.errorTab" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror" />
		<KeyWord name="socket.gaierror.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getaddrinfo" func="yes">
			<Overload retVal="" descr="getaddrinfo(host, port [, family, socktype, proto, flags])&#10;    -&gt; list of (family, socktype, proto, canonname, sockaddr)&#10;&#10;Resolve host and port into addrinfo struct.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getdefaulttimeout" func="yes">
			<Overload retVal="" descr="getdefaulttimeout() -&gt; timeout&#10;&#10;Returns the default timeout in seconds (float) for new socket objects.&#10;A value of None indicates that new socket objects have no timeout.&#10;When the socket module is first imported, the default is None.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getfqdn" func="yes">
			<Overload retVal="" descr="Get fully qualified domain name from name.&#10;&#10;An empty argument is interpreted as meaning the local host.&#10;&#10;First the hostname returned by gethostbyaddr() is checked, then&#10;possibly existing aliases. In case no FQDN is available, hostname&#10;from gethostname() is returned.">
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostbyaddr" func="yes">
			<Overload retVal="" descr="gethostbyaddr(host) -&gt; (name, aliaslist, addresslist)&#10;&#10;Return the true host name, a list of aliases, and a list of IP addresses,&#10;for a host.  The host argument is a string giving a host name or IP number.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostbyname" func="yes">
			<Overload retVal="" descr="gethostbyname(host) -&gt; address&#10;&#10;Return the IP address (a string of the form '255.255.255.255') for a host.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostbyname_ex" func="yes">
			<Overload retVal="" descr="gethostbyname_ex(host) -&gt; (name, aliaslist, addresslist)&#10;&#10;Return the true host name, a list of aliases, and a list of IP addresses,&#10;for a host.  The host argument is a string giving a host name or IP number.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostname" func="yes">
			<Overload retVal="" descr="gethostname() -&gt; string&#10;&#10;Return the current host name.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getnameinfo" func="yes">
			<Overload retVal="" descr="getnameinfo(sockaddr, flags) --&gt; (host, port)&#10;&#10;Get host and port for a sockaddr.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getprotobyname" func="yes">
			<Overload retVal="" descr="getprotobyname(name) -&gt; integer&#10;&#10;Return the protocol number for the named protocol.  (Rarely used.)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getservbyname" func="yes">
			<Overload retVal="" descr="getservbyname(servicename[, protocolname]) -&gt; integer&#10;&#10;Return a port number from a service name and protocol name.&#10;The optional protocol name, if given, should be 'tcp' or 'udp',&#10;otherwise any protocol will match.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getservbyport" func="yes">
			<Overload retVal="" descr="getservbyport(port[, protocolname]) -&gt; string&#10;&#10;Return the service name from a port number and protocol name.&#10;The optional protocol name, if given, should be 'tcp' or 'udp',&#10;otherwise any protocol will match.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.has_ipv6" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror" />
		<KeyWord name="socket.herror.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.htonl" func="yes">
			<Overload retVal="" descr="htonl(integer) -&gt; integer&#10;&#10;Convert a 32-bit integer from host to network byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.htons" func="yes">
			<Overload retVal="" descr="htons(integer) -&gt; integer&#10;&#10;Convert a 16-bit integer from host to network byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.inet_aton" func="yes">
			<Overload retVal="" descr="inet_aton(string) -&gt; packed 32-bit IP representation&#10;&#10;Convert an IP address in string format (123.45.67.89) to the 32-bit packed&#10;binary format used in low-level network functions.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.inet_ntoa" func="yes">
			<Overload retVal="" descr="inet_ntoa(packed_ip) -&gt; ip_address_string&#10;&#10;Convert an IP address from 32-bit packed binary format to string format">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.m" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.meth" />
		<KeyWord name="socket.ntohl" func="yes">
			<Overload retVal="" descr="ntohl(integer) -&gt; integer&#10;&#10;Convert a 32-bit integer from network to host byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.ntohs" func="yes">
			<Overload retVal="" descr="ntohs(integer) -&gt; integer&#10;&#10;Convert a 16-bit integer from network to host byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.p" func="yes">
			<Overload retVal="" descr="(partial)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.partial" func="yes">
			<Overload retVal="" descr="partial(func, *args, **keywords) - new function with partial application&#10;of the given arguments and keywords.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.partial.args" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.partial.func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.partial.keywords" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.setdefaulttimeout" func="yes">
			<Overload retVal="" descr="setdefaulttimeout(timeout)&#10;&#10;Set the default timeout in seconds (float) for new socket objects.&#10;A value of None indicates that new socket objects have no timeout.&#10;When the socket module is first imported, the default is None.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket" func="yes">
			<Overload retVal="" descr="socket([family[, type[, proto]]]) -&gt; socket object&#10;&#10;Open a socket of the given type.  The family argument specifies the&#10;address family; it defaults to AF_INET.  The type argument specifies&#10;whether this is a stream (SOCK_STREAM, this is the default)&#10;or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,&#10;specifying the default protocol.  Keyword arguments are accepted.&#10;&#10;A socket object represents one endpoint of a network connection.&#10;&#10;Methods of socket objects (keyword arguments not allowed):&#10;&#10;accept() -- accept a connection, returning new socket and client address&#10;bind(addr) -- bind the socket to a local address&#10;close() -- close the socket&#10;connect(addr) -- connect the socket to a remote address&#10;connect_ex(addr) -- connect, return an error code instead of an exception&#10;dup() -- return a new socket object identical to the current one [*]&#10;fileno() -- return underlying file descriptor&#10;getpeername() -- return remote address [*]&#10;getsockname() -- return local address&#10;getsockopt(level, optname[, buflen]) -- get socket options&#10;gettimeout() -- return timeout or None&#10;listen(n) -- start listening for incoming connections&#10;makefile([mode, [bufsize]]) -- return a file object for the socket [*]&#10;recv(buflen[, flags]) -- receive data&#10;recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)&#10;recvfrom(buflen[, flags]) -- receive data and sender's address&#10;recvfrom_into(buffer[, nbytes, [, flags])&#10;  -- receive data and sender's address (into a buffer)&#10;sendall(data[, flags]) -- send all data&#10;send(data[, flags]) -- send data, may not send all of it&#10;sendto(data[, flags], addr) -- send data to a given address&#10;setblocking(0 | 1) -- set or clear the blocking I/O flag&#10;setsockopt(level, optname, value) -- set socket options&#10;settimeout(None | float) -- set or clear the timeout&#10;shutdown(how) -- shut down traffic in one or both directions&#10;&#10; [*] not available on all platforms!">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.accept" func="yes">
			<Overload retVal="" descr="accept() -&gt; (socket object, address info)&#10;&#10;Wait for an incoming connection.  Return a new socket representing the&#10;connection, and the address of the client.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
				<Param name="self" />
				<Param name="[_closedsocket=<class 'socket._closedsocket'>" />
				<Param name="[_delegate_methods=('recv', 'recvfrom', 'recv_into', 'recvfrom_into', 'send', 'sendto')" />
				<Param name="[setattr=<built-in function setattr>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.connect" func="yes">
			<Overload retVal="" descr="connect(address)&#10;&#10;Connect the socket to a remote address.  For IP sockets, the address&#10;is a pair (host, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.connect_ex" func="yes">
			<Overload retVal="" descr="connect_ex(address) -&gt; errno&#10;&#10;This is like connect(address), but returns an error code (the errno value)&#10;instead of raising an exception when an error occurs.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.dup" func="yes">
			<Overload retVal="" descr="dup() -&gt; socket object&#10;&#10;Return a new socket object connected to the same system resource.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.listen" func="yes">
			<Overload retVal="" descr="listen(backlog)&#10;&#10;Enable a server to accept connections.  The backlog argument must be at&#10;least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.makefile" func="yes">
			<Overload retVal="" descr="makefile([mode[, bufsize]]) -&gt; file object&#10;&#10;Return a regular file object corresponding to the socket.  The mode&#10;and bufsize arguments are as for the built-in open() function.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[bufsize=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.proto" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recv" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recv_into" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recvfrom" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recvfrom_into" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.send" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.sendto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer or a string.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.ssl" func="yes">
			<Overload retVal="" descr=>
				<Param name="sock" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.sslerror" func="yes">
			<Overload retVal="" descr="An error occurred in the SSL implementation.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.sslerror.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.sslerror.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.sslerror.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.sslerror.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.sslerror.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout" />
		<KeyWord name="socket.timeout.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="softspace" func="yes">
			<Overload retVal="" descr="Function of code">
			</Overload>
		</KeyWord>
		<KeyWord name="sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="sortTestMethodsUsing" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="sorted" func="yes">
			<Overload retVal="" descr="sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list">
			</Overload>
		</KeyWord>
		<KeyWord name="source_synopsis" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnl" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnle" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnve" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="speed" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="split_header_words" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="splitattr" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="splitdoc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="splitdrive" func="yes">
			<Overload retVal="" descr="Function of os2emxpath">
			</Overload>
		</KeyWord>
		<KeyWord name="splitext" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="splitfields" func="yes">
			<Overload retVal="" descr="Function of string">
			</Overload>
		</KeyWord>
		<KeyWord name="splithost" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="splitnport" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="splitpasswd" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="splitport" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="splitquery" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="splittag" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="splittype" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="splitunc" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="splituser" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="splitvalue" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3" />
		<KeyWord name="sqlite3.Binary" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cache" />
		<KeyWord name="sqlite3.Cache.display" func="yes">
			<Overload retVal="" descr="For debugging only.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cache.get" func="yes">
			<Overload retVal="" descr="Gets an entry from the cache or calls the factory function to produce one.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection" func="yes">
			<Overload retVal="" descr="SQLite database connection object.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.DataError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.DatabaseError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.Error" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.IntegrityError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.InterfaceError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.InternalError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.NotSupportedError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.OperationalError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.ProgrammingError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.Warning" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.close" func="yes">
			<Overload retVal="" descr="Closes the connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.commit" func="yes">
			<Overload retVal="" descr="Commit the current transaction.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.create_aggregate" func="yes">
			<Overload retVal="" descr="Creates a new aggregate. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.create_collation" func="yes">
			<Overload retVal="" descr="Creates a collation function. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.create_function" func="yes">
			<Overload retVal="" descr="Creates a new function. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.cursor" func="yes">
			<Overload retVal="" descr="Return a cursor for the connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.enable_load_extension" func="yes">
			<Overload retVal="" descr="Enable dynamic loading of SQLite extension modules. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.execute" func="yes">
			<Overload retVal="" descr="Executes a SQL statement. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.executemany" func="yes">
			<Overload retVal="" descr="Repeatedly executes a SQL statement. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.executescript" func="yes">
			<Overload retVal="" descr="Executes a multiple SQL statements at once. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.interrupt" func="yes">
			<Overload retVal="" descr="Abort any pending database operation. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.isolation_level" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.iterdump" func="yes">
			<Overload retVal="" descr="Returns iterator to the dump of the database in an SQL text format. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.load_extension" func="yes">
			<Overload retVal="" descr="Load SQLite extension module. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.rollback" func="yes">
			<Overload retVal="" descr="Roll back the current transaction.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.row_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.set_authorizer" func="yes">
			<Overload retVal="" descr="Sets authorizer callback. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.set_progress_handler" func="yes">
			<Overload retVal="" descr="Sets progress handler callback. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.text_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.total_changes" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor" func="yes">
			<Overload retVal="" descr="SQLite database cursor class.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.arraysize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.close" func="yes">
			<Overload retVal="" descr="Closes the cursor.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.connection" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.description" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.execute" func="yes">
			<Overload retVal="" descr="Executes a SQL statement.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.executemany" func="yes">
			<Overload retVal="" descr="Repeatedly executes a SQL statement.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.executescript" func="yes">
			<Overload retVal="" descr="Executes a multiple SQL statements at once. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.fetchall" func="yes">
			<Overload retVal="" descr="Fetches all rows from the resultset.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.fetchmany" func="yes">
			<Overload retVal="" descr="Fetches several rows from the resultset.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.fetchone" func="yes">
			<Overload retVal="" descr="Fetches one row from the resultset.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.lastrowid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.row_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.rowcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.setinputsizes" func="yes">
			<Overload retVal="" descr="Required by DB-API. Does nothing in pysqlite.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.setoutputsize" func="yes">
			<Overload retVal="" descr="Required by DB-API. Does nothing in pysqlite.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DataError" />
		<KeyWord name="sqlite3.DataError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DataError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DatabaseError" />
		<KeyWord name="sqlite3.DatabaseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DatabaseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date" func="yes">
			<Overload retVal="" descr="date(year, month, day) --&gt; date object">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp -&gt; local date from a POSIX timestamp (like time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.isoformat" func="yes">
			<Overload retVal="" descr="Return string in ISO 8601 format, YYYY-MM-DD.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.max" func="yes">
			<Overload retVal="" descr="(date)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.min" func="yes">
			<Overload retVal="" descr="(date)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.replace" func="yes">
			<Overload retVal="" descr="Return date with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DateFromTicks" />
		<KeyWord name="sqlite3.Error" />
		<KeyWord name="sqlite3.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.IntegrityError" />
		<KeyWord name="sqlite3.IntegrityError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.IntegrityError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InterfaceError" />
		<KeyWord name="sqlite3.InterfaceError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InterfaceError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InternalError" />
		<KeyWord name="sqlite3.InternalError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InternalError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.NotSupportedError" />
		<KeyWord name="sqlite3.NotSupportedError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.NotSupportedError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OperationalError" />
		<KeyWord name="sqlite3.OperationalError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OperationalError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode" />
		<KeyWord name="sqlite3.OptimizedUnicode.cell_contents" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.PARSE_COLNAMES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.PARSE_DECLTYPES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.PrepareProtocol" />
		<KeyWord name="sqlite3.ProgrammingError" />
		<KeyWord name="sqlite3.ProgrammingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.ProgrammingError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Row" />
		<KeyWord name="sqlite3.Row.keys" func="yes">
			<Overload retVal="" descr="Returns the keys of the row.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_ALTER_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_ANALYZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_ATTACH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DELETE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DENY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DETACH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_IGNORE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_INSERT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_PRAGMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_REINDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_SELECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_TRANSACTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_UPDATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Statement" />
		<KeyWord name="sqlite3.Time" func="yes">
			<Overload retVal="" descr="time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --&gt; a time object&#10;&#10;All arguments are optional. tzinfo may be None, or an instance of&#10;a tzinfo subclass. The remaining arguments may be ints or longs.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.isoformat" func="yes">
			<Overload retVal="" descr="Return string in ISO 8601 format, HH:MM:SS[.mmmmmm][+HH:MM].">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.max" func="yes">
			<Overload retVal="" descr="(time)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.replace" func="yes">
			<Overload retVal="" descr="Return time with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.TimeFromTicks" />
		<KeyWord name="sqlite3.Timestamp" func="yes">
			<Overload retVal="" descr="datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])&#10;&#10;The year, month and day arguments are required. tzinfo may be None, or an&#10;instance of a tzinfo subclass. The remaining arguments may be ints or longs.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.astimezone" func="yes">
			<Overload retVal="" descr="tz -&gt; convert to local time in new timezone tz">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.combine" func="yes">
			<Overload retVal="" descr="date, time -&gt; datetime with same date and time fields">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.date" func="yes">
			<Overload retVal="" descr="Return date object with same year, month and day.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp[, tz] -&gt; tz's local time from POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.isoformat" func="yes">
			<Overload retVal="" descr="[sep] -&gt; string in ISO 8601 format, YYYY-MM-DDTHH:MM:SS[.mmmmmm][+HH:MM].&#10;&#10;sep is used to separate the year from the time, and defaults to 'T'.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.max" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.min" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.now" func="yes">
			<Overload retVal="" descr="[tz] -&gt; new datetime with tz's local day and time.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.replace" func="yes">
			<Overload retVal="" descr="Return datetime with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.strptime" func="yes">
			<Overload retVal="" descr="string, format -&gt; new datetime parsed from a string (like time.strptime()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.time" func="yes">
			<Overload retVal="" descr="Return time object with same time but with tzinfo=None.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.timetz" func="yes">
			<Overload retVal="" descr="Return time object with same time and tzinfo.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utcfromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp -&gt; UTC datetime from a POSIX timestamp (like time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utcnow" func="yes">
			<Overload retVal="" descr="Return a new datetime representing UTC day and time.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utctimetuple" func="yes">
			<Overload retVal="" descr="Return UTC time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.TimestampFromTicks" />
		<KeyWord name="sqlite3.Warning" />
		<KeyWord name="sqlite3.Warning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Warning.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.adapt" func="yes">
			<Overload retVal="" descr="adapt(obj, protocol, alternate) -&gt; adapt obj to given protocol. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.adapters" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.apilevel" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.complete_statement" func="yes">
			<Overload retVal="" descr="complete_statement(sql)&#10;&#10;Checks if a string contains a complete SQL statement. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.connect" func="yes">
			<Overload retVal="" descr='connect(database[, timeout, isolation_level, detect_types, factory])&#10;&#10;Opens a connection to the SQLite database file *database*. You can use&#10;":memory:" to open a database connection to a database that resides in&#10;RAM instead of on disk.'>
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.converters" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.enable_callback_tracebacks" func="yes">
			<Overload retVal="" descr="enable_callback_tracebacks(flag)&#10;&#10;Enable or disable callback functions throwing errors to stderr.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.enable_shared_cache" func="yes">
			<Overload retVal="" descr="enable_shared_cache(do_enable)&#10;&#10;Enable or disable shared cache mode for the calling thread.&#10;Experimental/Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.paramstyle" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.register_adapter" func="yes">
			<Overload retVal="" descr="register_adapter(type, callable)&#10;&#10;Registers an adapter with pysqlite's adapter registry. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.register_converter" func="yes">
			<Overload retVal="" descr="register_converter(typename, callable)&#10;&#10;Registers a converter with pysqlite. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.sqlite_version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.sqlite_version_info" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.threadsafety" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.version_info" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.x" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqrt" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="sre" func="yes">
			<Overload retVal="" descr="This file is only retained for backwards compatibility.&#10;It will be removed in the future.  sre was moved to re in version 2.5.">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.I" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.L" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.M" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.S" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.U" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.X" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.compile" func="yes">
			<Overload retVal="" descr="Compile a regular expression pattern, returning a pattern object.">
				<Param name="pattern" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.error" />
		<KeyWord name="sre.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.escape" func="yes">
			<Overload retVal="" descr="Escape all non-alphanumeric characters in pattern.">
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.findall" func="yes">
			<Overload retVal="" descr="Return a list of all non-overlapping matches in the string.&#10;&#10;If one or more groups are present in the pattern, return a&#10;list of groups; this will be a list of tuples if the pattern&#10;has more than one group.&#10;&#10;Empty matches are included in the result.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.finditer" func="yes">
			<Overload retVal="" descr="Return an iterator over all non-overlapping matches in the&#10;string.  For each match, the iterator returns a match object.&#10;&#10;Empty matches are included in the result.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.match" func="yes">
			<Overload retVal="" descr="Try to apply the pattern at the start of the string, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.purge" func="yes">
			<Overload retVal="" descr="Clear the regular expression cache">
			</Overload>
		</KeyWord>
		<KeyWord name="sre.search" func="yes">
			<Overload retVal="" descr="Scan through string looking for a match to the pattern, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.split" func="yes">
			<Overload retVal="" descr="Split the source string by the occurrences of the pattern,&#10;returning a list containing the resulting substrings.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[maxsplit=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.sub" func="yes">
			<Overload retVal="" descr="Return the string obtained by replacing the leftmost&#10;non-overlapping occurrences of the pattern in string by the&#10;replacement repl.  repl can be either a string or a callable;&#10;if a string, backslash escapes in it are processed.  If it is&#10;a callable, it's passed the match object and must return&#10;a replacement string to be used.">
				<Param name="pattern" />
				<Param name="repl" />
				<Param name="string" />
				<Param name="[count=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.subn" func="yes">
			<Overload retVal="" descr="Return a 2-tuple containing (new_string, number).&#10;new_string is the string obtained by replacing the leftmost&#10;non-overlapping occurrences of the pattern in the source&#10;string by the replacement repl.  number is the number of&#10;substitutions that were made. repl can be either a string or a&#10;callable; if a string, backslash escapes in it are processed.&#10;If it is a callable, it's passed the match object and must&#10;return a replacement string to be used.">
				<Param name="pattern" />
				<Param name="repl" />
				<Param name="string" />
				<Param name="[count=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre.template" func="yes">
			<Overload retVal="" descr="Compile a template pattern, returning a pattern object">
				<Param name="pattern" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile" func="yes">
			<Overload retVal="" descr="Internal support module for sre">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ANY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ANY_ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ASSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ASSERT_NOT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ATCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BEGINNING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BEGINNING_LINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BEGINNING_STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_END_LINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_END_STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_LOC_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_LOC_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_MULTILINE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_UNI_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_UNI_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.BIGCHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.BRANCH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_LOC_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_LOC_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CHCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CH_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CH_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.FAILURE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.GROUPREF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.GROUPREF_EXISTS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.GROUPREF_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.IN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.IN_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.JUMP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.LITERAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MARK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAXCODE" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAXREPEAT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAX_REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAX_UNTIL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MIN_REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MIN_REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MIN_UNTIL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.NEGATE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.NOT_LITERAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.NOT_LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.OPCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.OP_IGNORE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.RANGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_INFO_CHARSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_INFO_LITERAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_INFO_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.STRING_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SUBPATTERN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SUCCESS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.compile" func="yes">
			<Overload retVal="" descr=>
				<Param name="p" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.error" />
		<KeyWord name="sre_compile.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.isstring" />
		<KeyWord name="sre_compile.makedict" />
		<KeyWord name="sre_constants" func="yes">
			<Overload retVal="" descr="Internal support module for sre">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ANY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ANY_ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ASSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ASSERT_NOT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ATCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BEGINNING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BEGINNING_LINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BEGINNING_STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_END_LINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_END_STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_LOC_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_LOC_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_MULTILINE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_UNI_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_UNI_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.BIGCHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.BRANCH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_LOC_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_LOC_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CHCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CH_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CH_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.FAILURE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.GROUPREF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.GROUPREF_EXISTS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.GROUPREF_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.IN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.IN_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.JUMP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.LITERAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MARK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAXREPEAT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAX_REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAX_UNTIL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MIN_REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MIN_REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MIN_UNTIL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.NEGATE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.NOT_LITERAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.NOT_LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.OPCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.OP_IGNORE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.RANGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_INFO_CHARSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_INFO_LITERAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_INFO_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SUBPATTERN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SUCCESS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.error" />
		<KeyWord name="sre_constants.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.makedict" />
		<KeyWord name="sre_parse" func="yes">
			<Overload retVal="" descr="Internal support module for sre">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ANY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ANY_ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ASSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ASSERT_NOT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ATCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BEGINNING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BEGINNING_LINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BEGINNING_STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_END_LINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_END_STRING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_LOC_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_LOC_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_MULTILINE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_UNI_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_UNI_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.BIGCHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.BRANCH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORIES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_LOC_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_LOC_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_SPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CHCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CH_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CH_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.DIGITS" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ESCAPES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.FAILURE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.FLAGS" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GROUPREF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GROUPREF_EXISTS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GROUPREF_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.HEXDIGITS" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.IN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.IN_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.JUMP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.LITERAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MARK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAXREPEAT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAX_REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAX_UNTIL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MIN_REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MIN_REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MIN_UNTIL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.NEGATE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.NOT_LITERAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.NOT_LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.OCTDIGITS" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.OPCODES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.OP_IGNORE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Pattern" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.RANGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.REPEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.REPEAT_CHARS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SPECIAL_CHARS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_INFO_CHARSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_INFO_LITERAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_INFO_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SUBPATTERN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SUCCESS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SubPattern" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Tokenizer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.WHITESPACE" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.error" />
		<KeyWord name="sre_parse.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.expand_template" />
		<KeyWord name="sre_parse.isdigit" />
		<KeyWord name="sre_parse.isident" />
		<KeyWord name="sre_parse.isname" />
		<KeyWord name="sre_parse.makedict" />
		<KeyWord name="sre_parse.parse" func="yes">
			<Overload retVal="" descr=>
				<Param name="str" />
				<Param name="[flags=0" />
				<Param name="[pattern=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.parse_template" />
		<KeyWord name="ssl" func="yes">
			<Overload retVal="" descr="This module provides some more Pythonic support for SSL.&#10;&#10;Object types:&#10;&#10;  SSLSocket -- subtype of socket.socket which does SSL over the socket&#10;&#10;Exceptions:&#10;&#10;  SSLError -- exception raised for I/O errors&#10;&#10;Functions:&#10;&#10;  cert_time_to_seconds -- convert time string used for certificate&#10;                          notBefore and notAfter functions to integer&#10;                          seconds past the Epoch (the time values&#10;                          returned from time.time())&#10;&#10;  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided&#10;                          by the server running on HOST at port PORT.  No&#10;                          validation of the certificate is performed.&#10;&#10;Integer constants:&#10;&#10;SSL_ERROR_ZERO_RETURN&#10;SSL_ERROR_WANT_READ&#10;SSL_ERROR_WANT_WRITE&#10;SSL_ERROR_WANT_X509_LOOKUP&#10;SSL_ERROR_SYSCALL&#10;SSL_ERROR_SSL&#10;SSL_ERROR_WANT_CONNECT&#10;&#10;SSL_ERROR_EOF&#10;SSL_ERROR_INVALID_ERROR_CODE&#10;&#10;The following group define certificate requirements that one side is&#10;allowing/requiring from the other side:&#10;&#10;CERT_NONE - no certificates from the other side are required (or will&#10;            be looked at if provided)&#10;CERT_OPTIONAL - certificates are not required, but if provided will be&#10;                validated, and if validation fails, the connection will&#10;                also fail&#10;CERT_REQUIRED - certificates are required, and will be validated, and&#10;                if validation fails, the connection will also fail&#10;&#10;The following constants identify various SSL protocol variants:&#10;&#10;PROTOCOL_SSLv2&#10;PROTOCOL_SSLv3&#10;PROTOCOL_SSLv23&#10;PROTOCOL_TLSv1&#10;PROTOCOL_TLSv1_1&#10;PROTOCOL_TLSv1_2&#10;&#10;The following constants identify various SSL alert message descriptions as per&#10;http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6&#10;&#10;ALERT_DESCRIPTION_CLOSE_NOTIFY&#10;ALERT_DESCRIPTION_UNEXPECTED_MESSAGE&#10;ALERT_DESCRIPTION_BAD_RECORD_MAC&#10;ALERT_DESCRIPTION_RECORD_OVERFLOW&#10;ALERT_DESCRIPTION_DECOMPRESSION_FAILURE&#10;ALERT_DESCRIPTION_HANDSHAKE_FAILURE&#10;ALERT_DESCRIPTION_BAD_CERTIFICATE&#10;ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE&#10;ALERT_DESCRIPTION_CERTIFICATE_REVOKED&#10;ALERT_DESCRIPTION_CERTIFICATE_EXPIRED&#10;ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN&#10;ALERT_DESCRIPTION_ILLEGAL_PARAMETER&#10;ALERT_DESCRIPTION_UNKNOWN_CA&#10;ALERT_DESCRIPTION_ACCESS_DENIED&#10;ALERT_DESCRIPTION_DECODE_ERROR&#10;ALERT_DESCRIPTION_DECRYPT_ERROR&#10;ALERT_DESCRIPTION_PROTOCOL_VERSION&#10;ALERT_DESCRIPTION_INSUFFICIENT_SECURITY&#10;ALERT_DESCRIPTION_INTERNAL_ERROR&#10;ALERT_DESCRIPTION_USER_CANCELLED&#10;ALERT_DESCRIPTION_NO_RENEGOTIATION&#10;ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION&#10;ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE&#10;ALERT_DESCRIPTION_UNRECOGNIZED_NAME&#10;ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE&#10;ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE&#10;ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.AF_INET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_ACCESS_DENIED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_CERTIFICATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_RECORD_MAC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_EXPIRED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_REVOKED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_DECODE_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_DECOMPRESSION_FAILURE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_DECRYPT_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_ILLEGAL_PARAMETER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_INSUFFICIENT_SECURITY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_NO_RENEGOTIATION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_PROTOCOL_VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_RECORD_OVERFLOW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNEXPECTED_MESSAGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNKNOWN_CA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNRECOGNIZED_NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_USER_CANCELLED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CERT_OPTIONAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CERT_REQUIRED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CHANNEL_BINDING_TYPES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CertificateError" />
		<KeyWord name="ssl.CertificateError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CertificateError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DER_cert_to_PEM_cert" func="yes">
			<Overload retVal="" descr="Takes a certificate in binary DER format and returns the&#10;PEM version of it as a string.">
				<Param name="der_cert_bytes" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths" func="yes">
			<Overload retVal="" descr="DefaultVerifyPaths(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.cafile" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.capath" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_cafile" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_cafile_env" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_capath" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_capath_env" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_ALPN" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_ECDH" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_NPN" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_SNI" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OPENSSL_VERSION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OPENSSL_VERSION_INFO" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OPENSSL_VERSION_NUMBER" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_ALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_CIPHER_SERVER_PREFERENCE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_COMPRESSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_SSLv2" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_SSLv3" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TLSv1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TLSv1_1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TLSv1_2" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_SINGLE_DH_USE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_SINGLE_ECDH_USE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PEM_FOOTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PEM_HEADER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PEM_cert_to_DER_cert" func="yes">
			<Overload retVal="" descr="Takes a certificate in ASCII PEM format and returns the&#10;DER-encoded version of it as a byte sequence">
				<Param name="pem_cert_string" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_SSLv23" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_SSLv3" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLSv1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLSv1_1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLSv1_2" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose" func="yes">
			<Overload retVal="" descr="SSLContext purpose flags with X509v3 Extended Key Usage objects">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.CLIENT_AUTH" func="yes">
			<Overload retVal="" descr="(Purpose)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.SERVER_AUTH" func="yes">
			<Overload retVal="" descr="(Purpose)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.fromname" func="yes">
			<Overload retVal="" descr="Create _ASN1Object from short name, long name or OID">
				<Param name="cls" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.fromnid" func="yes">
			<Overload retVal="" descr="Create _ASN1Object from OpenSSL numeric ID">
				<Param name="cls" />
				<Param name="nid" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.longname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.nid" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.oid" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose.shortname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_add" func="yes">
			<Overload retVal="" descr="RAND_add(string, entropy)&#10;&#10;Mix string into the OpenSSL PRNG state.  entropy (a float) is a lower&#10;bound on the entropy contained in string.  See RFC 1750.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_status" func="yes">
			<Overload retVal="" descr="RAND_status() -&gt; 0 or 1&#10;&#10;Returns 1 if the OpenSSL PRNG has been seeded with enough data and 0 if not.&#10;It is necessary to seed the PRNG with RAND_add() on some platforms before&#10;using the ssl() function.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SOCK_STREAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SOL_SOCKET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SO_TYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext" func="yes">
			<Overload retVal="" descr="An SSLContext holds various SSL-related configuration options and&#10;data, such as certificates and possibly a private key.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.cert_store_stats" func="yes">
			<Overload retVal="" descr="cert_store_stats() -&gt; {'crl': int, 'x509_ca': int, 'x509': int}&#10;&#10;Returns quantities of loaded X.509 certificates. X.509 certificates with a&#10;CA extension and certificate revocation lists inside the context's cert&#10;store.&#10;NOTE: Certificates in a capath directory aren't loaded unless they have&#10;been used at least once.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.check_hostname" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.get_ca_certs" func="yes">
			<Overload retVal="" descr="get_ca_certs(binary_form=False) -&gt; list of loaded certificate&#10;&#10;Returns a list of dicts with information of loaded CA certs. If the&#10;optional argument is True, returns a DER-encoded copy of the CA certificate.&#10;NOTE: Certificates in a capath directory aren't loaded unless they have&#10;been used at least once.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.load_cert_chain" />
		<KeyWord name="ssl.SSLContext.load_default_certs" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[purpose=_ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.load_dh_params" />
		<KeyWord name="ssl.SSLContext.load_verify_locations" />
		<KeyWord name="ssl.SSLContext.options" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.protocol" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.session_stats" />
		<KeyWord name="ssl.SSLContext.set_alpn_protocols" />
		<KeyWord name="ssl.SSLContext.set_ciphers" />
		<KeyWord name="ssl.SSLContext.set_default_verify_paths" />
		<KeyWord name="ssl.SSLContext.set_ecdh_curve" />
		<KeyWord name="ssl.SSLContext.set_npn_protocols" />
		<KeyWord name="ssl.SSLContext.set_servername_callback" func="yes">
			<Overload retVal="" descr="set_servername_callback(method)&#10;&#10;This sets a callback that will be called when a server name is provided by&#10;the SSL/TLS client in the SNI extension.&#10;&#10;If the argument is None then the callback is disabled. The method is called&#10;with the SSLSocket, the server name as a string, and the SSLContext object.&#10;See RFC 6066 for details of the SNI extension.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.verify_flags" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.verify_mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.wrap_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[server_side=False" />
				<Param name="[do_handshake_on_connect=True" />
				<Param name="[suppress_ragged_eofs=True" />
				<Param name="[server_hostname=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError" func="yes">
			<Overload retVal="" descr="SSL/TLS connection terminated abruptly.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError" func="yes">
			<Overload retVal="" descr="An error occurred in the SSL implementation.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket" func="yes">
			<Overload retVal="" descr="This class implements a subtype of socket.socket that wraps&#10;the underlying OS socket in an SSL context when necessary, and&#10;provides read and write methods over that channel.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.accept" func="yes">
			<Overload retVal="" descr="Accepts a new connection from a remote client, and returns&#10;a tuple containing that new connection wrapped with a server-side&#10;SSL channel, and the address of the remote client.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.cipher" />
		<KeyWord name="ssl.SSLSocket.close" />
		<KeyWord name="ssl.SSLSocket.compression" />
		<KeyWord name="ssl.SSLSocket.connect" func="yes">
			<Overload retVal="" descr="Connects to remote ADDR, and then wraps the connection in&#10;an SSL channel.">
				<Param name="self" />
				<Param name="addr" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.connect_ex" func="yes">
			<Overload retVal="" descr="Connects to remote ADDR, and then wraps the connection in&#10;an SSL channel.">
				<Param name="self" />
				<Param name="addr" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.context" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.do_handshake" func="yes">
			<Overload retVal="" descr="Perform a TLS/SSL handshake.">
				<Param name="self" />
				<Param name="[block=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.dup" />
		<KeyWord name="ssl.SSLSocket.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.get_channel_binding" func="yes">
			<Overload retVal="" descr="Get channel binding data for current connection.  Raise ValueError&#10;if the requested `cb_type` is not supported.  Return bytes of the data&#10;or None if the data is not available (e.g. before the handshake).">
				<Param name="self" />
				<Param name="[cb_type=tls-unique]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getpeercert" func="yes">
			<Overload retVal="" descr="Returns a formatted version of the data in the&#10;certificate provided by the other end of the SSL channel.&#10;Return None if no certificate was provided, {} if a&#10;certificate was provided, but not validated.">
				<Param name="self" />
				<Param name="[binary_form=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.listen" func="yes">
			<Overload retVal="" descr="listen(backlog)&#10;&#10;Enable a server to accept connections.  The backlog argument must be at&#10;least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.makefile" func="yes">
			<Overload retVal="" descr="Make and return a file-like object that&#10;works with the SSL connection.  Just use the code&#10;from the socket module.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[bufsize=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.pending" />
		<KeyWord name="ssl.SSLSocket.proto" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.read" func="yes">
			<Overload retVal="" descr="Read up to LEN bytes and return them.&#10;Return zero-length string on EOF.">
				<Param name="self" />
				<Param name="[len=0" />
				<Param name="[buffer=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recv" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[buflen=1024" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recv_into" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="buffer" />
				<Param name="[nbytes=None" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recvfrom" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[buflen=1024" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recvfrom_into" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="buffer" />
				<Param name="[nbytes=None" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.selected_alpn_protocol" />
		<KeyWord name="ssl.SSLSocket.selected_npn_protocol" />
		<KeyWord name="ssl.SSLSocket.send" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="data" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.sendall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="data" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.sendto" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="data" />
				<Param name="flags_or_addr" />
				<Param name="[addr=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer or a string.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.shutdown" />
		<KeyWord name="ssl.SSLSocket.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.unwrap" />
		<KeyWord name="ssl.SSLSocket.version" func="yes">
			<Overload retVal="" descr="Return a string identifying the protocol version used by the&#10;current SSL channel, or None if there is no established channel.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.write" func="yes">
			<Overload retVal="" descr="Write DATA to the underlying SSL channel.  Returns&#10;number of bytes of DATA actually transmitted.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError" func="yes">
			<Overload retVal="" descr="System error when attempting SSL operation.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError" func="yes">
			<Overload retVal="" descr="Non-blocking SSL socket needs to read more data&#10;before the requested operation can be completed.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError" func="yes">
			<Overload retVal="" descr="Non-blocking SSL socket needs to write more data&#10;before the requested operation can be completed.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError" func="yes">
			<Overload retVal="" descr="SSL/TLS session closed cleanly.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_EOF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_INVALID_ERROR_CODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_SSL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_SYSCALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_CONNECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_WRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_X509_LOOKUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_ZERO_RETURN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_CRL_CHECK_CHAIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_CRL_CHECK_LEAF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_X509_STRICT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_X509_TRUSTED_FIRST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.cert_time_to_seconds" func="yes">
			<Overload retVal="" descr='Return the time in seconds since the Epoch, given the timestring&#10;representing the "notBefore" or "notAfter" date from a certificate&#10;in ``"%b %d %H:%M:%S %Y %Z"`` strptime format (C locale).&#10;&#10;"notBefore" or "notAfter" dates must use UTC (RFC 5280).&#10;&#10;Month is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&#10;UTC should be specified as GMT (see ASN1_TIME_print())'>
				<Param name="cert_time" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.closing" func="yes">
			<Overload retVal="" descr="Context to automatically close something at the end of a block.&#10;&#10;Code like this:&#10;&#10;    with closing(&lt;module&gt;.open(&lt;arguments&gt;)) as f:&#10;        &lt;block&gt;&#10;&#10;is equivalent to this:&#10;&#10;    f = &lt;module&gt;.open(&lt;arguments&gt;)&#10;    try:&#10;        &lt;block&gt;&#10;    finally:&#10;        f.close()">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.create_connection" func="yes">
			<Overload retVal="" descr="Connect to *address* and return the socket object.&#10;&#10;Convenience function.  Connect to *address* (a 2-tuple ``(host,&#10;port)``) and return the socket object.  Passing the optional&#10;*timeout* parameter will set the timeout on the socket instance&#10;before attempting to connect.  If no *timeout* is supplied, the&#10;global default timeout setting returned by :func:`getdefaulttimeout`&#10;is used.  If *source_address* is set it must be a tuple of (host, port)&#10;for the socket to bind as a source address before making the connection.&#10;An host of '' or port 0 tells the OS to use the default.">
				<Param name="address" />
				<Param name="[timeout=<object object at 0x00000000024AA130>" />
				<Param name="[source_address=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.create_default_context" func="yes">
			<Overload retVal="" descr="Create a SSLContext object with default settings.&#10;&#10;NOTE: The protocol and settings may change anytime without prior&#10;      deprecation. The values represent a fair balance between maximum&#10;      compatibility and security.">
				<Param name="[purpose=_ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')" />
				<Param name="[cafile=None" />
				<Param name="[capath=None" />
				<Param name="[cadata=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.enum_certificates" func="yes">
			<Overload retVal="" descr="enum_certificates(store_name) -&gt; []&#10;&#10;Retrieve certificates from Windows' cert store. store_name may be one of&#10;'CA', 'ROOT' or 'MY'. The system may provide more cert storages, too.&#10;The function returns a list of (bytes, encoding_type, trust) tuples. The&#10;encoding_type flag can be interpreted with X509_ASN_ENCODING or&#10;PKCS_7_ASN_ENCODING. The trust setting is either a set of OIDs or the&#10;boolean True.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.enum_crls" func="yes">
			<Overload retVal="" descr="enum_crls(store_name) -&gt; []&#10;&#10;Retrieve CRLs from Windows' cert store. store_name may be one of&#10;'CA', 'ROOT' or 'MY'. The system may provide more cert storages, too.&#10;The function returns a list of (bytes, encoding_type) tuples. The&#10;encoding_type flag can be interpreted with X509_ASN_ENCODING or&#10;PKCS_7_ASN_ENCODING.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.get_default_verify_paths" func="yes">
			<Overload retVal="" descr="Return paths to default cafile and capath.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.get_protocol_name" />
		<KeyWord name="ssl.get_server_certificate" func="yes">
			<Overload retVal="" descr="Retrieve the certificate from the server at the specified address,&#10;and return it as a PEM-encoded string.&#10;If 'ca_certs' is specified, validate the server cert against it.&#10;If 'ssl_version' is specified, use it in the connection attempt.">
				<Param name="addr" />
				<Param name="[ssl_version=2" />
				<Param name="[ca_certs=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.match_hostname" func="yes">
			<Overload retVal="" descr="Verify that *cert* (in decoded format as returned by&#10;SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125&#10;rules are followed, but IP addresses are not accepted for *hostname*.&#10;&#10;CertificateError is raised on failure. On success, the function&#10;returns nothing.">
				<Param name="cert" />
				<Param name="hostname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
				<Param name="typename" />
				<Param name="field_names" />
				<Param name="[verbose=False" />
				<Param name="[rename=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket" func="yes">
			<Overload retVal="" descr="socket([family[, type[, proto]]]) -&gt; socket object&#10;&#10;Open a socket of the given type.  The family argument specifies the&#10;address family; it defaults to AF_INET.  The type argument specifies&#10;whether this is a stream (SOCK_STREAM, this is the default)&#10;or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,&#10;specifying the default protocol.  Keyword arguments are accepted.&#10;&#10;A socket object represents one endpoint of a network connection.&#10;&#10;Methods of socket objects (keyword arguments not allowed):&#10;&#10;accept() -- accept a connection, returning new socket and client address&#10;bind(addr) -- bind the socket to a local address&#10;close() -- close the socket&#10;connect(addr) -- connect the socket to a remote address&#10;connect_ex(addr) -- connect, return an error code instead of an exception&#10;dup() -- return a new socket object identical to the current one [*]&#10;fileno() -- return underlying file descriptor&#10;getpeername() -- return remote address [*]&#10;getsockname() -- return local address&#10;getsockopt(level, optname[, buflen]) -- get socket options&#10;gettimeout() -- return timeout or None&#10;listen(n) -- start listening for incoming connections&#10;makefile([mode, [bufsize]]) -- return a file object for the socket [*]&#10;recv(buflen[, flags]) -- receive data&#10;recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)&#10;recvfrom(buflen[, flags]) -- receive data and sender's address&#10;recvfrom_into(buffer[, nbytes, [, flags])&#10;  -- receive data and sender's address (into a buffer)&#10;sendall(data[, flags]) -- send all data&#10;send(data[, flags]) -- send data, may not send all of it&#10;sendto(data[, flags], addr) -- send data to a given address&#10;setblocking(0 | 1) -- set or clear the blocking I/O flag&#10;setsockopt(level, optname, value) -- set socket options&#10;settimeout(None | float) -- set or clear the timeout&#10;shutdown(how) -- shut down traffic in one or both directions&#10;&#10; [*] not available on all platforms!">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.accept" func="yes">
			<Overload retVal="" descr="accept() -&gt; (socket object, address info)&#10;&#10;Wait for an incoming connection.  Return a new socket representing the&#10;connection, and the address of the client.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
				<Param name="self" />
				<Param name="[_closedsocket=<class 'socket._closedsocket'>" />
				<Param name="[_delegate_methods=('recv', 'recvfrom', 'recv_into', 'recvfrom_into', 'send', 'sendto')" />
				<Param name="[setattr=<built-in function setattr>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.connect" func="yes">
			<Overload retVal="" descr="connect(address)&#10;&#10;Connect the socket to a remote address.  For IP sockets, the address&#10;is a pair (host, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.connect_ex" func="yes">
			<Overload retVal="" descr="connect_ex(address) -&gt; errno&#10;&#10;This is like connect(address), but returns an error code (the errno value)&#10;instead of raising an exception when an error occurs.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.dup" func="yes">
			<Overload retVal="" descr="dup() -&gt; socket object&#10;&#10;Return a new socket object connected to the same system resource.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.listen" func="yes">
			<Overload retVal="" descr="listen(backlog)&#10;&#10;Enable a server to accept connections.  The backlog argument must be at&#10;least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.makefile" func="yes">
			<Overload retVal="" descr="makefile([mode[, bufsize]]) -&gt; file object&#10;&#10;Return a regular file object corresponding to the socket.  The mode&#10;and bufsize arguments are as for the built-in open() function.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[bufsize=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.proto" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recv" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recv_into" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recvfrom" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recvfrom_into" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.send" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.sendto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer or a string.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error" />
		<KeyWord name="ssl.socket_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.sslwrap_simple" func="yes">
			<Overload retVal="" descr="A replacement for the old socket.ssl function.  Designed&#10;for compability with Python 2.5 and earlier.  Will disappear in&#10;Python 3.0.">
				<Param name="sock" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.wrap_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="sock" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None" />
				<Param name="[server_side=False" />
				<Param name="[cert_reqs=0" />
				<Param name="[ssl_version=2" />
				<Param name="[ca_certs=None" />
				<Param name="[do_handshake_on_connect=True" />
				<Param name="[suppress_ragged_eofs=True" />
				<Param name="[ciphers=None]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sslwrap_simple" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="st" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="stack" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="stack_size" func="yes">
			<Overload retVal="" descr="Function of dummy_thread">
			</Overload>
		</KeyWord>
		<KeyWord name="stamp" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="standard_b64decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="standard_b64encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="start" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="startTest" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="startTestRun" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="start_new_thread" func="yes">
			<Overload retVal="" descr="Function of dummy_thread">
			</Overload>
		</KeyWord>
		<KeyWord name="start_section" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="startfile" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat" func="yes">
			<Overload retVal="" descr="Constants/functions for interpreting results of os.stat() and os.lstat().&#10;&#10;Suggested usage: from stat import *">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_ARCHIVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_SNAPSHOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_ATIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_CTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_DEV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_GID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_INO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_MTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_NLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_UID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ENFMT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFBLK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFCHR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFDIR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFIFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFLNK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFMT" />
		<KeyWord name="stat.S_IFREG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFSOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IMODE" />
		<KeyWord name="stat.S_IREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IROTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRWXG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRWXO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRWXU" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISBLK" />
		<KeyWord name="stat.S_ISCHR" />
		<KeyWord name="stat.S_ISDIR" />
		<KeyWord name="stat.S_ISFIFO" />
		<KeyWord name="stat.S_ISGID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISLNK" />
		<KeyWord name="stat.S_ISREG" />
		<KeyWord name="stat.S_ISSOCK" />
		<KeyWord name="stat.S_ISUID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISVTX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IXGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IXOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IXUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_COMPRESSED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_HIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_NODUMP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_OPAQUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat_float_times" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="state" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="staticmethod" func="yes">
			<Overload retVal="" descr="staticmethod(function) -&gt; method&#10;&#10;Convert a function to be a static method.&#10;&#10;A static method does not receive an implicit first argument.&#10;To declare a static method, use this idiom:&#10;&#10;     class C:&#10;     def f(arg1, arg2, ...): ...&#10;     f = staticmethod(f)&#10;&#10;It can be called either on the class (e.g. C.f()) or on an instance&#10;(e.g. C().f()).  The instance is ignored except for its class.&#10;&#10;Static methods in Python are similar to those found in Java or C++.&#10;For a more advanced concept, see the classmethod builtin.">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs" func="yes">
			<Overload retVal="" descr="Constants for interpreting the results of os.statvfs() and os.fstatvfs().">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_BAVAIL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_BFREE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_BLOCKS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_FAVAIL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_FFREE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_FILES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_FLAG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_FRSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs.F_NAMEMAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stn" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="stop" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="stopTest" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="stopTestRun" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="str" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="strcoll" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="strerror" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="strftime" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="strict_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="string" func="yes">
			<Overload retVal="" descr="A collection of string operations (most are no longer used).&#10;&#10;Warning: most of the code you see here isn't normally used nowadays.&#10;Beginning with Python 1.6, many of these functions are implemented as&#10;methods on the standard string object. They used to be implemented by&#10;a built-in module called strop, but strop is now obsolete itself.&#10;&#10;Public module variables:&#10;&#10;whitespace -- a string containing all characters considered whitespace&#10;lowercase -- a string containing all characters considered lowercase letters&#10;uppercase -- a string containing all characters considered uppercase letters&#10;letters -- a string containing all characters considered letters&#10;digits -- a string containing all characters considered decimal digits&#10;hexdigits -- a string containing all characters considered hexadecimal digits&#10;octdigits -- a string containing all characters considered octal digits&#10;punctuation -- a string containing all characters considered punctuation&#10;printable -- a string containing all characters considered printable">
			</Overload>
		</KeyWord>
		<KeyWord name="string.Formatter" />
		<KeyWord name="string.Formatter.check_unused_args" />
		<KeyWord name="string.Formatter.convert_field" />
		<KeyWord name="string.Formatter.format" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.Formatter.format_field" />
		<KeyWord name="string.Formatter.get_field" />
		<KeyWord name="string.Formatter.get_value" />
		<KeyWord name="string.Formatter.parse" />
		<KeyWord name="string.Formatter.vformat" />
		<KeyWord name="string.Template" func="yes">
			<Overload retVal="" descr="(_TemplateMetaclass)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ascii_letters" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ascii_lowercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ascii_uppercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atof" func="yes">
			<Overload retVal="" descr="atof(s) -&gt; float&#10;&#10;Return the floating point number represented by the string s.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.atof_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atof_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atof_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atoi" func="yes">
			<Overload retVal="" descr="atoi(s [,base]) -&gt; int&#10;&#10;Return the integer represented by the string s in the given&#10;base, which defaults to 10.  The string s must consist of one&#10;or more digits, possibly preceded by a sign.  If base is 0, it&#10;is chosen from the leading characters of s, 0 for octal, 0x or&#10;0X for hexadecimal.  If base is 16, a preceding 0x or 0X is&#10;accepted.">
				<Param name="s" />
				<Param name="[base=10]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.atoi_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atoi_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atoi_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atol" func="yes">
			<Overload retVal="" descr="atol(s [,base]) -&gt; long&#10;&#10;Return the long integer represented by the string s in the&#10;given base, which defaults to 10.  The string s must consist&#10;of one or more digits, possibly preceded by a sign.  If base&#10;is 0, it is chosen from the leading characters of s, 0 for&#10;octal, 0x or 0X for hexadecimal.  If base is 16, a preceding&#10;0x or 0X is accepted.  A trailing L or l is not accepted,&#10;unless base is 0.">
				<Param name="s" />
				<Param name="[base=10]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.atol_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atol_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.atol_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.capitalize" func="yes">
			<Overload retVal="" descr="capitalize(s) -&gt; string&#10;&#10;Return a copy of the string s with only its first character&#10;capitalized.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.capwords" func="yes">
			<Overload retVal="" descr="capwords(s [,sep]) -&gt; string&#10;&#10;Split the argument into words using split, capitalize each&#10;word using capitalize, and join the capitalized words using&#10;join.  If the optional second argument sep is absent or None,&#10;runs of whitespace characters are replaced by a single space&#10;and leading and trailing whitespace are removed, otherwise&#10;sep is used to split and join the words.">
				<Param name="s" />
				<Param name="[sep=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.center" func="yes">
			<Overload retVal="" descr="center(s, width[, fillchar]) -&gt; string&#10;&#10;Return a center version of s, in a field of the specified&#10;width. padded with spaces as needed.  The string is never&#10;truncated.  If specified the fillchar is used instead of spaces.">
				<Param name="s" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.count" func="yes">
			<Overload retVal="" descr="count(s, sub[, start[,end]]) -&gt; int&#10;&#10;Return the number of occurrences of substring sub in string&#10;s[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.digits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.expandtabs" func="yes">
			<Overload retVal="" descr="expandtabs(s [,tabsize]) -&gt; string&#10;&#10;Return a copy of the string s with all tab characters replaced&#10;by the appropriate number of spaces, depending on the current&#10;column, and the tabsize (default 8).">
				<Param name="s" />
				<Param name="[tabsize=8]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.find" func="yes">
			<Overload retVal="" descr="find(s, sub [,start [,end]]) -&gt; in&#10;&#10;Return the lowest index in s where substring sub is found,&#10;such that sub is contained within s[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.hexdigits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.index" func="yes">
			<Overload retVal="" descr="index(s, sub [,start [,end]]) -&gt; int&#10;&#10;Like find but raises ValueError when the substring is not found.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.index_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="string.index_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.index_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.join" func="yes">
			<Overload retVal="" descr="join(list [,sep]) -&gt; string&#10;&#10;Return a string composed of the words in list, with&#10;intervening occurrences of sep.  The default separator is a&#10;single space.&#10;&#10;(joinfields and join are synonymous)">
				<Param name="words" />
				<Param name="[sep= ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.joinfields" func="yes">
			<Overload retVal="" descr="join(list [,sep]) -&gt; string&#10;&#10;Return a string composed of the words in list, with&#10;intervening occurrences of sep.  The default separator is a&#10;single space.&#10;&#10;(joinfields and join are synonymous)">
				<Param name="words" />
				<Param name="[sep= ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.letters" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ljust" func="yes">
			<Overload retVal="" descr="ljust(s, width[, fillchar]) -&gt; string&#10;&#10;Return a left-justified version of s, in a field of the&#10;specified width, padded with spaces as needed.  The string is&#10;never truncated.  If specified the fillchar is used instead of spaces.">
				<Param name="s" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.lower" func="yes">
			<Overload retVal="" descr="lower(s) -&gt; string&#10;&#10;Return a copy of the string s converted to lowercase.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.lowercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.lstrip" func="yes">
			<Overload retVal="" descr="lstrip(s [,chars]) -&gt; string&#10;&#10;Return a copy of the string s with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
				<Param name="s" />
				<Param name="[chars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.maketrans" func="yes">
			<Overload retVal="" descr="maketrans(frm, to) -&gt; string&#10;&#10;Return a translation table (a string of 256 bytes long)&#10;suitable for use in string.translate.  The strings frm and to&#10;must be of the same length.">
			</Overload>
		</KeyWord>
		<KeyWord name="string.octdigits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.printable" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.punctuation" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.replace" func="yes">
			<Overload retVal="" descr="replace (str, old, new[, maxreplace]) -&gt; string&#10;&#10;Return a copy of string str with all occurrences of substring&#10;old replaced by new. If the optional argument maxreplace is&#10;given, only the first maxreplace occurrences are replaced.">
				<Param name="s" />
				<Param name="old" />
				<Param name="new" />
				<Param name="[maxreplace=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.rfind" func="yes">
			<Overload retVal="" descr="rfind(s, sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in s where substring sub is found,&#10;such that sub is contained within s[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.rindex" func="yes">
			<Overload retVal="" descr="rindex(s, sub [,start [,end]]) -&gt; int&#10;&#10;Like rfind but raises ValueError when the substring is not found.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.rjust" func="yes">
			<Overload retVal="" descr="rjust(s, width[, fillchar]) -&gt; string&#10;&#10;Return a right-justified version of s, in a field of the&#10;specified width, padded with spaces as needed.  The string is&#10;never truncated.  If specified the fillchar is used instead of spaces.">
				<Param name="s" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.rsplit" func="yes">
			<Overload retVal="" descr="rsplit(s [,sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string s, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
				<Param name="s" />
				<Param name="[sep=None" />
				<Param name="[maxsplit=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.rstrip" func="yes">
			<Overload retVal="" descr="rstrip(s [,chars]) -&gt; string&#10;&#10;Return a copy of the string s with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
				<Param name="s" />
				<Param name="[chars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.split" func="yes">
			<Overload retVal="" descr="split(s [,sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string s, using sep as the&#10;delimiter string.  If maxsplit is given, splits at no more than&#10;maxsplit places (resulting in at most maxsplit+1 words).  If sep&#10;is not specified or is None, any whitespace string is a separator.&#10;&#10;(split and splitfields are synonymous)">
				<Param name="s" />
				<Param name="[sep=None" />
				<Param name="[maxsplit=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.splitfields" func="yes">
			<Overload retVal="" descr="split(s [,sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string s, using sep as the&#10;delimiter string.  If maxsplit is given, splits at no more than&#10;maxsplit places (resulting in at most maxsplit+1 words).  If sep&#10;is not specified or is None, any whitespace string is a separator.&#10;&#10;(split and splitfields are synonymous)">
				<Param name="s" />
				<Param name="[sep=None" />
				<Param name="[maxsplit=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.strip" func="yes">
			<Overload retVal="" descr="strip(s [,chars]) -&gt; string&#10;&#10;Return a copy of the string s with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping.">
				<Param name="s" />
				<Param name="[chars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.swapcase" func="yes">
			<Overload retVal="" descr="swapcase(s) -&gt; string&#10;&#10;Return a copy of the string s with upper case characters&#10;converted to lowercase and vice versa.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.translate" func="yes">
			<Overload retVal="" descr="translate(s,table [,deletions]) -&gt; string&#10;&#10;Return a copy of the string s, where all characters occurring&#10;in the optional argument deletions are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256.  The&#10;deletions argument is not allowed for Unicode strings.">
				<Param name="s" />
				<Param name="table" />
				<Param name="[deletions]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.upper" func="yes">
			<Overload retVal="" descr="upper(s) -&gt; string&#10;&#10;Return a copy of the string s converted to uppercase.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.uppercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.whitespace" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.zfill" func="yes">
			<Overload retVal="" descr="zfill(x, width) -&gt; string&#10;&#10;Pad a numeric string x with zeros on the left, to fill a field&#10;of the specified width.  The string x is never truncated.">
				<Param name="x" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="string_at" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold" func="yes">
			<Overload retVal="" descr="Common string manipulations.&#10;&#10;Public module variables:&#10;&#10;whitespace -- a string containing all characters considered whitespace&#10;lowercase -- a string containing all characters considered lowercase letters&#10;uppercase -- a string containing all characters considered uppercase letters&#10;letters -- a string containing all characters considered letters&#10;digits -- a string containing all characters considered decimal digits&#10;hexdigits -- a string containing all characters considered hexadecimal digits&#10;octdigits -- a string containing all characters considered octal digits">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atof" func="yes">
			<Overload retVal="" descr="atof(s) -&gt; float&#10;&#10;Return the floating point number represented by the string s.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atof_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atof_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atof_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atoi" func="yes">
			<Overload retVal="" descr="atoi(s [,base]) -&gt; int&#10;&#10;Return the integer represented by the string s in the given&#10;base, which defaults to 10.  The string s must consist of one&#10;or more digits, possibly preceded by a sign.  If base is 0, it&#10;is chosen from the leading characters of s, 0 for octal, 0x or&#10;0X for hexadecimal.  If base is 16, a preceding 0x or 0X is&#10;accepted.">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atoi_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atoi_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atoi_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atol" func="yes">
			<Overload retVal="" descr="atol(s [,base]) -&gt; long&#10;&#10;Return the long integer represented by the string s in the&#10;given base, which defaults to 10.  The string s must consist&#10;of one or more digits, possibly preceded by a sign.  If base&#10;is 0, it is chosen from the leading characters of s, 0 for&#10;octal, 0x or 0X for hexadecimal.  If base is 16, a preceding&#10;0x or 0X is accepted.  A trailing L or l is not accepted,&#10;unless base is 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atol_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atol_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.atol_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.capitalize" func="yes">
			<Overload retVal="" descr="capitalize(s) -&gt; string&#10;&#10;Return a copy of the string s with only its first character&#10;capitalized.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.capwords" func="yes">
			<Overload retVal="" descr="capwords(s, [sep]) -&gt; string&#10;&#10;Split the argument into words using split, capitalize each&#10;word using capitalize, and join the capitalized words using&#10;join. Note that this replaces runs of whitespace characters by&#10;a single space.">
				<Param name="s" />
				<Param name="[sep=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.center" func="yes">
			<Overload retVal="" descr="center(s, width) -&gt; string&#10;&#10;Return a center version of s, in a field of the specified&#10;width. padded with spaces as needed.  The string is never&#10;truncated.">
				<Param name="s" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.count" func="yes">
			<Overload retVal="" descr="count(s, sub[, start[,end]]) -&gt; int&#10;&#10;Return the number of occurrences of substring sub in string&#10;s[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.digits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.expandtabs" func="yes">
			<Overload retVal="" descr="expandtabs(s [,tabsize]) -&gt; string&#10;&#10;Return a copy of the string s with all tab characters replaced&#10;by the appropriate number of spaces, depending on the current&#10;column, and the tabsize (default 8).">
				<Param name="s" />
				<Param name="[tabsize=8]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.find" func="yes">
			<Overload retVal="" descr="find(s, sub [,start [,end]]) -&gt; in&#10;&#10;Return the lowest index in s where substring sub is found,&#10;such that sub is contained within s[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.hexdigits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.index" func="yes">
			<Overload retVal="" descr="index(s, sub [,start [,end]]) -&gt; int&#10;&#10;Like find but raises ValueError when the substring is not found.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.index_error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.index_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.index_error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.join" func="yes">
			<Overload retVal="" descr="join(list [,sep]) -&gt; string&#10;&#10;Return a string composed of the words in list, with&#10;intervening occurrences of sep.  The default separator is a&#10;single space.&#10;&#10;(joinfields and join are synonymous)">
				<Param name="words" />
				<Param name="[sep= ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.joinfields" func="yes">
			<Overload retVal="" descr="join(list [,sep]) -&gt; string&#10;&#10;Return a string composed of the words in list, with&#10;intervening occurrences of sep.  The default separator is a&#10;single space.&#10;&#10;(joinfields and join are synonymous)">
				<Param name="words" />
				<Param name="[sep= ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.letters" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.ljust" func="yes">
			<Overload retVal="" descr="ljust(s, width) -&gt; string&#10;&#10;Return a left-justified version of s, in a field of the&#10;specified width, padded with spaces as needed.  The string is&#10;never truncated.">
				<Param name="s" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.lower" func="yes">
			<Overload retVal="" descr="lower(s) -&gt; string&#10;&#10;Return a copy of the string s converted to lowercase.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.lowercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.lstrip" func="yes">
			<Overload retVal="" descr="lstrip(s) -&gt; string&#10;&#10;Return a copy of the string s with leading whitespace removed.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.maketrans" func="yes">
			<Overload retVal="" descr="maketrans(frm, to) -&gt; string&#10;&#10;Return a translation table (a string of 256 bytes long)&#10;suitable for use in string.translate.  The strings frm and to&#10;must be of the same length.">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.octdigits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.replace" func="yes">
			<Overload retVal="" descr="replace (str, old, new[, maxsplit]) -&gt; string&#10;&#10;Return a copy of string str with all occurrences of substring&#10;old replaced by new. If the optional argument maxsplit is&#10;given, only the first maxsplit occurrences are replaced.">
				<Param name="s" />
				<Param name="old" />
				<Param name="new" />
				<Param name="[maxsplit=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.rfind" func="yes">
			<Overload retVal="" descr="rfind(s, sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in s where substring sub is found,&#10;such that sub is contained within s[start,end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.rindex" func="yes">
			<Overload retVal="" descr="rindex(s, sub [,start [,end]]) -&gt; int&#10;&#10;Like rfind but raises ValueError when the substring is not found.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.rjust" func="yes">
			<Overload retVal="" descr="rjust(s, width) -&gt; string&#10;&#10;Return a right-justified version of s, in a field of the&#10;specified width, padded with spaces as needed.  The string is&#10;never truncated.">
				<Param name="s" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.rstrip" func="yes">
			<Overload retVal="" descr="rstrip(s) -&gt; string&#10;&#10;Return a copy of the string s with trailing whitespace&#10;removed.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.split" func="yes">
			<Overload retVal="" descr="split(str [,sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string s, using sep as the&#10;delimiter string.  If maxsplit is nonzero, splits into at most&#10;maxsplit words If sep is not specified, any whitespace string&#10;is a separator.  Maxsplit defaults to 0.&#10;&#10;(split and splitfields are synonymous)">
				<Param name="s" />
				<Param name="[sep=None" />
				<Param name="[maxsplit=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.splitfields" func="yes">
			<Overload retVal="" descr="split(str [,sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string s, using sep as the&#10;delimiter string.  If maxsplit is nonzero, splits into at most&#10;maxsplit words If sep is not specified, any whitespace string&#10;is a separator.  Maxsplit defaults to 0.&#10;&#10;(split and splitfields are synonymous)">
				<Param name="s" />
				<Param name="[sep=None" />
				<Param name="[maxsplit=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.strip" func="yes">
			<Overload retVal="" descr="strip(s) -&gt; string&#10;&#10;Return a copy of the string s with leading and trailing&#10;whitespace removed.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.swapcase" func="yes">
			<Overload retVal="" descr="swapcase(s) -&gt; string&#10;&#10;Return a copy of the string s with upper case characters&#10;converted to lowercase and vice versa.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.translate" func="yes">
			<Overload retVal="" descr="translate(s,table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string s, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256.">
				<Param name="s" />
				<Param name="table" />
				<Param name="[deletions]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.upper" func="yes">
			<Overload retVal="" descr="upper(s) -&gt; string&#10;&#10;Return a copy of the string s converted to uppercase.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.uppercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.whitespace" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringold.zfill" func="yes">
			<Overload retVal="" descr="zfill(x, width) -&gt; string&#10;&#10;Pad a numeric string x with zeros on the left, to fill a field&#10;of the specified width.  The string x is never truncated.">
				<Param name="x" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep" func="yes">
			<Overload retVal="" descr="Library that exposes various tables found in the StringPrep RFC 3454.&#10;&#10;There are two kinds of tables: sets, for which a member test is provided,&#10;and mappings, for which a mapping function is provided.">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.b1_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.b3_exceptions" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c22_specials" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c6_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c7_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c8_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c9_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.in_table_a1" />
		<KeyWord name="stringprep.in_table_b1" />
		<KeyWord name="stringprep.in_table_c11" />
		<KeyWord name="stringprep.in_table_c11_c12" />
		<KeyWord name="stringprep.in_table_c12" />
		<KeyWord name="stringprep.in_table_c21" />
		<KeyWord name="stringprep.in_table_c21_c22" />
		<KeyWord name="stringprep.in_table_c22" />
		<KeyWord name="stringprep.in_table_c3" />
		<KeyWord name="stringprep.in_table_c4" />
		<KeyWord name="stringprep.in_table_c5" />
		<KeyWord name="stringprep.in_table_c6" />
		<KeyWord name="stringprep.in_table_c7" />
		<KeyWord name="stringprep.in_table_c8" />
		<KeyWord name="stringprep.in_table_c9" />
		<KeyWord name="stringprep.in_table_d1" />
		<KeyWord name="stringprep.in_table_d2" />
		<KeyWord name="stringprep.map_table_b2" />
		<KeyWord name="stringprep.map_table_b3" />
		<KeyWord name="stringprep.unicodedata" func="yes">
			<Overload retVal="" descr="(UCD)">
			</Overload>
		</KeyWord>
		<KeyWord name="strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="stripid" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="strong" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="strptime" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="strseq" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="struct" func="yes">
			<Overload retVal="" descr="Functions to convert between Python values and C structs represented&#10;as Python strings. It uses format strings (explained below) as compact&#10;descriptions of the lay-out of the C structs and the intended conversion&#10;to/from Python values.&#10;&#10;The optional first format char indicates byte order, size and alignment:&#10;  @: native order, size &amp; alignment (default)&#10;  =: native order, std. size &amp; alignment&#10;  &lt;: little-endian, std. size &amp; alignment&#10;  &gt;: big-endian, std. size &amp; alignment&#10;  !: same as &gt;&#10;&#10;The remaining chars indicate types of args and must match exactly;&#10;these can be preceded by a decimal repeat count:&#10;  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;&#10;  ?: _Bool (requires C99; if not available, char is used instead)&#10;  h:short; H:unsigned short; i:int; I:unsigned int;&#10;  l:long; L:unsigned long; f:float; d:double.&#10;Special cases (preceding decimal count indicates length):&#10;  s:string (array of char); p: pascal string (with count byte).&#10;Special case (only available in native format):&#10;  P:an integer type that is wide enough to hold a pointer.&#10;Special case (not in native mode unless 'long long' in platform C):&#10;  q:long long; Q:unsigned long long&#10;Whitespace between formats is ignored.&#10;&#10;The variable struct.error is an exception raised on errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct" func="yes">
			<Overload retVal="" descr="Compiled struct object">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.format" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.pack" func="yes">
			<Overload retVal="" descr="S.pack(v1, v2, ...) -&gt; string&#10;&#10;Return a string containing values v1, v2, ... packed according to this&#10;Struct's format. See struct.__doc__ for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.pack_into" func="yes">
			<Overload retVal="" descr="S.pack_into(buffer, offset, v1, v2, ...)&#10;&#10;Pack the values v1, v2, ... according to this Struct's format, write &#10;the packed bytes into the writable buffer buf starting at offset.  Note&#10;that the offset is not an optional argument.  See struct.__doc__ for &#10;more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.unpack" func="yes">
			<Overload retVal="" descr="S.unpack(str) -&gt; (v1, v2, ...)&#10;&#10;Return tuple containing values unpacked according to this Struct's format.&#10;Requires len(str) == self.size. See struct.__doc__ for more on format&#10;strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.unpack_from" func="yes">
			<Overload retVal="" descr="S.unpack_from(buffer[, offset]) -&gt; (v1, v2, ...)&#10;&#10;Return tuple containing values unpacked according to this Struct's format.&#10;Unlike unpack, unpack_from can unpack values from any object supporting&#10;the buffer API, not just str. Requires len(buffer[offset:]) &gt;= self.size.&#10;See struct.__doc__ for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.calcsize" func="yes">
			<Overload retVal="" descr="Return size of C struct described by format string fmt.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.error" />
		<KeyWord name="struct.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.pack" func="yes">
			<Overload retVal="" descr="Return string containing values v1, v2, ... packed according to fmt.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.pack_into" func="yes">
			<Overload retVal="" descr="Pack the values v1, v2, ... according to fmt.&#10;Write the packed bytes into the writable buffer buf starting at offset.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.unpack" func="yes">
			<Overload retVal="" descr="Unpack the string containing packed C structure data, according to fmt.&#10;Requires len(string) == calcsize(fmt).">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.unpack_from" func="yes">
			<Overload retVal="" descr="Unpack the buffer, containing packed C structure data, according to&#10;fmt, starting at offset. Requires len(buffer[offset:]) &gt;= calcsize(fmt).">
			</Overload>
		</KeyWord>
		<KeyWord name="strxfrm" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="sub" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="subn" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess" func="yes">
			<Overload retVal="" descr="subprocess - Subprocesses with accessible I/O streams&#10;&#10;This module allows you to spawn processes, connect to their&#10;input/output/error pipes, and obtain their return codes.  This module&#10;intends to replace several older modules and functions:&#10;&#10;os.system&#10;os.spawn*&#10;os.popen*&#10;popen2.*&#10;commands.*&#10;&#10;Information about how the subprocess module can be used to replace these&#10;modules and functions can be found below.&#10;&#10;&#10;&#10;Using the subprocess module&#10;===========================&#10;This module defines one class called Popen:&#10;&#10;class Popen(args, bufsize=0, executable=None,&#10;            stdin=None, stdout=None, stderr=None,&#10;            preexec_fn=None, close_fds=False, shell=False,&#10;            cwd=None, env=None, universal_newlines=False,&#10;            startupinfo=None, creationflags=0):&#10;&#10;&#10;Arguments are:&#10;&#10;args should be a string, or a sequence of program arguments.  The&#10;program to execute is normally the first item in the args sequence or&#10;string, but can be explicitly set by using the executable argument.&#10;&#10;On UNIX, with shell=False (default): In this case, the Popen class&#10;uses os.execvp() to execute the child program.  args should normally&#10;be a sequence.  A string will be treated as a sequence with the string&#10;as the only item (the program to execute).&#10;&#10;On UNIX, with shell=True: If args is a string, it specifies the&#10;command string to execute through the shell.  If args is a sequence,&#10;the first item specifies the command string, and any additional items&#10;will be treated as additional shell arguments.&#10;&#10;On Windows: the Popen class uses CreateProcess() to execute the child&#10;program, which operates on strings.  If args is a sequence, it will be&#10;converted to a string using the list2cmdline method.  Please note that&#10;not all MS Windows applications interpret the command line the same&#10;way: The list2cmdline is designed for applications using the same&#10;rules as the MS C runtime.&#10;&#10;bufsize, if given, has the same meaning as the corresponding argument&#10;to the built-in open() function: 0 means unbuffered, 1 means line&#10;buffered, any other positive value means use a buffer of&#10;(approximately) that size.  A negative bufsize means to use the system&#10;default, which usually means fully buffered.  The default value for&#10;bufsize is 0 (unbuffered).&#10;&#10;stdin, stdout and stderr specify the executed programs' standard&#10;input, standard output and standard error file handles, respectively.&#10;Valid values are PIPE, an existing file descriptor (a positive&#10;integer), an existing file object, and None.  PIPE indicates that a&#10;new pipe to the child should be created.  With None, no redirection&#10;will occur; the child's file handles will be inherited from the&#10;parent.  Additionally, stderr can be STDOUT, which indicates that the&#10;stderr data from the applications should be captured into the same&#10;file handle as for stdout.&#10;&#10;If preexec_fn is set to a callable object, this object will be called&#10;in the child process just before the child is executed.&#10;&#10;If close_fds is true, all file descriptors except 0, 1 and 2 will be&#10;closed before the child process is executed.&#10;&#10;if shell is true, the specified command will be executed through the&#10;shell.&#10;&#10;If cwd is not None, the current directory will be changed to cwd&#10;before the child is executed.&#10;&#10;If env is not None, it defines the environment variables for the new&#10;process.&#10;&#10;If universal_newlines is true, the file objects stdout and stderr are&#10;opened as a text files, but lines may be terminated by any of '\n',&#10;the Unix end-of-line convention, '\r', the Macintosh convention or&#10;'\r\n', the Windows convention.  All of these external representations&#10;are seen as '\n' by the Python program.  Note: This feature is only&#10;available if Python is built with universal newline support (the&#10;default).  Also, the newlines attribute of the file objects stdout,&#10;stdin and stderr are not updated by the communicate() method.&#10;&#10;The startupinfo and creationflags, if given, will be passed to the&#10;underlying CreateProcess() function.  They can specify things such as&#10;appearance of the main window and priority for the new process.&#10;(Windows only)&#10;&#10;&#10;This module also defines some shortcut functions:&#10;&#10;call(*popenargs, **kwargs):&#10;    Run command with arguments.  Wait for command to complete, then&#10;    return the returncode attribute.&#10;&#10;    The arguments are the same as for the Popen constructor.  Example:&#10;&#10;    retcode = call([&quot;ls&quot;, &quot;-l&quot;])&#10;&#10;check_call(*popenargs, **kwargs):&#10;    Run command with arguments.  Wait for command to complete.  If the&#10;    exit code was zero then return, otherwise raise&#10;    CalledProcessError.  The CalledProcessError object will have the&#10;    return code in the returncode attribute.&#10;&#10;    The arguments are the same as for the Popen constructor.  Example:&#10;&#10;    check_call([&quot;ls&quot;, &quot;-l&quot;])&#10;&#10;check_output(*popenargs, **kwargs):&#10;    Run command with arguments and return its output as a byte string.&#10;&#10;    If the exit code was non-zero it raises a CalledProcessError.  The&#10;    CalledProcessError object will have the return code in the returncode&#10;    attribute and output in the output attribute.&#10;&#10;    The arguments are the same as for the Popen constructor.  Example:&#10;&#10;    output = check_output([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;])&#10;&#10;&#10;Exceptions&#10;----------&#10;Exceptions raised in the child process, before the new program has&#10;started to execute, will be re-raised in the parent.  Additionally,&#10;the exception object will have one extra attribute called&#10;'child_traceback', which is a string containing traceback information&#10;from the child's point of view.&#10;&#10;The most common exception raised is OSError.  This occurs, for&#10;example, when trying to execute a non-existent file.  Applications&#10;should prepare for OSErrors.&#10;&#10;A ValueError will be raised if Popen is called with invalid arguments.&#10;&#10;check_call() and check_output() will raise CalledProcessError, if the&#10;called process returns a non-zero return code.&#10;&#10;&#10;Security&#10;--------&#10;Unlike some other popen functions, this implementation will never call&#10;/bin/sh implicitly.  This means that all characters, including shell&#10;metacharacters, can safely be passed to child processes.&#10;&#10;&#10;Popen objects&#10;=============&#10;Instances of the Popen class have the following methods:&#10;&#10;poll()&#10;    Check if child process has terminated.  Returns returncode&#10;    attribute.&#10;&#10;wait()&#10;    Wait for child process to terminate.  Returns returncode attribute.&#10;&#10;communicate(input=None)&#10;    Interact with process: Send data to stdin.  Read data from stdout&#10;    and stderr, until end-of-file is reached.  Wait for process to&#10;    terminate.  The optional input argument should be a string to be&#10;    sent to the child process, or None, if no data should be sent to&#10;    the child.&#10;&#10;    communicate() returns a tuple (stdout, stderr).&#10;&#10;    Note: The data read is buffered in memory, so do not use this&#10;    method if the data size is large or unlimited.&#10;&#10;The following attributes are also available:&#10;&#10;stdin&#10;    If the stdin argument is PIPE, this attribute is a file object&#10;    that provides input to the child process.  Otherwise, it is None.&#10;&#10;stdout&#10;    If the stdout argument is PIPE, this attribute is a file object&#10;    that provides output from the child process.  Otherwise, it is&#10;    None.&#10;&#10;stderr&#10;    If the stderr argument is PIPE, this attribute is file object that&#10;    provides error output from the child process.  Otherwise, it is&#10;    None.&#10;&#10;pid&#10;    The process ID of the child process.&#10;&#10;returncode&#10;    The child return code.  A None value indicates that the process&#10;    hasn't terminated yet.  A negative value -N indicates that the&#10;    child was terminated by signal N (UNIX only).&#10;&#10;&#10;Replacing older functions with the subprocess module&#10;====================================================&#10;In this section, &quot;a ==&gt; b&quot; means that b can be used as a replacement&#10;for a.&#10;&#10;Note: All functions in this section fail (more or less) silently if&#10;the executed program cannot be found; this module raises an OSError&#10;exception.&#10;&#10;In the following examples, we assume that the subprocess module is&#10;imported with &quot;from subprocess import *&quot;.&#10;&#10;&#10;Replacing /bin/sh shell backquote&#10;---------------------------------&#10;output=`mycmd myarg`&#10;==&gt;&#10;output = Popen([&quot;mycmd&quot;, &quot;myarg&quot;], stdout=PIPE).communicate()[0]&#10;&#10;&#10;Replacing shell pipe line&#10;-------------------------&#10;output=`dmesg | grep hda`&#10;==&gt;&#10;p1 = Popen([&quot;dmesg&quot;], stdout=PIPE)&#10;p2 = Popen([&quot;grep&quot;, &quot;hda&quot;], stdin=p1.stdout, stdout=PIPE)&#10;output = p2.communicate()[0]&#10;&#10;&#10;Replacing os.system()&#10;---------------------&#10;sts = os.system(&quot;mycmd&quot; + &quot; myarg&quot;)&#10;==&gt;&#10;p = Popen(&quot;mycmd&quot; + &quot; myarg&quot;, shell=True)&#10;pid, sts = os.waitpid(p.pid, 0)&#10;&#10;Note:&#10;&#10;* Calling the program through the shell is usually not required.&#10;&#10;* It's easier to look at the returncode attribute than the&#10;  exitstatus.&#10;&#10;A more real-world example would look like this:&#10;&#10;try:&#10;    retcode = call(&quot;mycmd&quot; + &quot; myarg&quot;, shell=True)&#10;    if retcode &lt; 0:&#10;        print &gt;&gt;sys.stderr, &quot;Child was terminated by signal&quot;, -retcode&#10;    else:&#10;        print &gt;&gt;sys.stderr, &quot;Child returned&quot;, retcode&#10;except OSError, e:&#10;    print &gt;&gt;sys.stderr, &quot;Execution failed:&quot;, e&#10;&#10;&#10;Replacing os.spawn*&#10;-------------------&#10;P_NOWAIT example:&#10;&#10;pid = os.spawnlp(os.P_NOWAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;)&#10;==&gt;&#10;pid = Popen([&quot;/bin/mycmd&quot;, &quot;myarg&quot;]).pid&#10;&#10;&#10;P_WAIT example:&#10;&#10;retcode = os.spawnlp(os.P_WAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;)&#10;==&gt;&#10;retcode = call([&quot;/bin/mycmd&quot;, &quot;myarg&quot;])&#10;&#10;&#10;Vector example:&#10;&#10;os.spawnvp(os.P_NOWAIT, path, args)&#10;==&gt;&#10;Popen([path] + args[1:])&#10;&#10;&#10;Environment example:&#10;&#10;os.spawnlpe(os.P_NOWAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;, env)&#10;==&gt;&#10;Popen([&quot;/bin/mycmd&quot;, &quot;myarg&quot;], env={&quot;PATH&quot;: &quot;/usr/bin&quot;})&#10;&#10;&#10;Replacing os.popen*&#10;-------------------&#10;pipe = os.popen(&quot;cmd&quot;, mode='r', bufsize)&#10;==&gt;&#10;pipe = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize, stdout=PIPE).stdout&#10;&#10;pipe = os.popen(&quot;cmd&quot;, mode='w', bufsize)&#10;==&gt;&#10;pipe = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize, stdin=PIPE).stdin&#10;&#10;&#10;(child_stdin, child_stdout) = os.popen2(&quot;cmd&quot;, mode, bufsize)&#10;==&gt;&#10;p = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize,&#10;          stdin=PIPE, stdout=PIPE, close_fds=True)&#10;(child_stdin, child_stdout) = (p.stdin, p.stdout)&#10;&#10;&#10;(child_stdin,&#10; child_stdout,&#10; child_stderr) = os.popen3(&quot;cmd&quot;, mode, bufsize)&#10;==&gt;&#10;p = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize,&#10;          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)&#10;(child_stdin,&#10; child_stdout,&#10; child_stderr) = (p.stdin, p.stdout, p.stderr)&#10;&#10;&#10;(child_stdin, child_stdout_and_stderr) = os.popen4(&quot;cmd&quot;, mode,&#10;                                                   bufsize)&#10;==&gt;&#10;p = Popen(&quot;cmd&quot;, shell=True, bufsize=bufsize,&#10;          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)&#10;(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)&#10;&#10;On Unix, os.popen2, os.popen3 and os.popen4 also accept a sequence as&#10;the command to execute, in which case arguments will be passed&#10;directly to the program without shell intervention.  This usage can be&#10;replaced as follows:&#10;&#10;(child_stdin, child_stdout) = os.popen2([&quot;/bin/ls&quot;, &quot;-l&quot;], mode,&#10;                                        bufsize)&#10;==&gt;&#10;p = Popen([&quot;/bin/ls&quot;, &quot;-l&quot;], bufsize=bufsize, stdin=PIPE, stdout=PIPE)&#10;(child_stdin, child_stdout) = (p.stdin, p.stdout)&#10;&#10;Return code handling translates as follows:&#10;&#10;pipe = os.popen(&quot;cmd&quot;, 'w')&#10;...&#10;rc = pipe.close()&#10;if rc is not None and rc % 256:&#10;    print &quot;There were some errors&quot;&#10;==&gt;&#10;process = Popen(&quot;cmd&quot;, 'w', shell=True, stdin=PIPE)&#10;...&#10;process.stdin.close()&#10;if process.wait() != 0:&#10;    print &quot;There were some errors&quot;&#10;&#10;&#10;Replacing popen2.*&#10;------------------&#10;(child_stdout, child_stdin) = popen2.popen2(&quot;somestring&quot;, bufsize, mode)&#10;==&gt;&#10;p = Popen([&quot;somestring&quot;], shell=True, bufsize=bufsize&#10;          stdin=PIPE, stdout=PIPE, close_fds=True)&#10;(child_stdout, child_stdin) = (p.stdout, p.stdin)&#10;&#10;On Unix, popen2 also accepts a sequence as the command to execute, in&#10;which case arguments will be passed directly to the program without&#10;shell intervention.  This usage can be replaced as follows:&#10;&#10;(child_stdout, child_stdin) = popen2.popen2([&quot;mycmd&quot;, &quot;myarg&quot;], bufsize,&#10;                                            mode)&#10;==&gt;&#10;p = Popen([&quot;mycmd&quot;, &quot;myarg&quot;], bufsize=bufsize,&#10;          stdin=PIPE, stdout=PIPE, close_fds=True)&#10;(child_stdout, child_stdin) = (p.stdout, p.stdin)&#10;&#10;The popen2.Popen3 and popen2.Popen4 basically works as subprocess.Popen,&#10;except that:&#10;&#10;* subprocess.Popen raises an exception if the execution fails&#10;* the capturestderr argument is replaced with the stderr argument.&#10;* stdin=PIPE and stdout=PIPE must be specified.&#10;* popen2 closes all filedescriptors by default, but you have to specify&#10;  close_fds=True with subprocess.Popen.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CREATE_NEW_CONSOLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CREATE_NEW_PROCESS_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError" func="yes">
			<Overload retVal="" descr="This exception is raised when a process run by check_call() or&#10;check_output() returns a non-zero exit status.&#10;The exit status will be stored in the returncode attribute;&#10;check_output() will also store the output in the output attribute.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.MAXFD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.PIPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen" />
		<KeyWord name="subprocess.Popen.communicate" func="yes">
			<Overload retVal="" descr="Interact with process: Send data to stdin.  Read data from&#10;stdout and stderr, until end-of-file is reached.  Wait for&#10;process to terminate.  The optional input argument should be a&#10;string to be sent to the child process, or None, if no data&#10;should be sent to the child.&#10;&#10;communicate() returns a tuple (stdout, stderr).">
				<Param name="self" />
				<Param name="[input=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.kill" func="yes">
			<Overload retVal="" descr="Terminates the process">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.poll" />
		<KeyWord name="subprocess.Popen.send_signal" func="yes">
			<Overload retVal="" descr="Send a signal to the process">
				<Param name="self" />
				<Param name="sig" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.terminate" func="yes">
			<Overload retVal="" descr="Terminates the process">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.wait" func="yes">
			<Overload retVal="" descr="Wait for child process to terminate.  Returns returncode&#10;attribute.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STARTF_USESHOWWINDOW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STARTF_USESTDHANDLES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STARTUPINFO" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STDOUT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STD_ERROR_HANDLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STD_INPUT_HANDLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STD_OUTPUT_HANDLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.call" func="yes">
			<Overload retVal="" descr='Run command with arguments.  Wait for command to complete, then&#10;return the returncode attribute.&#10;&#10;The arguments are the same as for the Popen constructor.  Example:&#10;&#10;retcode = call(["ls", "-l"])'>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.check_call" func="yes">
			<Overload retVal="" descr='Run command with arguments.  Wait for command to complete.  If&#10;the exit code was zero then return, otherwise raise&#10;CalledProcessError.  The CalledProcessError object will have the&#10;return code in the returncode attribute.&#10;&#10;The arguments are the same as for the Popen constructor.  Example:&#10;&#10;check_call(["ls", "-l"])'>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.check_output" func="yes">
			<Overload retVal="" descr="Run command with arguments and return its output as a byte string.&#10;&#10;If the exit code was non-zero it raises a CalledProcessError.  The&#10;CalledProcessError object will have the return code in the returncode&#10;attribute and output in the output attribute.&#10;&#10;The arguments are the same as for the Popen constructor.  Example:&#10;&#10;&gt;&gt;&gt; check_output([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;])&#10;'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'&#10;&#10;The stdout argument is not allowed as it is used internally.&#10;To capture standard error in the result, use stderr=STDOUT.&#10;&#10;&gt;&gt;&gt; check_output([&quot;/bin/sh&quot;, &quot;-c&quot;,&#10;...               &quot;ls -l non_existent_file ; exit 0&quot;],&#10;...              stderr=STDOUT)&#10;'ls: non_existent_file: No such file or directory\n'">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.list2cmdline" func="yes">
			<Overload retVal="" descr="Translate a sequence of arguments into a command line&#10;string, using the same rules as the MS C runtime:&#10;&#10;1) Arguments are delimited by white space, which is either a&#10;   space or a tab.&#10;&#10;2) A string surrounded by double quotation marks is&#10;   interpreted as a single argument, regardless of white space&#10;   contained within.  A quoted string can be embedded in an&#10;   argument.&#10;&#10;3) A double quotation mark preceded by a backslash is&#10;   interpreted as a literal double quotation mark.&#10;&#10;4) Backslashes are interpreted literally, unless they&#10;   immediately precede a double quotation mark.&#10;&#10;5) If backslashes immediately precede a double quotation mark,&#10;   every pair of backslashes is interpreted as a literal&#10;   backslash.  If the number of backslashes is odd, the last&#10;   backslash escapes the next double quotation mark as&#10;   described in rule 3.">
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.mswindows" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.pywintypes" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="subst" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="subtract" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="sum" func="yes">
			<Overload retVal="" descr="sum(sequence[, start]) -&gt; value&#10;&#10;Return the sum of a sequence of numbers (NOT strings) plus the value&#10;of parameter 'start' (which defaults to 0).  When the sequence is&#10;empty, return start.">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau" func="yes">
			<Overload retVal="" descr="Stuff to parse Sun and NeXT audio files.&#10;&#10;An audio file consists of a header followed by the data.  The structure&#10;of the header is as follows.&#10;&#10;        +---------------+&#10;        | magic word    |&#10;        +---------------+&#10;        | header size   |&#10;        +---------------+&#10;        | data size     |&#10;        +---------------+&#10;        | encoding      |&#10;        +---------------+&#10;        | sample rate   |&#10;        +---------------+&#10;        | # of channels |&#10;        +---------------+&#10;        | info          |&#10;        |               |&#10;        +---------------+&#10;&#10;The magic word consists of the 4 characters '.snd'.  Apart from the&#10;info field, all header fields are 4 bytes in size.  They are all&#10;32-bit unsigned integers encoded in big-endian byte order.&#10;&#10;The header size really gives the start of the data.&#10;The data size is the physical size of the data.  From the other&#10;parameters the number of frames can be calculated.&#10;The encoding gives the way in which audio samples are encoded.&#10;Possible values are listed below.&#10;The info field currently consists of an ASCII string giving a&#10;human-readable description of the audio file.  The info field is&#10;padded with NUL bytes to the header size.&#10;&#10;Usage.&#10;&#10;Reading audio files:&#10;        f = sunau.open(file, 'r')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods read(), seek(), and close().&#10;When the setpos() and rewind() methods are not used, the seek()&#10;method is not  necessary.&#10;&#10;This returns an instance of a class with the following public methods:&#10;        getnchannels()  -- returns number of audio channels (1 for&#10;                           mono, 2 for stereo)&#10;        getsampwidth()  -- returns sample width in bytes&#10;        getframerate()  -- returns sampling frequency&#10;        getnframes()    -- returns number of audio frames&#10;        getcomptype()   -- returns compression type ('NONE' or 'ULAW')&#10;        getcompname()   -- returns human-readable version of&#10;                           compression type ('not compressed' matches 'NONE')&#10;        getparams()     -- returns a tuple consisting of all of the&#10;                           above in the above order&#10;        getmarkers()    -- returns None (for compatibility with the&#10;                           aifc module)&#10;        getmark(id)     -- raises an error since the mark does not&#10;                           exist (for compatibility with the aifc module)&#10;        readframes(n)   -- returns at most n frames of audio&#10;        rewind()        -- rewind to the beginning of the audio stream&#10;        setpos(pos)     -- seek to the specified position&#10;        tell()          -- return the current position&#10;        close()         -- close the instance (make it unusable)&#10;The position returned by tell() and the position given to setpos()&#10;are compatible and have nothing to do with the actual position in the&#10;file.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;Writing audio files:&#10;        f = sunau.open(file, 'w')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods write(), tell(), seek(), and&#10;close().&#10;&#10;This returns an instance of a class with the following public methods:&#10;        setnchannels(n) -- set the number of channels&#10;        setsampwidth(n) -- set the sample width&#10;        setframerate(n) -- set the frame rate&#10;        setnframes(n)   -- set the number of frames&#10;        setcomptype(type, name)&#10;                        -- set the compression type and the&#10;                           human-readable compression type&#10;        setparams(tuple)-- set all parameters at once&#10;        tell()          -- return current position in output file&#10;        writeframesraw(data)&#10;                        -- write audio frames without pathing up the&#10;                           file header&#10;        writeframes(data)&#10;                        -- write audio frames and patch up the file header&#10;        close()         -- patch up the file header and close the&#10;                           output file&#10;You should set the parameters before the first writeframesraw or&#10;writeframes.  The total number of frames does not need to be set,&#10;but when it is set to the correct value, the header does not have to&#10;be patched up.&#10;It is best to first set all parameters, perhaps possibly the&#10;compression type, and then write audio frames using writeframesraw.&#10;When all frames have been written, either call writeframes('') or&#10;close() to patch up the sizes in the header.&#10;The close() method is called automatically when the class instance&#10;is destroyed.">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G721" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G722" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G723_3" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G723_5" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ALAW_8" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_DOUBLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_FLOAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_16" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_24" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_32" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_8" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_MULAW_8" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_UNKNOWN_SIZE" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Au_read" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Au_write" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Error" />
		<KeyWord name="sunau.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.openfp" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio" func="yes">
			<Overload retVal="" descr="Interpret sun audio headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio.MAGIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio.error" />
		<KeyWord name="sunaudio.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio.get_long_be" func="yes">
			<Overload retVal="" descr="Convert a 4-char value to integer.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio.gethdr" func="yes">
			<Overload retVal="" descr="Read a sound header from an open file.">
				<Param name="fp" />
			</Overload>
		</KeyWord>
		<KeyWord name="sunaudio.printhdr" func="yes">
			<Overload retVal="" descr="Read and print the sound header of a named file.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="super" func="yes">
			<Overload retVal="" descr="super(type, obj) -&gt; bound super object; requires isinstance(obj, type)&#10;super(type) -&gt; unbound super object&#10;super(type, type2) -&gt; bound super object; requires issubclass(type2, type)&#10;Typical use to call a cooperative superclass method:&#10;class C(B):&#10;    def meth(self, arg):&#10;        super(C, self).meth(arg)">
			</Overload>
		</KeyWord>
		<KeyWord name="swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol" func="yes">
			<Overload retVal="" descr='Non-terminal symbols of Python grammar (from "graminit.h").'>
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.and_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.and_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.arglist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.argument" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.arith_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.assert_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.atom" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.augassign" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.break_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.classdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_for" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_if" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_iter" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_op" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comparison" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.compound_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.continue_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.decorated" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.decorator" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.decorators" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.del_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dictorsetmaker" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dotted_as_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dotted_as_names" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dotted_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.encoding_decl" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.eval_input" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.except_clause" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.exec_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.expr_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.exprlist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.factor" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.file_input" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.flow_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.for_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.fpdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.fplist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.funcdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.global_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.if_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_as_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_as_names" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_from" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.lambdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.list_for" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.list_if" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.list_iter" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.listmaker" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.main" />
		<KeyWord name="symbol.not_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.old_lambdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.old_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.or_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.parameters" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.pass_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.power" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.print_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.raise_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.return_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.shift_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.simple_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.single_input" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.sliceop" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.small_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.subscript" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.subscriptlist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.suite" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.sym_name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.term" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist_comp" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist_safe" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.trailer" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.try_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.varargslist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.while_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.with_item" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.with_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.xor_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.yield_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.yield_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symmetric_difference" func="yes">
			<Overload retVal="" descr="Return the symmetric difference of two sets as a new set.&#10;&#10;(i.e. all elements that are in exactly one of the sets.)">
			</Overload>
		</KeyWord>
		<KeyWord name="symmetric_difference_update" func="yes">
			<Overload retVal="" descr="Update a set with the symmetric difference of itself and another.">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable" func="yes">
			<Overload retVal="" descr="Interface to the compiler's internal symbol tables">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.CELL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Class" />
		<KeyWord name="symtable.Class.get_children" />
		<KeyWord name="symtable.Class.get_id" />
		<KeyWord name="symtable.Class.get_identifiers" />
		<KeyWord name="symtable.Class.get_lineno" />
		<KeyWord name="symtable.Class.get_methods" />
		<KeyWord name="symtable.Class.get_name" />
		<KeyWord name="symtable.Class.get_symbols" />
		<KeyWord name="symtable.Class.get_type" />
		<KeyWord name="symtable.Class.has_children" />
		<KeyWord name="symtable.Class.has_exec" func="yes">
			<Overload retVal="" descr="Return true if the scope uses exec">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Class.has_import_star" func="yes">
			<Overload retVal="" descr="Return true if the scope uses import *">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Class.is_nested" />
		<KeyWord name="symtable.Class.is_optimized" />
		<KeyWord name="symtable.Class.lookup" />
		<KeyWord name="symtable.DEF_BOUND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_GLOBAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_IMPORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_LOCAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_PARAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.FREE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Function" />
		<KeyWord name="symtable.Function.get_children" />
		<KeyWord name="symtable.Function.get_frees" />
		<KeyWord name="symtable.Function.get_globals" />
		<KeyWord name="symtable.Function.get_id" />
		<KeyWord name="symtable.Function.get_identifiers" />
		<KeyWord name="symtable.Function.get_lineno" />
		<KeyWord name="symtable.Function.get_locals" />
		<KeyWord name="symtable.Function.get_name" />
		<KeyWord name="symtable.Function.get_parameters" />
		<KeyWord name="symtable.Function.get_symbols" />
		<KeyWord name="symtable.Function.get_type" />
		<KeyWord name="symtable.Function.has_children" />
		<KeyWord name="symtable.Function.has_exec" func="yes">
			<Overload retVal="" descr="Return true if the scope uses exec">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Function.has_import_star" func="yes">
			<Overload retVal="" descr="Return true if the scope uses import *">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Function.is_nested" />
		<KeyWord name="symtable.Function.is_optimized" />
		<KeyWord name="symtable.Function.lookup" />
		<KeyWord name="symtable.GLOBAL_EXPLICIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.GLOBAL_IMPLICIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.LOCAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.OPT_BARE_EXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.OPT_EXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.OPT_IMPORT_STAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SCOPE_MASK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SCOPE_OFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol" />
		<KeyWord name="symtable.Symbol.get_name" />
		<KeyWord name="symtable.Symbol.get_namespace" func="yes">
			<Overload retVal="" descr="Returns the single namespace bound to this name.&#10;&#10;Raises ValueError if the name is bound to multiple namespaces.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol.get_namespaces" func="yes">
			<Overload retVal="" descr="Return a list of namespaces bound to this name">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol.is_assigned" />
		<KeyWord name="symtable.Symbol.is_declared_global" />
		<KeyWord name="symtable.Symbol.is_free" />
		<KeyWord name="symtable.Symbol.is_global" />
		<KeyWord name="symtable.Symbol.is_imported" />
		<KeyWord name="symtable.Symbol.is_local" />
		<KeyWord name="symtable.Symbol.is_namespace" func="yes">
			<Overload retVal="" descr="Returns true if name binding introduces new namespace.&#10;&#10;If the name is used as the target of a function or class&#10;statement, this will be true.&#10;&#10;Note that a single name can be bound to multiple objects.  If&#10;is_namespace() is true, the name may also be bound to other&#10;objects, like an int or list, that does not introduce a new&#10;namespace.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol.is_parameter" />
		<KeyWord name="symtable.Symbol.is_referenced" />
		<KeyWord name="symtable.SymbolTable" />
		<KeyWord name="symtable.SymbolTable.get_children" />
		<KeyWord name="symtable.SymbolTable.get_id" />
		<KeyWord name="symtable.SymbolTable.get_identifiers" />
		<KeyWord name="symtable.SymbolTable.get_lineno" />
		<KeyWord name="symtable.SymbolTable.get_name" />
		<KeyWord name="symtable.SymbolTable.get_symbols" />
		<KeyWord name="symtable.SymbolTable.get_type" />
		<KeyWord name="symtable.SymbolTable.has_children" />
		<KeyWord name="symtable.SymbolTable.has_exec" func="yes">
			<Overload retVal="" descr="Return true if the scope uses exec">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SymbolTable.has_import_star" func="yes">
			<Overload retVal="" descr="Return true if the scope uses import *">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SymbolTable.is_nested" />
		<KeyWord name="symtable.SymbolTable.is_optimized" />
		<KeyWord name="symtable.SymbolTable.lookup" />
		<KeyWord name="symtable.SymbolTableFactory" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.USE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.symtable" />
		<KeyWord name="synopsis" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig" func="yes">
			<Overload retVal="" descr="Provide access to Python's configuration information.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_config_h_filename" func="yes">
			<Overload retVal="" descr="Returns the path of pyconfig.h.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_config_var" func="yes">
			<Overload retVal="" descr="Return the value of a single variable using the dictionary returned by&#10;'get_config_vars()'.&#10;&#10;Equivalent to get_config_vars().get(name)">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_config_vars" func="yes">
			<Overload retVal="" descr="With no arguments, return a dictionary of all configuration&#10;variables relevant for the current platform.&#10;&#10;On Unix, this means every variable defined in Python's installed Makefile;&#10;On Windows and Mac OS it's a much smaller set.&#10;&#10;With arguments, return a list of values that result from looking up&#10;each argument in the configuration variable dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_makefile_filename" func="yes">
			<Overload retVal="" descr="Return the path of the Makefile.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_path" func="yes">
			<Overload retVal="" descr="Returns a path corresponding to the scheme.&#10;&#10;``scheme`` is the install scheme name.">
				<Param name="name" />
				<Param name="[scheme=nt" />
				<Param name="[vars=None" />
				<Param name="[expand=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_path_names" func="yes">
			<Overload retVal="" descr="Returns a tuple containing the paths names.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_paths" func="yes">
			<Overload retVal="" descr="Returns a mapping containing an install scheme.&#10;&#10;``scheme`` is the install scheme name. If not provided, it will&#10;return the default scheme for the current platform.">
				<Param name="[scheme=nt" />
				<Param name="[vars=None" />
				<Param name="[expand=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_platform" func="yes">
			<Overload retVal="" descr="Return a string that identifies the current platform.&#10;&#10;This is used mainly to distinguish platform-specific build directories and&#10;platform-specific built distributions.  Typically includes the OS name&#10;and version and the architecture (as supplied by 'os.uname()'),&#10;although the exact information included depends on the OS; eg. for IRIX&#10;the architecture isn't particularly important (IRIX only runs on SGI&#10;hardware), but for Linux the kernel version isn't particularly&#10;important.&#10;&#10;Examples of returned values:&#10;   linux-i586&#10;   linux-alpha (?)&#10;   solaris-2.6-sun4u&#10;   irix-5.3&#10;   irix64-6.2&#10;&#10;Windows will return one of:&#10;   win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)&#10;   win-ia64 (64bit Windows on Itanium)&#10;   win32 (all others - specifically, sys.platform is returned)&#10;&#10;For other non-POSIX platforms, currently just returns 'sys.platform'.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_python_version" />
		<KeyWord name="sysconfig.get_scheme_names" func="yes">
			<Overload retVal="" descr="Returns a tuple containing the schemes names.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.is_python_build" />
		<KeyWord name="sysconfig.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.parse_config_h" func="yes">
			<Overload retVal="" descr="Parse a config.h-style file.&#10;&#10;A dictionary containing name/value pairs is returned.  If an&#10;optional dictionary is passed in as the second argument, it is&#10;used instead of a new dictionary.">
				<Param name="fp" />
				<Param name="[vars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.realpath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="system" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="system_alias" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="t" func="yes">
			<Overload retVal="" descr="Function of copy.t">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny" func="yes">
			<Overload retVal="" descr="The Tab Nanny despises ambiguous indentation.  She knows no mercy.&#10;&#10;tabnanny -- Detection of ambiguous indentation&#10;&#10;For the time being this module is intended to be called as a script.&#10;However it is possible to import it into an IDE and use the function&#10;check() described below.&#10;&#10;Warning: The API provided by this module is likely to change in future&#10;releases; such changes may not be backward compatible.">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.NannyNag" func="yes">
			<Overload retVal="" descr="Raised by tokeneater() if detecting an ambiguous indent.&#10;Captured and handled in check().">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.NannyNag.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.NannyNag.get_line" />
		<KeyWord name="tabnanny.NannyNag.get_lineno" />
		<KeyWord name="tabnanny.NannyNag.get_msg" />
		<KeyWord name="tabnanny.NannyNag.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.Whitespace" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.check" func="yes">
			<Overload retVal="" descr="check(file_or_dir)&#10;&#10;If file_or_dir is a directory and not a symbolic link, then recursively&#10;descend the directory tree named by file_or_dir, checking all .py files&#10;along the way. If file_or_dir is an ordinary Python source file, it is&#10;checked for whitespace related problems. The diagnostic messages are&#10;written to standard output using the print statement.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.errprint" />
		<KeyWord name="tabnanny.format_witnesses" />
		<KeyWord name="tabnanny.main" />
		<KeyWord name="tabnanny.process_tokens" />
		<KeyWord name="tan" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="tanh" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile" func="yes">
			<Overload retVal="" descr="Read from and write to tar format archives.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.AREGTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.BLKTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.BLOCKSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CHRTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CONTTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CompressionError" func="yes">
			<Overload retVal="" descr="Exception for unavailable compression methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CompressionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CompressionError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.DEFAULT_FORMAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.DIRTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ENCODING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EOFHeaderError" func="yes">
			<Overload retVal="" descr="Exception for end of file headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EOFHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EOFHeaderError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EmptyHeaderError" func="yes">
			<Overload retVal="" descr="Exception for empty headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EmptyHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EmptyHeaderError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject" func="yes">
			<Overload retVal="" descr="File-like object for reading an archive member.&#10;Is returned by TarFile.extractfile().">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.blocksize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.close" func="yes">
			<Overload retVal="" descr="Close the file object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes from the file. If size is not&#10;present or None, read all data until EOF is reached.">
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.readline" func="yes">
			<Overload retVal="" descr="Read one entire line from the file. If size is present&#10;and non-negative, return a string with at most that&#10;size, which may be an incomplete line.">
				<Param name="self" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.readlines" func="yes">
			<Overload retVal="" descr="Return a list with all remaining lines.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.seek" func="yes">
			<Overload retVal="" descr="Seek to a position in the file.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.tell" func="yes">
			<Overload retVal="" descr="Return the current file position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExtractError" func="yes">
			<Overload retVal="" descr="General exception for extract errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExtractError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExtractError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.FIFOTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNUTYPE_LONGLINK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNUTYPE_LONGNAME" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNUTYPE_SPARSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNU_FORMAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNU_MAGIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNU_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.HeaderError" func="yes">
			<Overload retVal="" descr="Base exception for header errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.HeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.HeaderError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.InvalidHeaderError" func="yes">
			<Overload retVal="" descr="Exception for invalid headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.InvalidHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.InvalidHeaderError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LENGTH_LINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LENGTH_NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LENGTH_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LNKTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.NUL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_FIELDS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_FORMAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_NUMBER_FIELDS" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.POSIX_MAGIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.RECORDSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.REGTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.REGULAR_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ReadError" func="yes">
			<Overload retVal="" descr="Exception for unreadable tar archives.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ReadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ReadError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SOLARIS_XHDTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SUPPORTED_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SYMTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.S_IFBLK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.S_IFCHR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.S_IFDIR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.S_IFIFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.S_IFLNK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.S_IFREG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.StreamError" func="yes">
			<Overload retVal="" descr="Exception for unsupported operations on stream-like TarFiles.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.StreamError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.StreamError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SubsequentHeaderError" func="yes">
			<Overload retVal="" descr="Exception for missing and invalid extended headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SubsequentHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SubsequentHeaderError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TAR_GZIPPED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TGEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TGREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TGWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TOEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TOREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TOWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TSGID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TSUID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TSVTX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TUEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TUREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TUWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarError" func="yes">
			<Overload retVal="" descr="Base exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile" func="yes">
			<Overload retVal="" descr="The TarFile Class provides an interface to tar archives.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.OPEN_METH" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.add" func="yes">
			<Overload retVal="" descr="Add the file `name' to the archive. `name' may be any type of file&#10;(directory, fifo, symbolic link, etc.). If given, `arcname'&#10;specifies an alternative name for the file in the archive.&#10;Directories are added recursively by default. This can be avoided by&#10;setting `recursive' to False. `exclude' is a function that should&#10;return True for each filename to be excluded. `filter' is a function&#10;that expects a TarInfo object argument and returns the changed&#10;TarInfo object, if it returns None the TarInfo object will be&#10;excluded from the archive.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[arcname=None" />
				<Param name="[recursive=True" />
				<Param name="[exclude=None" />
				<Param name="[filter=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.addfile" func="yes">
			<Overload retVal="" descr="Add the TarInfo object `tarinfo' to the archive. If `fileobj' is&#10;given, tarinfo.size bytes are read from it and added to the archive.&#10;You can create TarInfo objects using gettarinfo().&#10;On Windows platforms, `fileobj' should always be opened with mode&#10;'rb' to avoid irritation about the file size.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="[fileobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.bz2open" func="yes">
			<Overload retVal="" descr="Open bzip2 compressed tar archive name for reading or writing.&#10;Appending is not allowed.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[compresslevel=9" />
				<Param name="[**]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.chmod" func="yes">
			<Overload retVal="" descr="Set file permissions of targetpath according to tarinfo.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.chown" func="yes">
			<Overload retVal="" descr="Set owner of targetpath according to tarinfo.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.close" func="yes">
			<Overload retVal="" descr="Close the TarFile. In write-mode, two finishing zero blocks are&#10;appended to the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.errorlevel" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a TarInfo object. You can&#10;specify a different directory using `path'.">
				<Param name="self" />
				<Param name="member" />
				<Param name="[path]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory and set owner, modification time and permissions on&#10;directories afterwards. `path' specifies a different directory&#10;to extract to. `members' is optional and must be a subset of the&#10;list returned by getmembers().">
				<Param name="self" />
				<Param name="[path=." />
				<Param name="[members=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.extractfile" func="yes">
			<Overload retVal="" descr="Extract a member from the archive as a file object. `member' may be&#10;a filename or a TarInfo object. If `member' is a regular file, a&#10;file-like object is returned. If `member' is a link, a file-like&#10;object is constructed from the link's target. If `member' is none of&#10;the above, None is returned.&#10;The file-like object is read-only and provides the following&#10;methods: read(), readline(), readlines(), seek() and tell()">
				<Param name="self" />
				<Param name="member" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.fileobject" func="yes">
			<Overload retVal="" descr="File-like object for reading an archive member.&#10;Is returned by TarFile.extractfile().">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.format" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.getmember" func="yes">
			<Overload retVal="" descr="Return a TarInfo object for member `name'. If `name' can not be&#10;found in the archive, KeyError is raised. If a member occurs more&#10;than once in the archive, its last occurrence is assumed to be the&#10;most up-to-date version.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.getmembers" func="yes">
			<Overload retVal="" descr="Return the members of the archive as a list of TarInfo objects. The&#10;list has the same order as the members in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.getnames" func="yes">
			<Overload retVal="" descr="Return the members of the archive as a list of their names. It has&#10;the same order as the list returned by getmembers().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.gettarinfo" func="yes">
			<Overload retVal="" descr="Create a TarInfo object for either the file `name' or the file&#10;object `fileobj' (using os.fstat on its file descriptor). You can&#10;modify some of the TarInfo's attributes before you add it using&#10;addfile(). If given, `arcname' specifies an alternative name for the&#10;file in the archive.">
				<Param name="self" />
				<Param name="[name=None" />
				<Param name="[arcname=None" />
				<Param name="[fileobj=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.gzopen" func="yes">
			<Overload retVal="" descr="Open gzip compressed tar archive name for reading or writing.&#10;Appending is not allowed.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[compresslevel=9" />
				<Param name="[**]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.list" func="yes">
			<Overload retVal="" descr="Print a table of contents to sys.stdout. If `verbose' is False, only&#10;the names of the members are printed. If it is True, an `ls -l'-like&#10;output is produced.">
				<Param name="self" />
				<Param name="[verbose=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makedev" func="yes">
			<Overload retVal="" descr="Make a character or block device called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makedir" func="yes">
			<Overload retVal="" descr="Make a directory called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makefifo" func="yes">
			<Overload retVal="" descr="Make a fifo called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makefile" func="yes">
			<Overload retVal="" descr="Make a file called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makelink" func="yes">
			<Overload retVal="" descr="Make a (symbolic) link called targetpath. If it cannot be created&#10;(platform limitation), we try to make a copy of the referenced file&#10;instead of a link.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makeunknown" func="yes">
			<Overload retVal="" descr="Make a file from a TarInfo object with an unknown type&#10;at targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.next" func="yes">
			<Overload retVal="" descr="Return the next member of the archive as a TarInfo object, when&#10;TarFile is opened for reading. Return None if there is no more&#10;available.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.open" func="yes">
			<Overload retVal="" descr="Open a tar archive for reading, writing or appending. Return&#10;an appropriate TarFile class.&#10;&#10;mode:&#10;'r' or 'r:*' open for reading with transparent compression&#10;'r:'         open for reading exclusively uncompressed&#10;'r:gz'       open for reading with gzip compression&#10;'r:bz2'      open for reading with bzip2 compression&#10;'a' or 'a:'  open for appending, creating the file if necessary&#10;'w' or 'w:'  open for writing without compression&#10;'w:gz'       open for writing with gzip compression&#10;'w:bz2'      open for writing with bzip2 compression&#10;&#10;'r|*'        open a stream of tar blocks with transparent compression&#10;'r|'         open an uncompressed stream of tar blocks for reading&#10;'r|gz'       open a gzip compressed stream of tar blocks&#10;'r|bz2'      open a bzip2 compressed stream of tar blocks&#10;'w|'         open an uncompressed stream for writing&#10;'w|gz'       open a gzip compressed stream for writing&#10;'w|bz2'      open a bzip2 compressed stream for writing">
				<Param name="cls" />
				<Param name="[name=None" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[bufsize=10240" />
				<Param name="[**]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.posix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.tarinfo" func="yes">
			<Overload retVal="" descr="Informational class which holds the details about an&#10;archive member given by a tar header block.&#10;TarInfo objects are returned by TarFile.getmember(),&#10;TarFile.getmembers() and TarFile.gettarinfo() and are&#10;usually created internally.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.taropen" func="yes">
			<Overload retVal="" descr="Open uncompressed tar archive name for reading or writing.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.utime" func="yes">
			<Overload retVal="" descr="Set modification time of targetpath according to tarinfo.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFileCompat" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo" func="yes">
			<Overload retVal="" descr="Informational class which holds the details about an&#10;archive member given by a tar header block.&#10;TarInfo objects are returned by TarFile.getmember(),&#10;TarFile.getmembers() and TarFile.gettarinfo() and are&#10;usually created internally.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_gnu_header" func="yes">
			<Overload retVal="" descr="Return the object as a GNU header block sequence.">
				<Param name="self" />
				<Param name="info" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_pax_global_header" func="yes">
			<Overload retVal="" descr="Return the object as a pax global header block sequence.">
				<Param name="cls" />
				<Param name="pax_headers" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_pax_header" func="yes">
			<Overload retVal="" descr="Return the object as a ustar header block. If it cannot be&#10;represented this way, prepend a pax extended header sequence&#10;with supplement information.">
				<Param name="self" />
				<Param name="info" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_ustar_header" func="yes">
			<Overload retVal="" descr="Return the object as a ustar header block.">
				<Param name="self" />
				<Param name="info" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.frombuf" func="yes">
			<Overload retVal="" descr="Construct a TarInfo object from a 512 byte string buffer.">
				<Param name="cls" />
				<Param name="buf" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.fromtarfile" func="yes">
			<Overload retVal="" descr="Return the next TarInfo object from TarFile object&#10;tarfile.">
				<Param name="cls" />
				<Param name="tarfile" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.get_info" func="yes">
			<Overload retVal="" descr="Return the TarInfo's attributes as a dictionary.">
				<Param name="self" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.isblk" />
		<KeyWord name="tarfile.TarInfo.ischr" />
		<KeyWord name="tarfile.TarInfo.isdev" />
		<KeyWord name="tarfile.TarInfo.isdir" />
		<KeyWord name="tarfile.TarInfo.isfifo" />
		<KeyWord name="tarfile.TarInfo.isfile" />
		<KeyWord name="tarfile.TarInfo.islnk" />
		<KeyWord name="tarfile.TarInfo.isreg" />
		<KeyWord name="tarfile.TarInfo.issparse" />
		<KeyWord name="tarfile.TarInfo.issym" />
		<KeyWord name="tarfile.TarInfo.linkpath" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.path" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.tobuf" func="yes">
			<Overload retVal="" descr="Return a tar header as a string of 512 byte blocks.">
				<Param name="self" />
				<Param name="[format=1" />
				<Param name="[encoding=mbcs" />
				<Param name="[errors=strict]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarIter" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TruncatedHeaderError" func="yes">
			<Overload retVal="" descr="Exception for truncated headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TruncatedHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TruncatedHeaderError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.XGLTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.XHDTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.bltn_open" func="yes">
			<Overload retVal="" descr="open(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file using the file() type, returns a file object.  This is the&#10;preferred way to open a file.  See file.__doc__ for further information.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.calc_chksums" func="yes">
			<Overload retVal="" descr="Calculate the checksum for a member's header by summing up all&#10;characters except for the chksum field which is treated as if&#10;it was filled with spaces. According to the GNU tar sources,&#10;some tars (Sun and NeXT) calculate chksum with signed char,&#10;which will be different if there are chars in the buffer with&#10;the high bit set. So we calculate two checksums, unsigned and&#10;signed.">
				<Param name="buf" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.copyfileobj" func="yes">
			<Overload retVal="" descr="Copy length bytes from fileobj src to fileobj dst.&#10;If length is None, copy the entire content.">
				<Param name="src" />
				<Param name="dst" />
				<Param name="[length=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.filemode" func="yes">
			<Overload retVal="" descr="Convert a file's mode to a string of the form&#10;-rwxrwxrwx.&#10;Used by TarFile.list()">
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.filemode_table" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.is_tarfile" func="yes">
			<Overload retVal="" descr="Return True if name points to a tar archive that we&#10;are able to handle, else return False.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.itn" func="yes">
			<Overload retVal="" descr="Convert a python number to a number field.">
				<Param name="n" />
				<Param name="[digits=8" />
				<Param name="[format=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.nti" func="yes">
			<Overload retVal="" descr="Convert a number field to a python number.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.nts" func="yes">
			<Overload retVal="" descr="Convert a null-terminated string field to a python string.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.open" func="yes">
			<Overload retVal="" descr="Open a tar archive for reading, writing or appending. Return&#10;an appropriate TarFile class.&#10;&#10;mode:&#10;'r' or 'r:*' open for reading with transparent compression&#10;'r:'         open for reading exclusively uncompressed&#10;'r:gz'       open for reading with gzip compression&#10;'r:bz2'      open for reading with bzip2 compression&#10;'a' or 'a:'  open for appending, creating the file if necessary&#10;'w' or 'w:'  open for writing without compression&#10;'w:gz'       open for writing with gzip compression&#10;'w:bz2'      open for writing with bzip2 compression&#10;&#10;'r|*'        open a stream of tar blocks with transparent compression&#10;'r|'         open an uncompressed stream of tar blocks for reading&#10;'r|gz'       open a gzip compressed stream of tar blocks&#10;'r|bz2'      open a bzip2 compressed stream of tar blocks&#10;'w|'         open an uncompressed stream for writing&#10;'w|gz'       open a gzip compressed stream for writing&#10;'w|bz2'      open a bzip2 compressed stream for writing">
				<Param name="cls" />
				<Param name="[name=None" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[bufsize=10240" />
				<Param name="[**]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.stn" func="yes">
			<Overload retVal="" descr="Convert a python string to a null-terminated string buffer.">
				<Param name="s" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.uts" func="yes">
			<Overload retVal="" descr="Convert a unicode object to a string.">
				<Param name="s" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="taropen" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="tb_lineno" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="tclobjs_to_py" func="yes">
			<Overload retVal="" descr="Function of ttk">
			</Overload>
		</KeyWord>
		<KeyWord name="tearDown" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="tearDownClass" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="tee" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib" func="yes">
			<Overload retVal="" descr="TELNET client class.&#10;&#10;Based on RFC 854: TELNET Protocol Specification, by J. Postel and&#10;J. Reynolds&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; from telnetlib import Telnet&#10;&gt;&gt;&gt; tn = Telnet('www.python.org', 79)   # connect to finger port&#10;&gt;&gt;&gt; tn.write('guido\r\n')&#10;&gt;&gt;&gt; print tn.read_all()&#10;Login       Name               TTY         Idle    When    Where&#10;guido    Guido van Rossum      pts/2        &lt;Dec  2 11:10&gt; snag.cnri.reston..&#10;&#10;&gt;&gt;&gt;&#10;&#10;Note that read_all() won't read until eof -- it just reads some data&#10;-- but it guarantees to read at least one byte unless EOF is hit.&#10;&#10;It is possible to pass a Telnet object to select.select() in order to&#10;wait until more data is available.  Note that in this case,&#10;read_eager() may return '' even if there was data on the socket,&#10;because the protocol negotiation may have eaten the data.  This is why&#10;EOFError is needed in some cases to distinguish between &quot;no data&quot; and&#10;&quot;connection closed&quot; (since the socket also appears ready for reading&#10;when it is closed).&#10;&#10;To do:&#10;- option negotiation&#10;- timeout should be intrinsic to the connection object instead of an&#10;  option on one of the read calls only">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.AO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.AUTHENTICATION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.AYT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.BINARY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.BM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.BRK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.CHARSET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.COM_PORT_OPTION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DET" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DONT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.ECHO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.ENCRYPT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EXOPL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.FORWARD_X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.GA" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.IAC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.IP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.KERMIT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.LFLOW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.LINEMODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.LOGOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAMS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOCRD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOFFD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOHTD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOHTS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOLFD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOVTD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOVTS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAWS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NEW_ENVIRON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NOOPT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.OLD_ENVIRON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.OUTMRK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.PRAGMA_HEARTBEAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.PRAGMA_LOGON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.RCP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.RCTE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.RSP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SB" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SEND_URL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SGA" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SNDLOC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SSPI_LOGON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.STATUS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SUPDUP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SUPDUPOUTPUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SUPPRESS_LOCAL_ECHO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TELNET_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TLS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TN3270E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TSPEED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TTYLOC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TTYPE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TUID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.VT3270REGIME" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.WILL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.WONT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.X3PAD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.XASCII" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.XAUTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.XDISPLOC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.test" func="yes">
			<Overload retVal="" descr="Test program for telnetlib.&#10;&#10;Usage: python telnetlib.py [-d] ... [host [port]]&#10;&#10;Default host is localhost; default port is 23.">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.theNULL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile" func="yes">
			<Overload retVal="" descr="Temporary files.&#10;&#10;This module provides generic, low- and high-level interfaces for&#10;creating temporary files and directories.  All of the interfaces&#10;provided by this module can be used without fear of race conditions&#10;except for 'mktemp'.  'mktemp' is subject to race conditions and&#10;should not be used; it is provided for backward compatibility only.&#10;&#10;This module also provides some data items to the user:&#10;&#10;  TMP_MAX  - maximum number of names that will be tried before&#10;             giving up.&#10;  template - the default prefix for all temporary names.&#10;             You may change this to control the default prefix.&#10;  tempdir  - If this is set to a string before the first use of&#10;             any routine from this module, it will be considered as&#10;             another candidate location to store temporary files.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.NamedTemporaryFile" func="yes">
			<Overload retVal="" descr="Create and return a temporary file.&#10;Arguments:&#10;'prefix', 'suffix', 'dir' -- as for mkstemp.&#10;'mode' -- the mode argument to os.fdopen (default &quot;w+b&quot;).&#10;'bufsize' -- the buffer size argument to os.fdopen (default -1).&#10;'delete' -- whether the file is deleted on close (default True).&#10;The file is created as mkstemp() would do it.&#10;&#10;Returns an object with a file-like interface; the name of the file&#10;is accessible as file.name.  The file will be automatically deleted&#10;when it is closed unless the 'delete' argument is set to False.">
				<Param name="[mode=w+b" />
				<Param name="[bufsize=-1" />
				<Param name="[suffix" />
				<Param name="[prefix=tmp" />
				<Param name="[dir=None" />
				<Param name="[delete=True]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.TMP_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.TemporaryFile" func="yes">
			<Overload retVal="" descr="Create and return a temporary file.&#10;Arguments:&#10;'prefix', 'suffix', 'dir' -- as for mkstemp.&#10;'mode' -- the mode argument to os.fdopen (default &quot;w+b&quot;).&#10;'bufsize' -- the buffer size argument to os.fdopen (default -1).&#10;'delete' -- whether the file is deleted on close (default True).&#10;The file is created as mkstemp() would do it.&#10;&#10;Returns an object with a file-like interface; the name of the file&#10;is accessible as file.name.  The file will be automatically deleted&#10;when it is closed unless the 'delete' argument is set to False.">
				<Param name="[mode=w+b" />
				<Param name="[bufsize=-1" />
				<Param name="[suffix" />
				<Param name="[prefix=tmp" />
				<Param name="[dir=None" />
				<Param name="[delete=True]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.gettempdir" func="yes">
			<Overload retVal="" descr="Accessor for tempfile.tempdir.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.gettempprefix" func="yes">
			<Overload retVal="" descr="Accessor for tempdir.template.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.mkdtemp" func="yes">
			<Overload retVal="" descr="User-callable function to create and return a unique temporary&#10;directory.  The return value is the pathname of the directory.&#10;&#10;Arguments are as for mkstemp, except that the 'text' argument is&#10;not accepted.&#10;&#10;The directory is readable, writable, and searchable only by the&#10;creating user.&#10;&#10;Caller is responsible for deleting the directory when done with it.">
				<Param name="[suffix" />
				<Param name="[prefix=tmp" />
				<Param name="[dir=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.mkstemp" func="yes">
			<Overload retVal="" descr="User-callable function to create and return a unique temporary&#10;file.  The return value is a pair (fd, name) where fd is the&#10;file descriptor returned by os.open, and name is the filename.&#10;&#10;If 'suffix' is specified, the file name will end with that suffix,&#10;otherwise there will be no suffix.&#10;&#10;If 'prefix' is specified, the file name will begin with that prefix,&#10;otherwise a default prefix is used.&#10;&#10;If 'dir' is specified, the file will be created in that directory,&#10;otherwise a default directory is used.&#10;&#10;If 'text' is specified and true, the file is opened in text&#10;mode.  Else (the default) the file is opened in binary mode.  On&#10;some operating systems, this makes no difference.&#10;&#10;The file is readable and writable only by the creating user ID.&#10;If the operating system uses permission bits to indicate whether a&#10;file is executable, the file is executable by no one. The file&#10;descriptor is not inherited by children of this process.&#10;&#10;Caller is responsible for deleting the file when done with it.">
				<Param name="[suffix" />
				<Param name="[prefix=tmp" />
				<Param name="[dir=None" />
				<Param name="[text=False]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.mktemp" func="yes">
			<Overload retVal="" descr="User-callable function to return a unique temporary file name.  The&#10;file is not created.&#10;&#10;Arguments are as for mkstemp, except that the 'text' argument is&#10;not accepted.&#10;&#10;This function is unsafe and should not be used.  The file name&#10;refers to a file that did not exist at some point, but by the time&#10;you get around to creating it, someone else may have beaten you to&#10;the punch.">
				<Param name="[suffix" />
				<Param name="[prefix=tmp" />
				<Param name="[dir=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.template" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfilepager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="template" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="tempnam" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="terminate" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="test" />
		<KeyWord name="test1" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="test_8svx" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_aifc" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_au" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_bmp" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_exif" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_gif" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_hcom" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_jpeg" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_pbm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_pgm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_png" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_ppm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_rast" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_rgb" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_skip" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="test_sndr" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_sndt" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_tiff" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_voc" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_wav" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_xbm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="testall" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="testfile" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="testmod" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="testsource" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="testzip" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="text" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="textdomain" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap" func="yes">
			<Overload retVal="" descr="Text wrapping and filling.">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.dedent" func="yes">
			<Overload retVal="" descr='Remove any common leading whitespace from every line in `text`.&#10;&#10;This can be used to make triple-quoted strings line up with the left&#10;edge of the display, while still presenting them in the source code&#10;in indented form.&#10;&#10;Note that tabs and spaces are both treated as whitespace, but they&#10;are not equal: the lines "  hello" and "\thello" are&#10;considered to have no common leading whitespace.  (This behaviour is&#10;new in Python 2.5; older versions of this module incorrectly&#10;expanded tabs before searching for common leading whitespace.)'>
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.fill" func="yes">
			<Overload retVal="" descr="Fill a single paragraph of text, returning a new string.&#10;&#10;Reformat the single paragraph in 'text' to fit in lines of no more&#10;than 'width' columns, and return a new string containing the entire&#10;wrapped paragraph.  As with wrap(), tabs are expanded and other&#10;whitespace characters converted to space.  See TextWrapper class for&#10;available keyword args to customize wrapping behaviour.">
				<Param name="text" />
				<Param name="[width=70" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.wrap" func="yes">
			<Overload retVal="" descr="Wrap a single paragraph of text, returning a list of wrapped lines.&#10;&#10;Reformat the single paragraph in 'text' so it fits in lines of no&#10;more than 'width' columns, and return a list of wrapped lines.  By&#10;default, tabs in 'text' are expanded with string.expandtabs(), and&#10;all other whitespace characters (including newline) are converted to&#10;space.  See TextWrapper class for available keyword args to customize&#10;wrapping behaviour.">
				<Param name="text" />
				<Param name="[width=70" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="theme_create" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="theme_names" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="theme_settings" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="theme_use" func="yes">
			<Overload retVal="" descr="Function of ttk.Style">
			</Overload>
		</KeyWord>
		<KeyWord name="this" />
		<KeyWord name="this.c" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="this.d" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="this.i" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="this.s" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="thishost" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="threading" func="yes">
			<Overload retVal="" descr="Thread module emulating a subset of Java's threading model.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="A factory function that returns a new bounded semaphore.&#10;&#10;A bounded semaphore checks to make sure its current value doesn't exceed its&#10;initial value. If it does, ValueError is raised. In most situations&#10;semaphores are used to guard resources with limited capacity.&#10;&#10;If the semaphore is released too many times it's a sign of a bug. If not&#10;given, value defaults to 1.&#10;&#10;Like regular semaphores, bounded semaphores manage a counter representing&#10;the number of release() calls minus the number of acquire() calls, plus an&#10;initial value. The acquire() method blocks if necessary until it can return&#10;without making the counter negative. If not given, value defaults to 1.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition" func="yes">
			<Overload retVal="" descr="Factory function that returns a new condition variable object.&#10;&#10;A condition variable allows one or more threads to wait until they are&#10;notified by another thread.&#10;&#10;If the lock argument is given and not None, it must be a Lock or RLock&#10;object, and it is used as the underlying lock. Otherwise, a new RLock object&#10;is created and used as the underlying lock.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event" func="yes">
			<Overload retVal="" descr="A factory function that returns a new event.&#10;&#10;Events manage a flag that can be set to true with the set() method and reset&#10;to false with the clear() method. The wait() method blocks until the flag is&#10;true.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Lock" func="yes">
			<Overload retVal="" descr="allocate_lock() -&gt; lock object&#10;(allocate() is an obsolete synonym)&#10;&#10;Create a new lock object.  See help(LockType) for information about locks.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.RLock" func="yes">
			<Overload retVal="" descr="Factory function that returns a new reentrant lock.&#10;&#10;A reentrant lock must be released by the thread that acquired it. Once a&#10;thread has acquired a reentrant lock, the same thread may acquire it again&#10;without blocking; the thread must release it once for each time it has&#10;acquired it.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Semaphore" func="yes">
			<Overload retVal="" descr="A factory function that returns a new semaphore.&#10;&#10;Semaphores manage a counter representing the number of release() calls minus&#10;the number of acquire() calls, plus an initial value. The acquire() method&#10;blocks if necessary until it can return without making the counter&#10;negative. If not given, value defaults to 1.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread" func="yes">
			<Overload retVal="" descr="A class that represents a thread of control.&#10;&#10;This class can be safely subclassed in a limited fashion.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.getName" />
		<KeyWord name="threading.Thread.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.isAlive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.isDaemon" />
		<KeyWord name="threading.Thread.is_alive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.join" func="yes">
			<Overload retVal="" descr="Wait until the thread terminates.&#10;&#10;This blocks the calling thread until the thread whose join() method is&#10;called terminates -- either normally or through an unhandled exception&#10;or until the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof). As join() always returns None, you must call&#10;isAlive() after join() to decide whether a timeout happened -- if the&#10;thread is still alive, the join() call timed out.&#10;&#10;When the timeout argument is not present or None, the operation will&#10;block until the thread terminates.&#10;&#10;A thread can be join()ed many times.&#10;&#10;join() raises a RuntimeError if an attempt is made to join the current&#10;thread as that would cause a deadlock. It is also an error to join() a&#10;thread before it has been started and attempts to do so raises the same&#10;exception.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.run" func="yes">
			<Overload retVal="" descr="Method representing the thread's activity.&#10;&#10;You may override this method in a subclass. The standard run() method&#10;invokes the callable object passed to the object's constructor as the&#10;target argument, if any, with sequential and keyword arguments taken&#10;from the args and kwargs arguments, respectively.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.setDaemon" />
		<KeyWord name="threading.Thread.setName" />
		<KeyWord name="threading.Thread.start" func="yes">
			<Overload retVal="" descr="Start the thread's activity.&#10;&#10;It must be called at most once per thread object. It arranges for the&#10;object's run() method to be invoked in a separate thread of control.&#10;&#10;This method will raise a RuntimeError if called more than once on the&#10;same thread object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.ThreadError" />
		<KeyWord name="threading.ThreadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.ThreadError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer" func="yes">
			<Overload retVal="" descr="Factory function to create a Timer object.&#10;&#10;Timers call a function after a specified number of seconds:&#10;&#10;    t = Timer(30.0, f, args=[], kwargs={})&#10;    t.start()&#10;    t.cancel()     # stop the timer's action if it's still waiting">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.activeCount" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.active_count" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.currentThread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.current_thread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.enumerate" func="yes">
			<Overload retVal="" descr="Return a list of all Thread objects currently alive.&#10;&#10;The list includes daemonic threads, dummy thread objects created by&#10;current_thread(), and the main thread. It excludes terminated threads and&#10;threads that have not yet been started.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.local" func="yes">
			<Overload retVal="" descr="Thread-local data">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.setprofile" func="yes">
			<Overload retVal="" descr="Set a profile function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.setprofile() for each thread, before its&#10;run() method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.settrace" func="yes">
			<Overload retVal="" descr="Set a trace function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.settrace() for each thread, before its run()&#10;method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.stack_size" func="yes">
			<Overload retVal="" descr="stack_size([size]) -&gt; size&#10;&#10;Return the thread stack size used when creating new threads.  The&#10;optional size argument specifies the stack size (in bytes) to be used&#10;for subsequently created threads, and must be 0 (use platform or&#10;configured default) or a positive integer value of at least 32,768 (32k).&#10;If changing the thread stack size is unsupported, a ThreadError&#10;exception is raised.  If the specified size is invalid, a ValueError&#10;exception is raised, and the stack size is unmodified.  32k bytes&#10; currently the minimum supported stack size value to guarantee&#10;sufficient stack space for the interpreter itself.&#10;&#10;Note that some platforms may have particular restrictions on values for&#10;the stack size, such as requiring a minimum stack size larger than 32kB or&#10;requiring allocation in multiples of the system memory page size&#10;- platform documentation should be referred to for more information&#10;(4kB pages are common; using multiples of 4096 for the stack size is&#10;the suggested approach in the absence of more specific information).">
			</Overload>
		</KeyWord>
		<KeyWord name="throw" func="yes">
			<Overload retVal="" descr="Function of xmlrpclib.GeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="tilt" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="tiltangle" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="time" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="time2isoz" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="time2netscape" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="timegm" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit" func="yes">
			<Overload retVal="" descr="Tool for measuring execution time of small code snippets.&#10;&#10;This module avoids a number of common traps for measuring execution&#10;times.  See also Tim Peters' introduction to the Algorithms chapter in&#10;the Python Cookbook, published by O'Reilly.&#10;&#10;Library usage: see the Timer class.&#10;&#10;Command line usage:&#10;    python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-h] [--] [statement]&#10;&#10;Options:&#10;  -n/--number N: how many times to execute 'statement' (default: see below)&#10;  -r/--repeat N: how many times to repeat the timer (default 3)&#10;  -s/--setup S: statement to be executed once initially (default 'pass')&#10;  -t/--time: use time.time() (default on Unix)&#10;  -c/--clock: use time.clock() (default on Windows)&#10;  -v/--verbose: print raw timing results; repeat for more digits precision&#10;  -h/--help: print this usage message and exit&#10;  --: separate options from statement, use when statement starts with -&#10;  statement: statement to be timed (default 'pass')&#10;&#10;A multi-line statement may be given by specifying each line as a&#10;separate argument; indented lines are possible by enclosing an&#10;argument in quotes and using leading spaces.  Multiple -s options are&#10;treated similarly.&#10;&#10;If -n is not given, a suitable number of loops is calculated by trying&#10;successive powers of 10 until the total time is at least 0.2 seconds.&#10;&#10;The difference in default timer function is because on Windows,&#10;clock() has microsecond granularity but time()'s granularity is 1/60th&#10;of a second; on Unix, clock() has 1/100th of a second granularity and&#10;time() is much more precise.  On either platform, the default timer&#10;functions measure wall clock time, not the CPU time.  This means that&#10;other processes running on the same computer may interfere with the&#10;timing.  The best thing to do when accurate timing is necessary is to&#10;repeat the timing a few times and use the best time.  The -r option is&#10;good for this; the default of 3 repetitions is probably enough in most&#10;cases.  On Unix, you can use clock() to measure CPU time.&#10;&#10;Note: there is a certain baseline overhead associated with executing a&#10;pass statement.  The code here doesn't try to hide it, but you should&#10;be aware of it.  The baseline overhead can be measured by invoking the&#10;program without arguments.&#10;&#10;The baseline overhead differs between Python versions!  Also, to&#10;fairly compare older Python versions to Python 2.3, you may want to&#10;use python -O for the older versions to avoid timing SET_LINENO&#10;instructions.">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.Timer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.default_number" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.default_repeat" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.default_timer" func="yes">
			<Overload retVal="" descr="clock() -&gt; floating point number&#10;&#10;Return the CPU time or real time since the start of the process or since&#10;the first call to clock().  This has as much precision as the system&#10;records.">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.dummy_src_name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.main" func="yes">
			<Overload retVal="" descr="Main program, used when run as a script.&#10;&#10;The optional 'args' argument specifies the command line to be parsed,&#10;defaulting to sys.argv[1:].&#10;&#10;The return value is an exit code to be passed to sys.exit(); it&#10;may be None to indicate success.&#10;&#10;When an exception happens during timing, a traceback is printed to&#10;stderr and the return value is 1.  Exceptions at other times&#10;(including the template compilation) are not caught.&#10;&#10;'_wrap_timer' is an internal interface used for unit testing.  If it&#10;is not None, it must be a callable that accepts a timer function&#10;and returns another timer function (used for unit testing).">
				<Param name="[args=None" />
				<Param name="[_wrap_timer=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.reindent" func="yes">
			<Overload retVal="" descr="Helper to reindent a multi-line statement.">
				<Param name="src" />
				<Param name="indent" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.repeat" func="yes">
			<Overload retVal="" descr="Convenience function to create Timer object and call repeat method.">
				<Param name="[stmt=pass" />
				<Param name="[setup=pass" />
				<Param name="[timer=<built-in function clock>" />
				<Param name="[repeat=3" />
				<Param name="[number=1000000]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.template" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.timeit" func="yes">
			<Overload retVal="" descr="Convenience function to create Timer object and call timeit method.">
				<Param name="[stmt=pass" />
				<Param name="[setup=pass" />
				<Param name="[timer=<built-in function clock>" />
				<Param name="[number=1000000]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="times" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="timetuple" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="timetz" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkColorChooser" />
		<KeyWord name="tkColorChooser.Chooser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkColorChooser.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkColorChooser.askcolor" func="yes">
			<Overload retVal="" descr="Ask for a color">
				<Param name="[color=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog" />
		<KeyWord name="tkCommonDialog.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.AtEnd" />
		<KeyWord name="tkCommonDialog.AtInsert" />
		<KeyWord name="tkCommonDialog.AtSelFirst" />
		<KeyWord name="tkCommonDialog.AtSelLast" />
		<KeyWord name="tkCommonDialog.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.BuiltinFunctionType" />
		<KeyWord name="tkCommonDialog.BuiltinMethodType" />
		<KeyWord name="tkCommonDialog.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType" />
		<KeyWord name="tkCommonDialog.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.EllipsisType" />
		<KeyWord name="tkCommonDialog.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType" />
		<KeyWord name="tkCommonDialog.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType" />
		<KeyWord name="tkCommonDialog.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.GetSetDescriptorType" />
		<KeyWord name="tkCommonDialog.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MemberDescriptorType" />
		<KeyWord name="tkCommonDialog.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.NoneType" />
		<KeyWord name="tkCommonDialog.NotImplementedType" />
		<KeyWord name="tkCommonDialog.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TclError" />
		<KeyWord name="tkCommonDialog.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TracebackType" />
		<KeyWord name="tkCommonDialog.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.image_names" />
		<KeyWord name="tkCommonDialog.image_types" />
		<KeyWord name="tkCommonDialog.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkCommonDialog.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog" />
		<KeyWord name="tkFileDialog.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.Directory" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.Open" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.SaveAs" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.askdirectory" func="yes">
			<Overload retVal="" descr="Ask for a directory, and return the file name">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.askopenfile" func="yes">
			<Overload retVal="" descr="Ask for a filename to open, and returned the opened file">
				<Param name="[mode=r" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.askopenfilename" func="yes">
			<Overload retVal="" descr="Ask for a filename to open">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.askopenfilenames" func="yes">
			<Overload retVal="" descr="Ask for multiple filenames to open&#10;&#10;Returns a list of filenames or empty list if&#10;cancel button selected">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.askopenfiles" func="yes">
			<Overload retVal="" descr="Ask for multiple filenames and return the open file&#10;objects&#10;&#10;returns a list of open file objects or an empty list if&#10;cancel selected">
				<Param name="[mode=r" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.asksaveasfile" func="yes">
			<Overload retVal="" descr="Ask for a filename to save as, and returned the opened file">
				<Param name="[mode=w" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFileDialog.asksaveasfilename" func="yes">
			<Overload retVal="" descr="Ask for a filename to save as">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont" />
		<KeyWord name="tkFont.BOLD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.Font" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.ITALIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.ROMAN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.families" func="yes">
			<Overload retVal="" descr="Get font families (as a tuple)">
				<Param name="[root=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.names" func="yes">
			<Overload retVal="" descr="Get names of defined fonts (as a tuple)">
				<Param name="[root=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkFont.nametofont" func="yes">
			<Overload retVal="" descr="Given the name of a tk named font, returns a Font representation.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox" />
		<KeyWord name="tkMessageBox.ABORT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.ABORTRETRYIGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.CANCEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.ERROR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.IGNORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.NO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.OK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.OKCANCEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.QUESTION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.RETRY" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.RETRYCANCEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.WARNING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.YES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.YESNO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.YESNOCANCEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.askokcancel" func="yes">
			<Overload retVal="" descr="Ask if operation should proceed; return true if the answer is ok">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.askquestion" func="yes">
			<Overload retVal="" descr="Ask a question">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.askretrycancel" func="yes">
			<Overload retVal="" descr="Ask if operation should be retried; return true if the answer is yes">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.askyesno" func="yes">
			<Overload retVal="" descr="Ask a question; return true if the answer is yes">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.askyesnocancel" func="yes">
			<Overload retVal="" descr="Ask a question; return true if the answer is yes, None if cancelled.">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.showerror" func="yes">
			<Overload retVal="" descr="Show an error message">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.showinfo" func="yes">
			<Overload retVal="" descr="Show an info message">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkMessageBox.showwarning" func="yes">
			<Overload retVal="" descr="Show a warning message">
				<Param name="[title=None" />
				<Param name="[message=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog" func="yes">
			<Overload retVal="" descr="Dialog boxes&#10;&#10;This module handles dialog boxes. It contains the following&#10;public symbols:&#10;&#10;Dialog -- a base class for dialogs&#10;&#10;askinteger -- get an integer from the user&#10;&#10;askfloat -- get a float from the user&#10;&#10;askstring -- get a string from the user">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ACTIVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ALL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ANCHOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ARC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.At" func="yes">
			<Overload retVal="" descr=>
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.AtEnd" />
		<KeyWord name="tkSimpleDialog.AtInsert" />
		<KeyWord name="tkSimpleDialog.AtSelFirst" />
		<KeyWord name="tkSimpleDialog.AtSelLast" />
		<KeyWord name="tkSimpleDialog.BASELINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BEVEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BOTH" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BOTTOM" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BROWSE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BUTT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BaseWidget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BitmapImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BooleanVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.BuiltinFunctionType" />
		<KeyWord name="tkSimpleDialog.BuiltinMethodType" />
		<KeyWord name="tkSimpleDialog.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CASCADE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CENTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CHAR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CHECKBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CHORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.COMMAND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CURRENT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CallWrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DISABLED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DOTBOX" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Dialog" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType" />
		<KeyWord name="tkSimpleDialog.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.DoubleVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.E" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.END" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.EW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.EXCEPTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.EXTENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.EllipsisType" />
		<KeyWord name="tkSimpleDialog.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Event" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FLAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType" />
		<KeyWord name="tkSimpleDialog.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GROOVE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType" />
		<KeyWord name="tkSimpleDialog.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.GetSetDescriptorType" />
		<KeyWord name="tkSimpleDialog.Grid" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.HIDDEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.HORIZONTAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.INSERT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.INSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Image" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.IntVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LEFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Listbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MITER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MOVETO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MULTIPLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MemberDescriptorType" />
		<KeyWord name="tkSimpleDialog.Menu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Message" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Misc" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.N" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NONE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NORMAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NSEW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NUMERIC" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NoDefaultRoot" func="yes">
			<Overload retVal="" descr="Inhibit setting of default root window.&#10;&#10;Call this function to inhibit that the first instance of&#10;Tk is used for windows without an explicit parent window.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.NoneType" />
		<KeyWord name="tkSimpleDialog.NotImplementedType" />
		<KeyWord name="tkSimpleDialog.ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.OUTSIDE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.PAGES" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.PIESLICE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.PROJECTING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Pack" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.PhotoImage" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Place" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.RADIOBUTTON" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.RAISED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.READABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.RIDGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.RIGHT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.ROUND" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SCROLL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SEL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SEL_FIRST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SEL_LAST" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SEPARATOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SINGLE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SOLID" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SUNKEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SW" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Spinbox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.StringVar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Studbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TOP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TRUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Tcl" func="yes">
			<Overload retVal="" descr=>
				<Param name="[screenName=None" />
				<Param name="[baseName=None" />
				<Param name="[className=Tk" />
				<Param name="[useTk=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TclError" />
		<KeyWord name="tkSimpleDialog.TclError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TclError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TclVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Text" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Tk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TkVersion" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Toplevel" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TracebackType" />
		<KeyWord name="tkSimpleDialog.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Tributton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UNDERLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UNITS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.VERTICAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Variable" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.W" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.WORD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.WRITABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Wm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.X" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.XView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.Y" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.YES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.YView" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.askfloat" func="yes">
			<Overload retVal="" descr="get a float from the user&#10;&#10;Arguments:&#10;&#10;    title -- the dialog title&#10;    prompt -- the label text&#10;    **kw -- see SimpleDialog class&#10;&#10;Return value is a float">
				<Param name="title" />
				<Param name="prompt" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.askinteger" func="yes">
			<Overload retVal="" descr="get an integer from the user&#10;&#10;Arguments:&#10;&#10;    title -- the dialog title&#10;    prompt -- the label text&#10;    **kw -- see SimpleDialog class&#10;&#10;Return value is an integer">
				<Param name="title" />
				<Param name="prompt" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.askstring" func="yes">
			<Overload retVal="" descr="get a string from the user&#10;&#10;Arguments:&#10;&#10;    title -- the dialog title&#10;    prompt -- the label text&#10;    **kw -- see SimpleDialog class&#10;&#10;Return value is a string">
				<Param name="title" />
				<Param name="prompt" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getboolean" func="yes">
			<Overload retVal="" descr="Convert true and false to integer values 1 and 0.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getdouble.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.getint.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.image_names" />
		<KeyWord name="tkSimpleDialog.image_types" />
		<KeyWord name="tkSimpleDialog.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tkSimpleDialog.wantobjects" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_bisque" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_focusFollowsMouse" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_focusNext" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_focusPrev" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_menuBar" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_setPalette" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tk_strictMotif" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tkraise" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="tmpfile" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="tmpnam" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="toBytes" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="to_eng_string" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="to_integral" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_integral_exact" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_integral_value" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_sci_string" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="toaiff" func="yes">
			<Overload retVal="" descr="Convert &quot;arbitrary&quot; sound files to AIFF (Apple and SGI's audio format).&#10;&#10;Input may be compressed.&#10;Uncompressed file type may be AIFF, WAV, VOC, 8SVX, NeXT/Sun, and others.&#10;An exception is raised if the file is not of a recognized type.&#10;Returned filename is either the input filename or a temporary filename;&#10;in the latter case the caller must ensure that it is removed.&#10;Other temporary files used are removed by the function.">
			</Overload>
		</KeyWord>
		<KeyWord name="toaiff.error" />
		<KeyWord name="toaiff.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="toaiff.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="toaiff.t" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="toaiff.table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="toaiff.toaiff" />
		<KeyWord name="toaiff.uncompress" func="yes">
			<Overload retVal="" descr="(instance)">
			</Overload>
		</KeyWord>
		<KeyWord name="tobuf" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="tobytes" />
		<KeyWord name="today" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="tofile" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="token" func="yes">
			<Overload retVal="" descr='Token constants (from "token.h").'>
			</Overload>
		</KeyWord>
		<KeyWord name="token.AMPER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.AMPEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.AT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.BACKQUOTE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.CIRCUMFLEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.CIRCUMFLEXEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.COLON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.COMMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESTAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESTAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.EQEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.EQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ERRORTOKEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.GREATER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.GREATEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.INDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ISEOF" />
		<KeyWord name="token.ISNONTERMINAL" />
		<KeyWord name="token.ISTERMINAL" />
		<KeyWord name="token.LBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LEFTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LEFTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LESS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LESSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.MINEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.MINUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NEWLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NOTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NT_OFFSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.N_TOKENS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.OP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PERCENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PERCENTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PLUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PLUSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RIGHTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RIGHTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.SEMI" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.SLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.SLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.STAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.STAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.STRING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.TILDE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.VBAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.VBAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.main" />
		<KeyWord name="token.tok_name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize" func="yes">
			<Overload retVal="" descr='Tokenization help for Python programs.&#10;&#10;generate_tokens(readline) is a generator that breaks a stream of&#10;text into Python tokens.  It accepts a readline-like method which is called&#10;repeatedly to get the next line of input (or "" for EOF).  It generates&#10;5-tuples with these members:&#10;&#10;    the token type (see token.py)&#10;    the token (a string)&#10;    the starting (row, column) indices of the token (a 2-tuple of ints)&#10;    the ending (row, column) indices of the token (a 2-tuple of ints)&#10;    the original line (string)&#10;&#10;It is designed to match the working of the Python tokenizer exactly, except&#10;that it produces COMMENT tokens for comments and gives type OP for all&#10;operators&#10;&#10;Older entry points&#10;    tokenize_loop(readline, tokeneater)&#10;    tokenize(readline, tokeneater=printtoken)&#10;are the same, except instead of generating tokens, tokeneater is a callback&#10;function to which the 5 fields described above are passed as 5 arguments,&#10;each time a new token is found.'>
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AMPER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AMPEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.BACKQUOTE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Binnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Bracket" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.CIRCUMFLEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.CIRCUMFLEXEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.COLON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.COMMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.COMMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Comment" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ContStr" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESTAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESTAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Decnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Double" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Double3" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.EQEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.EQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ERRORTOKEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Expfloat" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Exponent" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Floatnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Funny" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.GREATER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.GREATEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Hexnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.INDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ISEOF" />
		<KeyWord name="tokenize.ISNONTERMINAL" />
		<KeyWord name="tokenize.ISTERMINAL" />
		<KeyWord name="tokenize.Ignore" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Imagnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Intnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LEFTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LEFTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LESS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LESSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.MINEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.MINUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NEWLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NOTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NT_OFFSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.N_TOKENS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Number" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.OP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Octnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Operator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PERCENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PERCENTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PLUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PLUSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PlainToken" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Pointfloat" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PseudoExtras" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PseudoToken" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RIGHTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RIGHTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.SEMI" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.SLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.SLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.STAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.STAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.STRING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Single" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Single3" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Special" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.StopTokenizing" />
		<KeyWord name="tokenize.StopTokenizing.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.StopTokenizing.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.String" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TILDE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Token" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenError" />
		<KeyWord name="tokenize.TokenError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Triple" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Untokenizer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.VBAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.VBAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Whitespace" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.any" />
		<KeyWord name="tokenize.chain" func="yes">
			<Overload retVal="" descr="chain(*iterables) --&gt; chain object&#10;&#10;Return a chain object whose .next() method returns elements from the&#10;first iterable until it is exhausted, then elements from the next&#10;iterable, until all of the iterables are exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.chain.from_iterable" func="yes">
			<Overload retVal="" descr="chain.from_iterable(iterable) --&gt; chain object&#10;&#10;Alternate chain() contructor taking a single iterable argument&#10;that evaluates lazily.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.chain.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.double3prog" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.endprogs" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.generate_tokens" func="yes">
			<Overload retVal="" descr="The generate_tokens() generator requires one argument, readline, which&#10;must be a callable object which provides the same interface as the&#10;readline() method of built-in file objects. Each call to the function&#10;should return one line of input as a string.  Alternately, readline&#10;can be a callable function terminating with StopIteration:&#10;    readline = open(myfile).next    # Example of alternate readline&#10;&#10;The generator produces 5-tuples with these members: the token type; the&#10;token string; a 2-tuple (srow, scol) of ints specifying the row and&#10;column where the token begins in the source; a 2-tuple (erow, ecol) of&#10;ints specifying the row and column where the token ends in the source;&#10;and the line on which the token was found. The line passed is the&#10;logical line; continuation lines are included.">
				<Param name="readline" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.group" />
		<KeyWord name="tokenize.main" />
		<KeyWord name="tokenize.maybe" />
		<KeyWord name="tokenize.printtoken" />
		<KeyWord name="tokenize.pseudoprog" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.single3prog" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.single_quoted" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.t" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tabsize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tok_name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tokenize" func="yes">
			<Overload retVal="" descr="The tokenize() function accepts two parameters: one representing the&#10;input stream, and one providing an output mechanism for tokenize().&#10;&#10;The first parameter, readline, must be a callable object which provides&#10;the same interface as the readline() method of built-in file objects.&#10;Each call to the function should return one line of input as a string.&#10;&#10;The second parameter, tokeneater, must also be a callable object. It is&#10;called once for each token, with five arguments, corresponding to the&#10;tuples generated by generate_tokens().">
				<Param name="readline" />
				<Param name="[tokeneater=<function printtoken at 0x00000000028EC978>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tokenize_loop" />
		<KeyWord name="tokenize.tokenprog" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.triple_quoted" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.untokenize" func="yes">
			<Overload retVal="" descr="Transform tokens back into Python source code.&#10;&#10;Each element returned by the iterable must be a token sequence&#10;with at least two elements, a token number and token value.  If&#10;only two tokens are passed, the resulting output is poor.&#10;&#10;Round-trip invariant for full input:&#10;    Untokenized source will match input source exactly&#10;&#10;Round-trip invariant for limited intput:&#10;    # Output text will tokenize the back to the input&#10;    t1 = [tok[:2] for tok in generate_tokens(f.readline)]&#10;    newcode = untokenize(t1)&#10;    readline = iter(newcode.splitlines(1)).next&#10;    t2 = [tok[:2] for tok in generate_tokens(readline)]&#10;    assert t1 == t2">
				<Param name="iterable" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize_loop" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="tolist" />
		<KeyWord name="toordinal" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="tostring" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="total_ordering" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="tounicode" func="yes">
			<Overload retVal="" descr="Function of httplib.array">
			</Overload>
		</KeyWord>
		<KeyWord name="towards" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="trace" func="yes">
			<Overload retVal="" descr="program/module to trace Python program or function execution&#10;&#10;Sample use, command line:&#10;  trace.py -c -f counts --ignore-dir '$prefix' spam.py eggs&#10;  trace.py -t --ignore-dir '$prefix' spam.py eggs&#10;  trace.py --trackcalls spam.py eggs&#10;&#10;Sample use, programmatically&#10;  import sys&#10;&#10;  # create a Trace object, telling it what to ignore, and whether to&#10;  # do tracing or line-counting or both.&#10;  tracer = trace.Trace(ignoredirs=[sys.prefix, sys.exec_prefix,], trace=0,&#10;                    count=1)&#10;  # run the new command using the given tracer&#10;  tracer.run('main()')&#10;  # make a report, placing output in /tmp&#10;  r = tracer.results()&#10;  r.write_results(show_missing=True, coverdir=&quot;/tmp&quot;)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.CoverageResults" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Ignore" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.PRAGMA_NOCOVER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Trace" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.find_executable_linenos" func="yes">
			<Overload retVal="" descr="Return dict where keys are line numbers in the line number table.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.find_lines" func="yes">
			<Overload retVal="" descr="Return lineno dict for all code objects reachable from code.">
				<Param name="code" />
				<Param name="strs" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.find_lines_from_code" func="yes">
			<Overload retVal="" descr="Return dict where keys are lines in the line number table.">
				<Param name="code" />
				<Param name="strs" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.find_strings" func="yes">
			<Overload retVal="" descr="Return a dict of possible docstring positions.&#10;&#10;The dict maps line numbers to strings.  There is an entry for&#10;line that contains only a string or a part of a triple-quoted&#10;string.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.fullmodname" func="yes">
			<Overload retVal="" descr="Return a plausible module name for the path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.main" func="yes">
			<Overload retVal="" descr=>
				<Param name="[argv=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.modname" func="yes">
			<Overload retVal="" descr="Return a plausible module name for the patch.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.rx_blank" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.usage" />
		<KeyWord name="traceback" func="yes">
			<Overload retVal="" descr="Extract, format and print information about Python stack traces.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.extract_stack" func="yes">
			<Overload retVal="" descr="Extract the raw traceback from the current stack frame.&#10;&#10;The return value has the same format as for extract_tb().  The&#10;optional 'f' and 'limit' arguments have the same meaning as for&#10;print_stack().  Each item in the list is a quadruple (filename,&#10;line number, function name, text), and the entries are in order&#10;from oldest to newest stack frame.">
				<Param name="[f=None" />
				<Param name="[limit=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.extract_tb" func="yes">
			<Overload retVal="" descr="Return list of up to limit pre-processed entries from traceback.&#10;&#10;This is useful for alternate formatting of stack traces.  If&#10;'limit' is omitted or None, all entries are extracted.  A&#10;pre-processed stack trace entry is a quadruple (filename, line&#10;number, function name, text) representing the information that is&#10;usually printed for a stack trace.  The text is a string with&#10;leading and trailing whitespace stripped; if the source is not&#10;available it is None.">
				<Param name="tb" />
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_exc" func="yes">
			<Overload retVal="" descr="Like print_exc() but return a string.">
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_exception" func="yes">
			<Overload retVal="" descr="Format a stack trace and the exception information.&#10;&#10;The arguments have the same meaning as the corresponding arguments&#10;to print_exception().  The return value is a list of strings, each&#10;ending in a newline and some containing internal newlines.  When&#10;these lines are concatenated and printed, exactly the same text is&#10;printed as does print_exception().">
				<Param name="etype" />
				<Param name="value" />
				<Param name="tb" />
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_exception_only" func="yes">
			<Overload retVal="" descr="Format the exception part of a traceback.&#10;&#10;The arguments are the exception type and value such as given by&#10;sys.last_type and sys.last_value. The return value is a list of&#10;strings, each ending in a newline.&#10;&#10;Normally, the list contains a single string; however, for&#10;SyntaxError exceptions, it contains several lines that (when&#10;printed) display detailed information about where the syntax&#10;error occurred.&#10;&#10;The message indicating which exception occurred is always the last&#10;string in the list.">
				<Param name="etype" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_list" func="yes">
			<Overload retVal="" descr="Format a list of traceback entry tuples for printing.&#10;&#10;Given a list of tuples as returned by extract_tb() or&#10;extract_stack(), return a list of strings ready for printing.&#10;Each string in the resulting list corresponds to the item with the&#10;same index in the argument list.  Each string ends in a newline;&#10;the strings may contain internal newlines as well, for those items&#10;whose source text line is not None.">
				<Param name="extracted_list" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_stack" func="yes">
			<Overload retVal="" descr="Shorthand for 'format_list(extract_stack(f, limit))'.">
				<Param name="[f=None" />
				<Param name="[limit=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_tb" func="yes">
			<Overload retVal="" descr="A shorthand for 'format_list(extract_tb(tb, limit))'.">
				<Param name="tb" />
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_exc" func="yes">
			<Overload retVal="" descr="Shorthand for 'print_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)'.&#10;(In fact, it uses sys.exc_info() to retrieve the same information&#10;in a thread-safe way.)">
				<Param name="[limit=None" />
				<Param name="[file=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_exception" func="yes">
			<Overload retVal="" descr="Print exception up to 'limit' stack trace entries from 'tb' to 'file'.&#10;&#10;This differs from print_tb() in the following ways: (1) if&#10;traceback is not None, it prints a header &quot;Traceback (most recent&#10;call last):&quot;; (2) it prints the exception type and value after the&#10;stack trace; (3) if type is SyntaxError and value has the&#10;appropriate format, it prints the line where the syntax error&#10;occurred with a caret on the next line indicating the approximate&#10;position of the error.">
				<Param name="etype" />
				<Param name="value" />
				<Param name="tb" />
				<Param name="[limit=None" />
				<Param name="[file=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_last" func="yes">
			<Overload retVal="" descr="This is a shorthand for 'print_exception(sys.last_type,&#10;sys.last_value, sys.last_traceback, limit, file)'.">
				<Param name="[limit=None" />
				<Param name="[file=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_list" func="yes">
			<Overload retVal="" descr="Print the list of tuples as returned by extract_tb() or&#10;extract_stack() as a formatted stack trace to the given file.">
				<Param name="extracted_list" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_stack" func="yes">
			<Overload retVal="" descr="Print a stack trace from its invocation point.&#10;&#10;The optional 'f' argument can be used to specify an alternate&#10;stack frame at which to start. The optional 'limit' and 'file'&#10;arguments have the same meaning as for print_exception().">
				<Param name="[f=None" />
				<Param name="[limit=None" />
				<Param name="[file=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_tb" func="yes">
			<Overload retVal="" descr="Print up to 'limit' stack trace entries from the traceback 'tb'.&#10;&#10;If 'limit' is omitted or None, all entries are printed.  If 'file'&#10;is omitted or None, the output goes to sys.stderr; otherwise&#10;'file' should be an open file or file-like object with a write()&#10;method.">
				<Param name="tb" />
				<Param name="[limit=None" />
				<Param name="[file=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.tb_lineno" func="yes">
			<Overload retVal="" descr="Calculate correct line number of traceback given in tb.&#10;&#10;Obsolete in 2.3.">
				<Param name="tb" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracer" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="translation" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="triangular" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="trunc" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="try" />
		<KeyWord name="ttk" func="yes">
			<Overload retVal="" descr="Ttk wrapper.&#10;&#10;This module provides classes to allow using Tk themed widget set.&#10;&#10;Ttk is based on a revised and enhanced version of&#10;TIP #48 (http://tip.tcl.tk/48) specified style engine.&#10;&#10;Its basic idea is to separate, to the extent possible, the code&#10;implementing a widget's behavior from the code implementing its&#10;appearance. Widget class bindings are primarily responsible for&#10;maintaining the widget state and invoking callbacks, all aspects&#10;of the widgets appearance lies at Themes.">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Button" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Checkbutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Combobox" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Entry" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Frame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Label" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabelFrame" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale" func="yes">
			<Overload retVal="" descr="A Ttk Scale widget with a Ttk Label widget indicating its&#10;current value.&#10;&#10;The Ttk Scale can be accessed through instance.scale, and Ttk Label&#10;can be accessed through instance.label">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.after" func="yes">
			<Overload retVal="" descr="Call function once after given time.&#10;&#10;MS specifies the time in milliseconds. FUNC gives the&#10;function which shall be called. Additional parameters&#10;are given as parameters to the function call.  Return&#10;identifier to cancel scheduling with after_cancel.">
				<Param name="self" />
				<Param name="ms" />
				<Param name="[func=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.after_cancel" func="yes">
			<Overload retVal="" descr="Cancel scheduling of function identified with ID.&#10;&#10;Identifier returned by after or after_idle must be&#10;given as first parameter.">
				<Param name="self" />
				<Param name="id" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.after_idle" func="yes">
			<Overload retVal="" descr="Call FUNC once if the Tcl main loop has no event to&#10;process.&#10;&#10;Return an identifier to cancel the scheduling with&#10;after_cancel.">
				<Param name="self" />
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.bbox" func="yes">
			<Overload retVal="" descr="Return a tuple of integer coordinates for the bounding&#10;box of this widget controlled by the geometry manager grid.&#10;&#10;If COLUMN, ROW is given the bounding box applies from&#10;the cell with row and column 0 to the specified&#10;cell. If COL2 and ROW2 are given the bounding box&#10;starts at that cell.&#10;&#10;The returned integers specify the offset of the upper left&#10;corner in the master widget and the width and height.">
				<Param name="self" />
				<Param name="[column=None" />
				<Param name="[row=None" />
				<Param name="[col2=None" />
				<Param name="[row2=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.bell" func="yes">
			<Overload retVal="" descr="Ring a display's bell.">
				<Param name="self" />
				<Param name="[displayof=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.bind" func="yes">
			<Overload retVal="" descr='Bind to this widget at event SEQUENCE a call to function FUNC.&#10;&#10;SEQUENCE is a string of concatenated event&#10;patterns. An event pattern is of the form&#10;&lt;MODIFIER-MODIFIER-TYPE-DETAIL&gt; where MODIFIER is one&#10;of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,&#10;Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,&#10;B3, Alt, Button4, B4, Double, Button5, B5 Triple,&#10;Mod1, M1. TYPE is one of Activate, Enter, Map,&#10;ButtonPress, Button, Expose, Motion, ButtonRelease&#10;FocusIn, MouseWheel, Circulate, FocusOut, Property,&#10;Colormap, Gravity Reparent, Configure, KeyPress, Key,&#10;Unmap, Deactivate, KeyRelease Visibility, Destroy,&#10;Leave and DETAIL is the button number for ButtonPress,&#10;ButtonRelease and DETAIL is the Keysym for KeyPress and&#10;KeyRelease. Examples are&#10;&lt;Control-Button-1&gt; for pressing Control and mouse button 1 or&#10;&lt;Alt-A&gt; for pressing A and the Alt key (KeyPress can be omitted).&#10;An event pattern can also be a virtual event of the form&#10;&lt;&lt;AString&gt;&gt; where AString can be arbitrary. This&#10;event can be generated by event_generate.&#10;If events are concatenated they must appear shortly&#10;after each other.&#10;&#10;FUNC will be called if the event sequence occurs with an&#10;instance of Event as argument. If the return value of FUNC is&#10;"break" no further bound function is invoked.&#10;&#10;An additional boolean parameter ADD specifies whether FUNC will&#10;be called additionally to the other bound function or whether&#10;it will replace the previous function.&#10;&#10;Bind will return an identifier to allow deletion of the bound function with&#10;unbind without memory leak.&#10;&#10;If FUNC or SEQUENCE is omitted the bound function or list&#10;of bound events are returned.'>
				<Param name="self" />
				<Param name="[sequence=None" />
				<Param name="[func=None" />
				<Param name="[add=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.bind_all" func="yes">
			<Overload retVal="" descr="Bind to all widgets at an event SEQUENCE a call to function FUNC.&#10;An additional boolean parameter ADD specifies whether FUNC will&#10;be called additionally to the other bound function or whether&#10;it will replace the previous function. See bind for the return value.">
				<Param name="self" />
				<Param name="[sequence=None" />
				<Param name="[func=None" />
				<Param name="[add=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.bind_class" func="yes">
			<Overload retVal="" descr="Bind to widgets with bindtag CLASSNAME at event&#10;SEQUENCE a call of function FUNC. An additional&#10;boolean parameter ADD specifies whether FUNC will be&#10;called additionally to the other bound function or&#10;whether it will replace the previous function. See bind for&#10;the return value.">
				<Param name="self" />
				<Param name="className" />
				<Param name="[sequence=None" />
				<Param name="[func=None" />
				<Param name="[add=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.bindtags" func="yes">
			<Overload retVal="" descr="Set or get the list of bindtags for this widget.&#10;&#10;With no argument return the list of all bindtags associated with&#10;this widget. With a list of strings as argument the bindtags are&#10;set to this list. The bindtags determine in which order events are&#10;processed (see bind).">
				<Param name="self" />
				<Param name="[tagList=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.cget" func="yes">
			<Overload retVal="" descr="Return the resource value for a KEY given as string.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.check" />
		<KeyWord name="ttk.LabeledScale.clipboard_append" func="yes">
			<Overload retVal="" descr="Append STRING to the Tk clipboard.&#10;&#10;A widget specified at the optional displayof keyword&#10;argument specifies the target display. The clipboard&#10;can be retrieved with selection_get.">
				<Param name="self" />
				<Param name="string" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.clipboard_clear" func="yes">
			<Overload retVal="" descr="Clear the data in the Tk clipboard.&#10;&#10;A widget specified for the optional displayof keyword&#10;argument specifies the target display.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.clipboard_get" func="yes">
			<Overload retVal="" descr="Retrieve data from the clipboard on window's display.&#10;&#10;The window keyword defaults to the root window of the Tkinter&#10;application.&#10;&#10;The type keyword specifies the form in which the data is&#10;to be returned and should be an atom name such as STRING&#10;or FILE_NAME.  Type defaults to STRING, except on X11, where the default&#10;is to try UTF8_STRING and fall back to STRING.&#10;&#10;This command is equivalent to:&#10;&#10;selection_get(CLIPBOARD)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.colormodel" func="yes">
			<Overload retVal="" descr="Useless. Not implemented in Tk.">
				<Param name="self" />
				<Param name="[value=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.columnconfigure" func="yes">
			<Overload retVal="" descr="Configure column INDEX of a grid.&#10;&#10;Valid resources are minsize (minimum size of the column),&#10;weight (how much does additional space propagate to this column)&#10;and pad (how much space to let additionally).">
				<Param name="self" />
				<Param name="index" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.config" func="yes">
			<Overload retVal="" descr="Configure resources of a widget.&#10;&#10;The values for resources are specified as keyword&#10;arguments. To get an overview about&#10;the allowed keyword arguments call the method keys.">
				<Param name="self" />
				<Param name="[cnf=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.configure" func="yes">
			<Overload retVal="" descr="Configure resources of a widget.&#10;&#10;The values for resources are specified as keyword&#10;arguments. To get an overview about&#10;the allowed keyword arguments call the method keys.">
				<Param name="self" />
				<Param name="[cnf=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.deletecommand" func="yes">
			<Overload retVal="" descr="Internal function.&#10;&#10;Delete the Tcl command provided in NAME.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.destroy" func="yes">
			<Overload retVal="" descr="Destroy this widget and possibly its associated variable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.event_add" func="yes">
			<Overload retVal="" descr="Bind a virtual event VIRTUAL (of the form &lt;&lt;Name&gt;&gt;)&#10;to an event SEQUENCE such that the virtual event is triggered&#10;whenever SEQUENCE occurs.">
				<Param name="self" />
				<Param name="virtual" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.event_delete" func="yes">
			<Overload retVal="" descr="Unbind a virtual event VIRTUAL from SEQUENCE.">
				<Param name="self" />
				<Param name="virtual" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.event_generate" func="yes">
			<Overload retVal="" descr="Generate an event SEQUENCE. Additional&#10;keyword arguments specify parameter of the event&#10;(e.g. x, y, rootx, rooty).">
				<Param name="self" />
				<Param name="sequence" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.event_info" func="yes">
			<Overload retVal="" descr="Return a list of all virtual events or the information&#10;about the SEQUENCE bound to the virtual event VIRTUAL.">
				<Param name="self" />
				<Param name="[virtual=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.focus" func="yes">
			<Overload retVal="" descr="Direct input focus to this widget.&#10;&#10;If the application currently does not have the focus&#10;this widget will get the focus if the application gets&#10;the focus through the window manager.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.focus_displayof" func="yes">
			<Overload retVal="" descr="Return the widget which has currently the focus on the&#10;display where this widget is located.&#10;&#10;Return None if the application does not have the focus.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.focus_force" func="yes">
			<Overload retVal="" descr="Direct input focus to this widget even if the&#10;application does not have the focus. Use with&#10;caution!">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.focus_get" func="yes">
			<Overload retVal="" descr="Return the widget which has currently the focus in the&#10;application.&#10;&#10;Use focus_displayof to allow working with several&#10;displays. Return None if application does not have&#10;the focus.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.focus_lastfor" func="yes">
			<Overload retVal="" descr="Return the widget which would have the focus if top level&#10;for this widget gets the focus from the window manager.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.focus_set" func="yes">
			<Overload retVal="" descr="Direct input focus to this widget.&#10;&#10;If the application currently does not have the focus&#10;this widget will get the focus if the application gets&#10;the focus through the window manager.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.forget" func="yes">
			<Overload retVal="" descr="Unmap this widget and do not use it for the packing order.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.form" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.getboolean" func="yes">
			<Overload retVal="" descr="Return a boolean value for Tcl boolean values true and false given as parameter.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.getdouble" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.getint" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.getvar" func="yes">
			<Overload retVal="" descr="Return value of Tcl variable NAME.">
				<Param name="self" />
				<Param name="[name=PY_VAR]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grab_current" func="yes">
			<Overload retVal="" descr="Return widget which has currently the grab in this application&#10;or None.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grab_release" func="yes">
			<Overload retVal="" descr="Release grab for this widget if currently set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grab_set" func="yes">
			<Overload retVal="" descr="Set grab for this widget.&#10;&#10;A grab directs all events to this and descendant&#10;widgets in the application.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grab_set_global" func="yes">
			<Overload retVal="" descr="Set global grab for this widget.&#10;&#10;A global grab directs all events to this and&#10;descendant widgets on the display. Use with caution -&#10;other applications do not get events anymore.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grab_status" func="yes">
			<Overload retVal="" descr='Return None, "local" or "global" if this widget has&#10;no, a local or a global grab.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid" func="yes">
			<Overload retVal="" descr="Position a widget in the parent widget in a grid. Use as options:&#10;column=number - use cell identified with given column (starting with 0)&#10;columnspan=number - this widget will span several columns&#10;in=master - use master to contain this widget&#10;in_=master - see 'in' option description&#10;ipadx=amount - add internal padding in x direction&#10;ipady=amount - add internal padding in y direction&#10;padx=amount - add padding in x direction&#10;pady=amount - add padding in y direction&#10;row=number - use cell identified with given row (starting with 0)&#10;rowspan=number - this widget will span several rows&#10;sticky=NSEW - if cell is larger on which sides will this&#10;              widget stick to the cell boundary">
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_bbox" func="yes">
			<Overload retVal="" descr="Return a tuple of integer coordinates for the bounding&#10;box of this widget controlled by the geometry manager grid.&#10;&#10;If COLUMN, ROW is given the bounding box applies from&#10;the cell with row and column 0 to the specified&#10;cell. If COL2 and ROW2 are given the bounding box&#10;starts at that cell.&#10;&#10;The returned integers specify the offset of the upper left&#10;corner in the master widget and the width and height.">
				<Param name="self" />
				<Param name="[column=None" />
				<Param name="[row=None" />
				<Param name="[col2=None" />
				<Param name="[row2=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_columnconfigure" func="yes">
			<Overload retVal="" descr="Configure column INDEX of a grid.&#10;&#10;Valid resources are minsize (minimum size of the column),&#10;weight (how much does additional space propagate to this column)&#10;and pad (how much space to let additionally).">
				<Param name="self" />
				<Param name="index" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_configure" func="yes">
			<Overload retVal="" descr="Position a widget in the parent widget in a grid. Use as options:&#10;column=number - use cell identified with given column (starting with 0)&#10;columnspan=number - this widget will span several columns&#10;in=master - use master to contain this widget&#10;in_=master - see 'in' option description&#10;ipadx=amount - add internal padding in x direction&#10;ipady=amount - add internal padding in y direction&#10;padx=amount - add padding in x direction&#10;pady=amount - add padding in y direction&#10;row=number - use cell identified with given row (starting with 0)&#10;rowspan=number - this widget will span several rows&#10;sticky=NSEW - if cell is larger on which sides will this&#10;              widget stick to the cell boundary">
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_forget" func="yes">
			<Overload retVal="" descr="Unmap this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_info" func="yes">
			<Overload retVal="" descr="Return information about the options&#10;for positioning this widget in a grid.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_location" func="yes">
			<Overload retVal="" descr="Return a tuple of column and row which identify the cell&#10;at which the pixel at position X and Y inside the master&#10;widget is located.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_propagate" func="yes">
			<Overload retVal="" descr="Set or get the status for propagation of geometry information.&#10;&#10;A boolean argument specifies whether the geometry information&#10;of the slaves will determine the size of this widget. If no argument&#10;is given, the current setting will be returned.">
				<Param name="self" />
				<Param name="[flag=['_noarg_']]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_remove" func="yes">
			<Overload retVal="" descr="Unmap this widget but remember the grid options.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_rowconfigure" func="yes">
			<Overload retVal="" descr="Configure row INDEX of a grid.&#10;&#10;Valid resources are minsize (minimum size of the row),&#10;weight (how much does additional space propagate to this row)&#10;and pad (how much space to let additionally).">
				<Param name="self" />
				<Param name="index" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_size" func="yes">
			<Overload retVal="" descr="Return a tuple of the number of column and rows in the grid.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.grid_slaves" func="yes">
			<Overload retVal="" descr="Return a list of all slaves of this widget&#10;in its packing order.">
				<Param name="self" />
				<Param name="[row=None" />
				<Param name="[column=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.identify" func="yes">
			<Overload retVal="" descr="Returns the name of the element at position x, y, or the empty&#10;string if the point does not lie within any element.&#10;&#10;x and y are pixel coordinates relative to the widget.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.image_names" func="yes">
			<Overload retVal="" descr="Return a list of all existing image names.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.image_types" func="yes">
			<Overload retVal="" descr="Return a list of all available image types (e.g. phote bitmap).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.info" func="yes">
			<Overload retVal="" descr="Return information about the packing options&#10;for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.instate" func="yes">
			<Overload retVal="" descr="Test the widget's state.&#10;&#10;If callback is not specified, returns True if the widget state&#10;matches statespec and False otherwise. If callback is specified,&#10;then it will be invoked with *args, **kw if the widget state&#10;matches statespec. statespec is expected to be a sequence.">
				<Param name="self" />
				<Param name="statespec" />
				<Param name="[callback=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.keys" func="yes">
			<Overload retVal="" descr="Return a list of all resource names of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.lift" func="yes">
			<Overload retVal="" descr="Raise this widget in the stacking order.">
				<Param name="self" />
				<Param name="[aboveThis=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.location" func="yes">
			<Overload retVal="" descr="Return a tuple of column and row which identify the cell&#10;at which the pixel at position X and Y inside the master&#10;widget is located.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.lower" func="yes">
			<Overload retVal="" descr="Lower this widget in the stacking order.">
				<Param name="self" />
				<Param name="[belowThis=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.mainloop" func="yes">
			<Overload retVal="" descr="Call the mainloop of Tk.">
				<Param name="self" />
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.nametowidget" func="yes">
			<Overload retVal="" descr="Return the Tkinter instance of a widget identified by&#10;its Tcl name NAME.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.option_add" func="yes">
			<Overload retVal="" descr="Set a VALUE (second parameter) for an option&#10;PATTERN (first parameter).&#10;&#10;An optional third parameter gives the numeric priority&#10;(defaults to 80).">
				<Param name="self" />
				<Param name="pattern" />
				<Param name="value" />
				<Param name="[priority=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.option_clear" func="yes">
			<Overload retVal="" descr="Clear the option database.&#10;&#10;It will be reloaded if option_add is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.option_get" func="yes">
			<Overload retVal="" descr="Return the value for an option NAME for this widget&#10;with CLASSNAME.&#10;&#10;Values with higher priority override lower values.">
				<Param name="self" />
				<Param name="name" />
				<Param name="className" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.option_readfile" func="yes">
			<Overload retVal="" descr="Read file FILENAME into the option database.&#10;&#10;An optional second parameter gives the numeric&#10;priority.">
				<Param name="self" />
				<Param name="fileName" />
				<Param name="[priority=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.pack" func="yes">
			<Overload retVal="" descr="Pack a widget in the parent widget. Use as options:&#10;after=widget - pack it after you have packed widget&#10;anchor=NSEW (or subset) - position widget according to&#10;                          given direction&#10;before=widget - pack it before you will pack widget&#10;expand=bool - expand widget if parent size grows&#10;fill=NONE or X or Y or BOTH - fill widget if widget grows&#10;in=master - use master to contain this widget&#10;in_=master - see 'in' option description&#10;ipadx=amount - add internal padding in x direction&#10;ipady=amount - add internal padding in y direction&#10;padx=amount - add padding in x direction&#10;pady=amount - add padding in y direction&#10;side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.">
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.pack_configure" func="yes">
			<Overload retVal="" descr="Pack a widget in the parent widget. Use as options:&#10;after=widget - pack it after you have packed widget&#10;anchor=NSEW (or subset) - position widget according to&#10;                          given direction&#10;before=widget - pack it before you will pack widget&#10;expand=bool - expand widget if parent size grows&#10;fill=NONE or X or Y or BOTH - fill widget if widget grows&#10;in=master - use master to contain this widget&#10;in_=master - see 'in' option description&#10;ipadx=amount - add internal padding in x direction&#10;ipady=amount - add internal padding in y direction&#10;padx=amount - add padding in x direction&#10;pady=amount - add padding in y direction&#10;side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.">
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.pack_forget" func="yes">
			<Overload retVal="" descr="Unmap this widget and do not use it for the packing order.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.pack_info" func="yes">
			<Overload retVal="" descr="Return information about the packing options&#10;for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.pack_propagate" func="yes">
			<Overload retVal="" descr="Set or get the status for propagation of geometry information.&#10;&#10;A boolean argument specifies whether the geometry information&#10;of the slaves will determine the size of this widget. If no argument&#10;is given the current setting will be returned.">
				<Param name="self" />
				<Param name="[flag=['_noarg_']]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.pack_slaves" func="yes">
			<Overload retVal="" descr="Return a list of all slaves of this widget&#10;in its packing order.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.place" func="yes">
			<Overload retVal="" descr="Place a widget in the parent widget. Use as options:&#10;in=master - master relative to which the widget is placed&#10;in_=master - see 'in' option description&#10;x=amount - locate anchor of this widget at position x of master&#10;y=amount - locate anchor of this widget at position y of master&#10;relx=amount - locate anchor of this widget between 0.0 and 1.0&#10;              relative to width of master (1.0 is right edge)&#10;rely=amount - locate anchor of this widget between 0.0 and 1.0&#10;              relative to height of master (1.0 is bottom edge)&#10;anchor=NSEW (or subset) - position anchor according to given direction&#10;width=amount - width of this widget in pixel&#10;height=amount - height of this widget in pixel&#10;relwidth=amount - width of this widget between 0.0 and 1.0&#10;                  relative to width of master (1.0 is the same width&#10;                  as the master)&#10;relheight=amount - height of this widget between 0.0 and 1.0&#10;                   relative to height of master (1.0 is the same&#10;                   height as the master)&#10;bordermode=&quot;inside&quot; or &quot;outside&quot; - whether to take border width of&#10;                                   master widget into account">
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.place_configure" func="yes">
			<Overload retVal="" descr="Place a widget in the parent widget. Use as options:&#10;in=master - master relative to which the widget is placed&#10;in_=master - see 'in' option description&#10;x=amount - locate anchor of this widget at position x of master&#10;y=amount - locate anchor of this widget at position y of master&#10;relx=amount - locate anchor of this widget between 0.0 and 1.0&#10;              relative to width of master (1.0 is right edge)&#10;rely=amount - locate anchor of this widget between 0.0 and 1.0&#10;              relative to height of master (1.0 is bottom edge)&#10;anchor=NSEW (or subset) - position anchor according to given direction&#10;width=amount - width of this widget in pixel&#10;height=amount - height of this widget in pixel&#10;relwidth=amount - width of this widget between 0.0 and 1.0&#10;                  relative to width of master (1.0 is the same width&#10;                  as the master)&#10;relheight=amount - height of this widget between 0.0 and 1.0&#10;                   relative to height of master (1.0 is the same&#10;                   height as the master)&#10;bordermode=&quot;inside&quot; or &quot;outside&quot; - whether to take border width of&#10;                                   master widget into account">
				<Param name="self" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.place_forget" func="yes">
			<Overload retVal="" descr="Unmap this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.place_info" func="yes">
			<Overload retVal="" descr="Return information about the placing options&#10;for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.place_slaves" func="yes">
			<Overload retVal="" descr="Return a list of all slaves of this widget&#10;in its packing order.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.propagate" func="yes">
			<Overload retVal="" descr="Set or get the status for propagation of geometry information.&#10;&#10;A boolean argument specifies whether the geometry information&#10;of the slaves will determine the size of this widget. If no argument&#10;is given the current setting will be returned.">
				<Param name="self" />
				<Param name="[flag=['_noarg_']]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.quit" func="yes">
			<Overload retVal="" descr="Quit the Tcl interpreter. All widgets will be destroyed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.register" func="yes">
			<Overload retVal="" descr="Return a newly created Tcl function. If this&#10;function is called, the Python function FUNC will&#10;be executed. An optional function SUBST can&#10;be given which will be executed before FUNC.">
				<Param name="self" />
				<Param name="func" />
				<Param name="[subst=None" />
				<Param name="[needcleanup=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.rowconfigure" func="yes">
			<Overload retVal="" descr="Configure row INDEX of a grid.&#10;&#10;Valid resources are minsize (minimum size of the row),&#10;weight (how much does additional space propagate to this row)&#10;and pad (how much space to let additionally).">
				<Param name="self" />
				<Param name="index" />
				<Param name="[cnf={}" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.selection_clear" func="yes">
			<Overload retVal="" descr="Clear the current X selection.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.selection_get" func="yes">
			<Overload retVal="" descr="Return the contents of the current X selection.&#10;&#10;A keyword parameter selection specifies the name of&#10;the selection and defaults to PRIMARY.  A keyword&#10;parameter displayof specifies a widget on the display&#10;to use. A keyword parameter type specifies the form of data to be&#10;fetched, defaulting to STRING except on X11, where UTF8_STRING is tried&#10;before STRING.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.selection_handle" func="yes">
			<Overload retVal="" descr="Specify a function COMMAND to call if the X&#10;selection owned by this widget is queried by another&#10;application.&#10;&#10;This function must return the contents of the&#10;selection. The function will be called with the&#10;arguments OFFSET and LENGTH which allows the chunking&#10;of very long selections. The following keyword&#10;parameters can be provided:&#10;selection - name of the selection (default PRIMARY),&#10;type - type of the selection (e.g. STRING, FILE_NAME).">
				<Param name="self" />
				<Param name="command" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.selection_own" func="yes">
			<Overload retVal="" descr="Become owner of X selection.&#10;&#10;A keyword parameter selection specifies the name of&#10;the selection (default PRIMARY).">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.selection_own_get" func="yes">
			<Overload retVal="" descr="Return owner of X selection.&#10;&#10;The following keyword parameter can&#10;be provided:&#10;selection - name of the selection (default PRIMARY),&#10;type - type of the selection (e.g. STRING, FILE_NAME).">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.send" func="yes">
			<Overload retVal="" descr="Send Tcl command CMD to different interpreter INTERP to be executed.">
				<Param name="self" />
				<Param name="interp" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.setvar" func="yes">
			<Overload retVal="" descr="Set Tcl variable NAME to VALUE.">
				<Param name="self" />
				<Param name="[name=PY_VAR" />
				<Param name="[value=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.size" func="yes">
			<Overload retVal="" descr="Return a tuple of the number of column and rows in the grid.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.slaves" func="yes">
			<Overload retVal="" descr="Return a list of all slaves of this widget&#10;in its packing order.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.state" func="yes">
			<Overload retVal="" descr="Modify or inquire widget state.&#10;&#10;Widget state is returned if statespec is None, otherwise it is&#10;set according to the statespec flags and then a new state spec&#10;is returned indicating which flags were changed. statespec is&#10;expected to be a sequence.">
				<Param name="self" />
				<Param name="[statespec=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_bisque" func="yes">
			<Overload retVal="" descr="Change the color scheme to light brown as used in Tk 3.6 and before.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_focusFollowsMouse" func="yes">
			<Overload retVal="" descr="The widget under mouse will get automatically focus. Can not&#10;be disabled easily.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_focusNext" func="yes">
			<Overload retVal="" descr="Return the next widget in the focus order which follows&#10;widget which has currently the focus.&#10;&#10;The focus order first goes to the next child, then to&#10;the children of the child recursively and then to the&#10;next sibling which is higher in the stacking order.  A&#10;widget is omitted if it has the takefocus resource set&#10;to 0.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_focusPrev" func="yes">
			<Overload retVal="" descr="Return previous widget in the focus order. See tk_focusNext for details.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_menuBar" func="yes">
			<Overload retVal="" descr="Do not use. Needed in Tk 3.6 and earlier.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_setPalette" func="yes">
			<Overload retVal="" descr="Set a new color scheme for all widget elements.&#10;&#10;A single color as argument will cause that all colors of Tk&#10;widget elements are derived from this.&#10;Alternatively several keyword parameters and its associated&#10;colors can be given. The following keywords are valid:&#10;activeBackground, foreground, selectColor,&#10;activeForeground, highlightBackground, selectBackground,&#10;background, highlightColor, selectForeground,&#10;disabledForeground, insertBackground, troughColor.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tk_strictMotif" func="yes">
			<Overload retVal="" descr="Set Tcl internal variable, whether the look and feel&#10;should adhere to Motif.&#10;&#10;A parameter of 1 means adhere to Motif (e.g. no color&#10;change if mouse passes over slider).&#10;Returns the set value.">
				<Param name="self" />
				<Param name="[boolean=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.tkraise" func="yes">
			<Overload retVal="" descr="Raise this widget in the stacking order.">
				<Param name="self" />
				<Param name="[aboveThis=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.unbind" func="yes">
			<Overload retVal="" descr="Unbind for this widget for event SEQUENCE  the&#10;function identified with FUNCID.">
				<Param name="self" />
				<Param name="sequence" />
				<Param name="[funcid=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.unbind_all" func="yes">
			<Overload retVal="" descr="Unbind for all widgets for event SEQUENCE all functions.">
				<Param name="self" />
				<Param name="sequence" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.unbind_class" func="yes">
			<Overload retVal="" descr="Unbind for a all widgets with bindtag CLASSNAME for event SEQUENCE&#10;all functions.">
				<Param name="self" />
				<Param name="className" />
				<Param name="sequence" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.update" func="yes">
			<Overload retVal="" descr="Enter event loop until all pending events have been processed by Tcl.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.update_idletasks" func="yes">
			<Overload retVal="" descr="Enter event loop until all idle callbacks have been called. This&#10;will update the display of windows but not process events caused by&#10;the user.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.value" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.wait_variable" func="yes">
			<Overload retVal="" descr="Wait until the variable is modified.&#10;&#10;A parameter of type IntVar, StringVar, DoubleVar or&#10;BooleanVar must be given.">
				<Param name="self" />
				<Param name="[name=PY_VAR]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.wait_visibility" func="yes">
			<Overload retVal="" descr="Wait until the visibility of a WIDGET changes&#10;(e.g. it appears).&#10;&#10;If no parameter is given self is used.">
				<Param name="self" />
				<Param name="[window=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.wait_window" func="yes">
			<Overload retVal="" descr="Wait until a WIDGET is destroyed.&#10;&#10;If no parameter is given self is used.">
				<Param name="self" />
				<Param name="[window=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.waitvar" func="yes">
			<Overload retVal="" descr="Wait until the variable is modified.&#10;&#10;A parameter of type IntVar, StringVar, DoubleVar or&#10;BooleanVar must be given.">
				<Param name="self" />
				<Param name="[name=PY_VAR]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_atom" func="yes">
			<Overload retVal="" descr="Return integer which represents atom NAME.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[displayof=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_atomname" func="yes">
			<Overload retVal="" descr="Return name of atom with identifier ID.">
				<Param name="self" />
				<Param name="id" />
				<Param name="[displayof=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_cells" func="yes">
			<Overload retVal="" descr="Return number of cells in the colormap for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_children" func="yes">
			<Overload retVal="" descr="Return a list of all widgets which are children of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_class" func="yes">
			<Overload retVal="" descr="Return window class name of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_colormapfull" func="yes">
			<Overload retVal="" descr="Return true if at the last color request the colormap was full.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_containing" func="yes">
			<Overload retVal="" descr="Return the widget which is at the root coordinates ROOTX, ROOTY.">
				<Param name="self" />
				<Param name="rootX" />
				<Param name="rootY" />
				<Param name="[displayof=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_depth" func="yes">
			<Overload retVal="" descr="Return the number of bits per pixel.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_exists" func="yes">
			<Overload retVal="" descr="Return true if this widget exists.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_fpixels" func="yes">
			<Overload retVal="" descr='Return the number of pixels for the given distance NUMBER&#10;(e.g. "3c") as float.'>
				<Param name="self" />
				<Param name="number" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_geometry" func="yes">
			<Overload retVal="" descr='Return geometry string for this widget in the form "widthxheight+X+Y".'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_height" func="yes">
			<Overload retVal="" descr="Return height of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_id" func="yes">
			<Overload retVal="" descr="Return identifier ID for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_interps" func="yes">
			<Overload retVal="" descr="Return the name of all Tcl interpreters for this display.">
				<Param name="self" />
				<Param name="[displayof=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_ismapped" func="yes">
			<Overload retVal="" descr="Return true if this widget is mapped.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_manager" func="yes">
			<Overload retVal="" descr="Return the window mananger name for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_name" func="yes">
			<Overload retVal="" descr="Return the name of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_parent" func="yes">
			<Overload retVal="" descr="Return the name of the parent of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_pathname" func="yes">
			<Overload retVal="" descr="Return the pathname of the widget given by ID.">
				<Param name="self" />
				<Param name="id" />
				<Param name="[displayof=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_pixels" func="yes">
			<Overload retVal="" descr="Rounded integer value of winfo_fpixels.">
				<Param name="self" />
				<Param name="number" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_pointerx" func="yes">
			<Overload retVal="" descr="Return the x coordinate of the pointer on the root window.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_pointerxy" func="yes">
			<Overload retVal="" descr="Return a tuple of x and y coordinates of the pointer on the root window.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_pointery" func="yes">
			<Overload retVal="" descr="Return the y coordinate of the pointer on the root window.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_reqheight" func="yes">
			<Overload retVal="" descr="Return requested height of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_reqwidth" func="yes">
			<Overload retVal="" descr="Return requested width of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_rgb" func="yes">
			<Overload retVal="" descr="Return tuple of decimal values for red, green, blue for&#10;COLOR in this widget.">
				<Param name="self" />
				<Param name="color" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_rootx" func="yes">
			<Overload retVal="" descr="Return x coordinate of upper left corner of this widget on the&#10;root window.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_rooty" func="yes">
			<Overload retVal="" descr="Return y coordinate of upper left corner of this widget on the&#10;root window.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screen" func="yes">
			<Overload retVal="" descr="Return the screen name of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screencells" func="yes">
			<Overload retVal="" descr="Return the number of the cells in the colormap of the screen&#10;of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screendepth" func="yes">
			<Overload retVal="" descr="Return the number of bits per pixel of the root window of the&#10;screen of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screenheight" func="yes">
			<Overload retVal="" descr="Return the number of pixels of the height of the screen of this widget&#10;in pixel.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screenmmheight" func="yes">
			<Overload retVal="" descr="Return the number of pixels of the height of the screen of&#10;this widget in mm.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screenmmwidth" func="yes">
			<Overload retVal="" descr="Return the number of pixels of the width of the screen of&#10;this widget in mm.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screenvisual" func="yes">
			<Overload retVal="" descr="Return one of the strings directcolor, grayscale, pseudocolor,&#10;staticcolor, staticgray, or truecolor for the default&#10;colormodel of this screen.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_screenwidth" func="yes">
			<Overload retVal="" descr="Return the number of pixels of the width of the screen of&#10;this widget in pixel.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_server" func="yes">
			<Overload retVal="" descr='Return information of the X-Server of the screen of this widget in&#10;the form "XmajorRminor vendor vendorVersion".'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_toplevel" func="yes">
			<Overload retVal="" descr="Return the toplevel widget of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_viewable" func="yes">
			<Overload retVal="" descr="Return true if the widget and all its higher ancestors are mapped.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_visual" func="yes">
			<Overload retVal="" descr="Return one of the strings directcolor, grayscale, pseudocolor,&#10;staticcolor, staticgray, or truecolor for the&#10;colormodel of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_visualid" func="yes">
			<Overload retVal="" descr="Return the X identifier for the visual for this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_visualsavailable" func="yes">
			<Overload retVal="" descr="Return a list of all visuals available for the screen&#10;of this widget.&#10;&#10;Each item in the list consists of a visual name (see winfo_visual), a&#10;depth and if INCLUDEIDS=1 is given also the X identifier.">
				<Param name="self" />
				<Param name="[includeids=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_vrootheight" func="yes">
			<Overload retVal="" descr="Return the height of the virtual root window associated with this&#10;widget in pixels. If there is no virtual root window return the&#10;height of the screen.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_vrootwidth" func="yes">
			<Overload retVal="" descr="Return the width of the virtual root window associated with this&#10;widget in pixel. If there is no virtual root window return the&#10;width of the screen.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_vrootx" func="yes">
			<Overload retVal="" descr="Return the x offset of the virtual root relative to the root&#10;window of the screen of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_vrooty" func="yes">
			<Overload retVal="" descr="Return the y offset of the virtual root relative to the root&#10;window of the screen of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_width" func="yes">
			<Overload retVal="" descr="Return the width of this widget.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_x" func="yes">
			<Overload retVal="" descr="Return the x coordinate of the upper left corner of this widget&#10;in the parent.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.LabeledScale.winfo_y" func="yes">
			<Overload retVal="" descr="Return the y coordinate of the upper left corner of this widget&#10;in the parent.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Labelframe" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Menubutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Notebook" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.OptionMenu" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.PanedWindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Panedwindow" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Progressbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Radiobutton" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Scale" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Scrollbar" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Separator" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Sizegrip" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style" func="yes">
			<Overload retVal="" descr="Manipulate style database.">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.configure" func="yes">
			<Overload retVal="" descr="Query or sets the default value of the specified option(s) in&#10;style.&#10;&#10;Each key in kw is an option and each value is either a string or&#10;a sequence identifying the value for that option.">
				<Param name="self" />
				<Param name="style" />
				<Param name="[query_opt=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.element_create" func="yes">
			<Overload retVal="" descr="Create a new element in the current theme of given etype.">
				<Param name="self" />
				<Param name="elementname" />
				<Param name="etype" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.element_names" func="yes">
			<Overload retVal="" descr="Returns the list of elements defined in the current theme.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.element_options" func="yes">
			<Overload retVal="" descr="Return the list of elementname's options.">
				<Param name="self" />
				<Param name="elementname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.layout" func="yes">
			<Overload retVal="" descr='Define the widget layout for given style. If layoutspec is&#10;omitted, return the layout specification for given style.&#10;&#10;layoutspec is expected to be a list or an object different than&#10;None that evaluates to False if you want to "turn off" that style.&#10;If it is a list (or tuple, or something else), each item should be&#10;a tuple where the first item is the layout name and the second item&#10;should have the format described below:&#10;&#10;LAYOUTS&#10;&#10;    A layout can contain the value None, if takes no options, or&#10;    a dict of options specifying how to arrange the element.&#10;    The layout mechanism uses a simplified version of the pack&#10;    geometry manager: given an initial cavity, each element is&#10;    allocated a parcel. Valid options/values are:&#10;&#10;        side: whichside&#10;            Specifies which side of the cavity to place the&#10;            element; one of top, right, bottom or left. If&#10;            omitted, the element occupies the entire cavity.&#10;&#10;        sticky: nswe&#10;            Specifies where the element is placed inside its&#10;            allocated parcel.&#10;&#10;        children: [sublayout... ]&#10;            Specifies a list of elements to place inside the&#10;            element. Each element is a tuple (or other sequence)&#10;            where the first item is the layout name, and the other&#10;            is a LAYOUT.'>
				<Param name="self" />
				<Param name="style" />
				<Param name="[layoutspec=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.lookup" func="yes">
			<Overload retVal="" descr="Returns the value specified for option in style.&#10;&#10;If state is specified it is expected to be a sequence of one&#10;or more states. If the default argument is set, it is used as&#10;a fallback value in case no specification for option is found.">
				<Param name="self" />
				<Param name="style" />
				<Param name="option" />
				<Param name="[state=None" />
				<Param name="[default=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.map" func="yes">
			<Overload retVal="" descr="Query or sets dynamic values of the specified option(s) in&#10;style.&#10;&#10;Each key in kw is an option and each value should be a list or a&#10;tuple (usually) containing statespecs grouped in tuples, or list,&#10;or something else of your preference. A statespec is compound of&#10;one or more states and then a value.">
				<Param name="self" />
				<Param name="style" />
				<Param name="[query_opt=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.theme_create" func="yes">
			<Overload retVal="" descr="Creates a new theme.&#10;&#10;It is an error if themename already exists. If parent is&#10;specified, the new theme will inherit styles, elements and&#10;layouts from the specified parent theme. If settings are present,&#10;they are expected to have the same syntax used for theme_settings.">
				<Param name="self" />
				<Param name="themename" />
				<Param name="[parent=None" />
				<Param name="[settings=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.theme_names" func="yes">
			<Overload retVal="" descr="Returns a list of all known themes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.theme_settings" func="yes">
			<Overload retVal="" descr="Temporarily sets the current theme to themename, apply specified&#10;settings and then restore the previous theme.&#10;&#10;Each key in settings is a style and each value may contain the&#10;keys 'configure', 'map', 'layout' and 'element create' and they&#10;are expected to have the same format as specified by the methods&#10;configure, map, layout and element_create respectively.">
				<Param name="self" />
				<Param name="themename" />
				<Param name="settings" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Style.theme_use" func="yes">
			<Overload retVal="" descr="If themename is None, returns the theme in use, otherwise, set&#10;the current theme to themename, refreshes all widgets and emits&#10;a &lt;&lt;ThemeChanged&gt;&gt; event.">
				<Param name="self" />
				<Param name="[themename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Treeview" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.Widget" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.setup_master" func="yes">
			<Overload retVal="" descr="If master is not None, itself is returned. If master is None,&#10;the default master is returned if there is one, otherwise a new&#10;master is created and returned.&#10;&#10;If it is not allowed to use the default root and master is None,&#10;RuntimeError is raised.">
				<Param name="[master=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttk.tclobjs_to_py" func="yes">
			<Overload retVal="" descr="Returns adict with its values converted from Tcl objects to Python&#10;objects.">
				<Param name="adict" />
			</Overload>
		</KeyWord>
		<KeyWord name="ttypager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="tuple" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle" func="yes">
			<Overload retVal="" descr="Turtle graphics is a popular way for introducing programming to&#10;kids. It was part of the original Logo programming language developed&#10;by Wally Feurzig and Seymour Papert in 1966.&#10;&#10;Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an ``import turtle``, give it&#10;the command turtle.forward(15), and it moves (on-screen!) 15 pixels in&#10;the direction it is facing, drawing a line as it moves. Give it the&#10;command turtle.right(25), and it rotates in-place 25 degrees clockwise.&#10;&#10;By combining together these and similar commands, intricate shapes and&#10;pictures can easily be drawn.&#10;&#10;----- turtle.py&#10;&#10;This module is an extended reimplementation of turtle.py from the&#10;Python standard distribution up to Python 2.5. (See: http://www.python.org)&#10;&#10;It tries to keep the merits of turtle.py and to be (nearly) 100%&#10;compatible with it. This means in the first place to enable the&#10;learning programmer to use all the commands, classes and methods&#10;interactively when using the module from within IDLE run with&#10;the -n switch.&#10;&#10;Roughly it has the following features added:&#10;&#10;- Better animation of the turtle movements, especially of turning the&#10;  turtle. So the turtles can more easily be used as a visual feedback&#10;  instrument by the (beginning) programmer.&#10;&#10;- Different turtle shapes, gif-images as turtle shapes, user defined&#10;  and user controllable turtle shapes, among them compound&#10;  (multicolored) shapes. Turtle shapes can be stretched and tilted, which&#10;  makes turtles very versatile geometrical objects.&#10;&#10;- Fine control over turtle movement and screen updates via delay(),&#10;  and enhanced tracer() and speed() methods.&#10;&#10;- Aliases for the most commonly used commands, like fd for forward etc.,&#10;  following the early Logo traditions. This reduces the boring work of&#10;  typing long sequences of commands, which often occur in a natural way&#10;  when kids try to program fancy pictures on their first encounter with&#10;  turtle graphics.&#10;&#10;- Turtles now have an undo()-method with configurable undo-buffer.&#10;&#10;- Some simple commands/methods for creating event driven programs&#10;  (mouse-, key-, timer-events). Especially useful for programming games.&#10;&#10;- A scrollable Canvas class. The default scrollable Canvas can be&#10;  extended interactively as needed while playing around with the turtle(s).&#10;&#10;- A TurtleScreen class with methods controlling background color or&#10;  background image, window and canvas size and other properties of the&#10;  TurtleScreen.&#10;&#10;- There is a method, setworldcoordinates(), to install a user defined&#10;  coordinate-system for the TurtleScreen.&#10;&#10;- The implementation uses a 2-vector class named Vec2D, derived from tuple.&#10;  This class is public, so it can be imported by the application programmer,&#10;  which makes certain types of computations very natural and compact.&#10;&#10;- Appearance of the TurtleScreen and the Turtles at startup/import can be&#10;  configured by means of a turtle.cfg configuration file.&#10;  The default configuration mimics the appearance of the old turtle module.&#10;&#10;- If configured appropriately the module reads in docstrings from a docstring&#10;  dictionary in some different language, supplied separately  and replaces&#10;  the English ones by those read in. There is a utility function&#10;  write_docstringdict() to write a dictionary with the original (English)&#10;  docstrings to disc, so it can serve as a template for translations.&#10;&#10;Behind the scenes there are some features included with possible&#10;extensions in mind. These will be commented and documented elsewhere.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Canvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen" func="yes">
			<Overload retVal="" descr="RawTurtle auto-creating (scrolled) canvas.&#10;&#10;When a Turtle object is created or a function derived from some&#10;Turtle method is called a TurtleScreen object is automatically created.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.DEFAULT_ANGLEORIENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.DEFAULT_MODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.START_ORIENTATION" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.back" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.backward" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.begin_fill" func="yes">
			<Overload retVal="" descr="Called just before drawing a shape to be filled.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.begin_poly" func="yes">
			<Overload retVal="" descr="Start recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Start recording the vertices of a polygon. Current turtle position&#10;is first point of polygon.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.bk" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.circle" func="yes">
			<Overload retVal="" descr="Draw a circle with given radius.&#10;&#10;Arguments:&#10;radius -- a number&#10;extent (optional) -- a number&#10;steps (optional) -- an integer&#10;&#10;Draw a circle with given radius. The center is radius units left&#10;of the turtle; extent - an angle - determines which part of the&#10;circle is drawn. If extent is not given, draw the entire circle.&#10;If extent is not a full circle, one endpoint of the arc is the&#10;current pen position. Draw the arc in counterclockwise direction&#10;if radius is positive, otherwise in clockwise direction. Finally&#10;the direction of the turtle is changed by the amount of extent.&#10;&#10;As the circle is approximated by an inscribed regular polygon,&#10;steps determines the number of steps to use. If not given,&#10;it will be calculated automatically. Maybe used to draw regular&#10;polygons.&#10;&#10;call: circle(radius)                  # full circle&#10;--or: circle(radius, extent)          # arc&#10;--or: circle(radius, extent, steps)&#10;--or: circle(radius, steps=6)         # 6-sided polygon&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.circle(50)&#10;&gt;&gt;&gt; turtle.circle(120, 180)  # semicircle">
				<Param name="self" />
				<Param name="radius" />
				<Param name="[extent=None" />
				<Param name="[steps=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.clear" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings from the screen. Do not move turtle.&#10;&#10;No arguments.&#10;&#10;Delete the turtle's drawings from the screen. Do not move turtle.&#10;State and position of the turtle as well as drawings of other&#10;turtles are not affected.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.clear()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.clearstamp" func="yes">
			<Overload retVal="" descr='Delete stamp with given stampid&#10;&#10;Argument:&#10;stampid - an integer, must be return value of previous stamp() call.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; astamp = turtle.stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.clearstamp(astamp)'>
				<Param name="self" />
				<Param name="stampid" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.clearstamps" func="yes">
			<Overload retVal="" descr="Delete all or first/last n of turtle's stamps.&#10;&#10;Optional argument:&#10;n -- an integer&#10;&#10;If n is None, delete all of pen's stamps,&#10;else if n &gt; 0 delete first n stamps&#10;else if n &lt; 0 delete last n stamps.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.stamp(); turtle.fd(30)&#10;...&#10;&gt;&gt;&gt; turtle.clearstamps(2)&#10;&gt;&gt;&gt; turtle.clearstamps(-2)&#10;&gt;&gt;&gt; turtle.clearstamps()">
				<Param name="self" />
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.clone" func="yes">
			<Overload retVal="" descr="Create and return a clone of the turtle.&#10;&#10;No argument.&#10;&#10;Create and return a clone of the turtle with same position, heading&#10;and turtle properties.&#10;&#10;Example (for a Turtle instance named mick):&#10;mick = Turtle()&#10;joe = mick.clone()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.color" func="yes">
			<Overload retVal="" descr="Return or set the pencolor and fillcolor.&#10;&#10;Arguments:&#10;Several input formats are allowed.&#10;They use 0, 1, 2, or 3 arguments as follows:&#10;&#10;color()&#10;    Return the current pencolor and the current fillcolor&#10;    as a pair of color specification strings as are returned&#10;    by pencolor and fillcolor.&#10;color(colorstring), color((r,g,b)), color(r,g,b)&#10;    inputs as in pencolor, set both, fillcolor and pencolor,&#10;    to the given value.&#10;color(colorstring1, colorstring2),&#10;color((r1,g1,b1), (r2,g2,b2))&#10;    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)&#10;    and analogously, if the other input format is used.&#10;&#10;If turtleshape is a polygon, outline and interior of that polygon&#10;is drawn with the newly set colors.&#10;For mor info see: pencolor, fillcolor&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color('red', 'green')&#10;&gt;&gt;&gt; turtle.color()&#10;('red', 'green')&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))&#10;&gt;&gt;&gt; color()&#10;('#285078', '#a0c8f0')">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.degrees" func="yes">
			<Overload retVal="" descr="Set angle measurement units to degrees.&#10;&#10;Optional argument:&#10;fullcircle -  a number&#10;&#10;Set angle measurement units, i. e. set number&#10;of 'degrees' for a full circle. Dafault value is&#10;360 degrees.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&#10;Change angle measurement unit to grad (also known as gon,&#10;grade, or gradian and equals 1/100-th of the right angle.)&#10;&gt;&gt;&gt; turtle.degrees(400.0)&#10;&gt;&gt;&gt; turtle.heading()&#10;100">
				<Param name="self" />
				<Param name="[fullcircle=360.0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.distance" func="yes">
			<Overload retVal="" descr="Return the distance from the turtle to (x,y) in turtle step units.&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.distance(30,40)&#10;50.0&#10;&gt;&gt;&gt; pen = Turtle()&#10;&gt;&gt;&gt; pen.forward(77)&#10;&gt;&gt;&gt; turtle.distance(pen)&#10;77.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.dot" func="yes">
			<Overload retVal="" descr='Draw a dot with diameter size, using color.&#10;&#10;Optional arguments:&#10;size -- an integer &gt;= 1 (if given)&#10;color -- a colorstring or a numeric color tuple&#10;&#10;Draw a circular dot with diameter size, using color.&#10;If size is not given, the maximum of pensize+4 and 2*pensize is used.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.dot()&#10;&gt;&gt;&gt; turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)'>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.down" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.end_fill" func="yes">
			<Overload retVal="" descr="Fill the shape drawn after the call begin_fill().&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.end_poly" func="yes">
			<Overload retVal="" descr="Stop recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Stop recording the vertices of a polygon. Current turtle position is&#10;last point of polygon. This will be connected with the first point.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.end_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.fd" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.fill" func="yes">
			<Overload retVal="" descr="Call fill(True) before drawing a shape to fill, fill(False) when done.&#10;&#10;Optional argument:&#10;flag -- True/False (or 1/0 respectively)&#10;&#10;Call fill(True) before drawing the shape you want to fill,&#10;and  fill(False) when done.&#10;When used without argument: return fillstate (True if filling,&#10;False else)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fill(True)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.fill(False)">
				<Param name="self" />
				<Param name="[flag=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.fillcolor" func="yes">
			<Overload retVal="" descr="Return or set the fillcolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - fillcolor()&#10;    Return the current fillcolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - fillcolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - fillcolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - fillcolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the interior of that polygon is drawn&#10;with the newly set fillcolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fillcolor('violet')&#10;&gt;&gt;&gt; col = turtle.pencolor()&#10;&gt;&gt;&gt; turtle.fillcolor(col)&#10;&gt;&gt;&gt; turtle.fillcolor(0, .5, 0)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.forward" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.get_poly" func="yes">
			<Overload retVal="" descr='Return the lastly recorded polygon.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; p = turtle.get_poly()&#10;&gt;&gt;&gt; turtle.register_shape("myFavouriteShape", p)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.getpen" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.getscreen" func="yes">
			<Overload retVal="" descr='Return the TurtleScreen object, the turtle is drawing  on.&#10;&#10;No argument.&#10;&#10;Return the TurtleScreen object, the turtle is drawing  on.&#10;So TurtleScreen-methods can be called for that object.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; ts = turtle.getscreen()&#10;&gt;&gt;&gt; ts&#10;&lt;turtle.TurtleScreen object at 0x0106B770&gt;&#10;&gt;&gt;&gt; ts.bgcolor("pink")'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.getturtle" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.goto" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.heading" func="yes">
			<Overload retVal="" descr="Return the turtle's current heading.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(67)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.hideturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.home" func="yes">
			<Overload retVal="" descr="Move turtle to the origin - coordinates (0,0).&#10;&#10;No arguments.&#10;&#10;Move turtle to the origin - coordinates (0,0) and set its&#10;heading to its start-orientation (which depends on mode).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.home()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.ht" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.isdown" func="yes">
			<Overload retVal="" descr="Return True if pen is down, False if it's up.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.isdown()&#10;False&#10;&gt;&gt;&gt; turtle.pendown()&#10;&gt;&gt;&gt; turtle.isdown()&#10;True">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.isvisible" func="yes">
			<Overload retVal="" descr="Return True if the Turtle is shown, False if it's hidden.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; print turtle.isvisible():&#10;False">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.left" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.lt" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.onclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun --  a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;add --  True or False. If True, new binding will be added, otherwise&#10;        it will replace a former binding.&#10;&#10;Example for the anonymous turtle, i. e. the procedural way:&#10;&#10;&gt;&gt;&gt; def turn(x, y):&#10;...     left(360)&#10;...&#10;&gt;&gt;&gt; onclick(turn)  # Now clicking into the turtle will turn it.&#10;&gt;&gt;&gt; onclick(None)  # event-binding will be removed">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.ondrag" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-move event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;       the coordinates of the clicked point on the canvas.&#10;num -- number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Every sequence of mouse-move-events on a turtle is preceded by a&#10;mouse-click event on that turtle.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.ondrag(turtle.goto)&#10;&#10;Subsequently clicking and dragging a Turtle will move it&#10;across the screen thereby producing handdrawings (if pen is&#10;down).">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.onrelease" func="yes">
			<Overload retVal="" descr='Bind fun to mouse-button-release event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Example (for a MyTurtle instance named joe):&#10;&gt;&gt;&gt; class MyTurtle(Turtle):&#10;...     def glow(self,x,y):&#10;...             self.fillcolor("red")&#10;...     def unglow(self,x,y):&#10;...             self.fillcolor("")&#10;...&#10;&gt;&gt;&gt; joe = MyTurtle()&#10;&gt;&gt;&gt; joe.onclick(joe.glow)&#10;&gt;&gt;&gt; joe.onrelease(joe.unglow)&#10;&#10;Clicking on joe turns fillcolor red, unclicking turns it to&#10;transparent.'>
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pd" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pen" func="yes">
			<Overload retVal="" descr="Return or set the pen's attributes.&#10;&#10;Arguments:&#10;    pen -- a dictionary with some or all of the below listed keys.&#10;    **pendict -- one or more keyword-arguments with the below&#10;                 listed keys as keywords.&#10;&#10;Return or set the pen's attributes in a 'pen-dictionary'&#10;with the following key/value pairs:&#10;   &quot;shown&quot;      :   True/False&#10;   &quot;pendown&quot;    :   True/False&#10;   &quot;pencolor&quot;   :   color-string or color-tuple&#10;   &quot;fillcolor&quot;  :   color-string or color-tuple&#10;   &quot;pensize&quot;    :   positive number&#10;   &quot;speed&quot;      :   number in range 0..10&#10;   &quot;resizemode&quot; :   &quot;auto&quot; or &quot;user&quot; or &quot;noresize&quot;&#10;   &quot;stretchfactor&quot;: (positive number, positive number)&#10;   &quot;outline&quot;    :   positive number&#10;   &quot;tilt&quot;       :   number&#10;&#10;This dictionary can be used as argument for a subsequent&#10;pen()-call to restore the former pen-state. Moreover one&#10;or more of these attributes can be provided as keyword-arguments.&#10;This can be used to set several pen attributes in one statement.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pen(fillcolor=&quot;black&quot;, pencolor=&quot;red&quot;, pensize=10)&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; penstate=turtle.pen()&#10;&gt;&gt;&gt; turtle.color(&quot;yellow&quot;,&quot;&quot;)&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; p.pen(penstate, fillcolor=&quot;green&quot;)&#10;&gt;&gt;&gt; p.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',&#10;'stretchfactor': (1,1), 'speed': 3}">
				<Param name="self" />
				<Param name="[pen=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pencolor" func="yes">
			<Overload retVal="" descr="Return or set the pencolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - pencolor()&#10;    Return the current pencolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - pencolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - pencolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - pencolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the outline of that polygon is drawn&#10;with the newly set pencolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pencolor('brown')&#10;&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)&#10;&gt;&gt;&gt; turtle.pencolor(tup)&#10;&gt;&gt;&gt; turtle.pencolor()&#10;'#33cc8c'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pendown" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pensize" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.penup" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pos" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.position" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.pu" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.radians" func="yes">
			<Overload retVal="" descr="Set the angle measurement units to radians.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&gt;&gt;&gt; turtle.radians()&#10;&gt;&gt;&gt; turtle.heading()&#10;1.5707963267948966">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.reset" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings and restore its default values.&#10;&#10;        No argument.&#10;,&#10;        Delete the turtle's drawings from the screen, re-center the turtle&#10;        and set variables to the default values.&#10;&#10;        Example (for a Turtle instance named turtle):&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,-22.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        100.0&#10;        &gt;&gt;&gt; turtle.reset()&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,0.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        0.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.resizemode" func="yes">
			<Overload retVal="" descr="Set resizemode to one of the values: &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;.&#10;&#10;(Optional) Argument:&#10;rmode -- one of the strings &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;&#10;&#10;Different resizemodes have the following effects:&#10;  - &quot;auto&quot; adapts the appearance of the turtle&#10;           corresponding to the value of pensize.&#10;  - &quot;user&quot; adapts the appearance of the turtle according to the&#10;           values of stretchfactor and outlinewidth (outline),&#10;           which are set by shapesize()&#10;  - &quot;noresize&quot; no adaption of the turtle's appearance takes place.&#10;If no argument is given, return current resizemode.&#10;resizemode(&quot;user&quot;) is called by a call of shapesize with arguments.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;noresize&quot;)&#10;&gt;&gt;&gt; turtle.resizemode()&#10;'noresize'">
				<Param name="self" />
				<Param name="[rmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.right" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.rt" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.seth" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.setheading" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.setpos" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.setposition" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.settiltangle" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape to point in the specified direction&#10;&#10;Optional argument:&#10;angle -- number&#10;&#10;Rotate the turtleshape to point in the direction specified by angle,&#10;regardless of its current tilt-angle. DO NOT change the turtle's&#10;heading (direction of movement).&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.settiltangle(45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.settiltangle(-45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.setundobuffer" func="yes">
			<Overload retVal="" descr="Set or disable undobuffer.&#10;&#10;Argument:&#10;size -- an integer or None&#10;&#10;If size is an integer an empty undobuffer of given size is installed.&#10;Size gives the maximum number of turtle-actions that can be undone&#10;by the undo() function.&#10;If size is None, no undobuffer is present.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setundobuffer(42)">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.setx" func="yes">
			<Overload retVal="" descr="Set the turtle's first coordinate to x&#10;&#10;Argument:&#10;x -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, leave second coordinate&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 240.00)&#10;&gt;&gt;&gt; turtle.setx(10)&#10;&gt;&gt;&gt; turtle.position()&#10;(10.00, 240.00)">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.sety" func="yes">
			<Overload retVal="" descr="Set the turtle's second coordinate to y&#10;&#10;Argument:&#10;y -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, second coordinate remains&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 40.00)&#10;&gt;&gt;&gt; turtle.sety(-10)&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, -10.00)">
				<Param name="self" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.shape" func="yes">
			<Overload retVal="" descr="Set turtle shape to shape with given name / return current shapename.&#10;&#10;Optional argument:&#10;name -- a string, which is a valid shapename&#10;&#10;Set turtle shape to shape with given name or, if name is not given,&#10;return name of current shape.&#10;Shape with name must exist in the TurtleScreen's shape dictionary.&#10;Initially there are the following polygon shapes:&#10;'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.&#10;To learn about how to deal with shapes see Screen-method register_shape.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape()&#10;'arrow'&#10;&gt;&gt;&gt; turtle.shape(&quot;turtle&quot;)&#10;&gt;&gt;&gt; turtle.shape()&#10;'turtle'">
				<Param name="self" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.shapesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.showturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.speed" func="yes">
			<Overload retVal="" descr="Return or set the turtle's speed.&#10;&#10;Optional argument:&#10;speed -- an integer in the range 0..10 or a speedstring (see below)&#10;&#10;Set the turtle's speed to an integer value in the range 0 .. 10.&#10;If no argument is given: return current speed.&#10;&#10;If input is a number greater than 10 or smaller than 0.5,&#10;speed is set to 0.&#10;Speedstrings  are mapped to speedvalues in the following way:&#10;    'fastest' :  0&#10;    'fast'    :  10&#10;    'normal'  :  6&#10;    'slow'    :  3&#10;    'slowest' :  1&#10;speeds from 1 to 10 enforce increasingly faster animation of&#10;line drawing and turtle turning.&#10;&#10;Attention:&#10;speed = 0 : *no* animation takes place. forward/back makes turtle jump&#10;and likewise left/right make the turtle turn instantly.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.speed(3)">
				<Param name="self" />
				<Param name="[speed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.st" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.stamp" func="yes">
			<Overload retVal="" descr='Stamp a copy of the turtleshape onto the canvas and return its id.&#10;&#10;No argument.&#10;&#10;Stamp a copy of the turtle shape onto the canvas at the current&#10;turtle position. Return a stamp_id for that stamp, which can be&#10;used to delete it by calling clearstamp(stamp_id).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; turtle.stamp()&#10;13&#10;&gt;&gt;&gt; turtle.fd(50)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.tilt" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape by angle.&#10;&#10;Argument:&#10;angle - a number&#10;&#10;Rotate the turtleshape by angle from its current tilt-angle,&#10;but do NOT change the turtle's heading (direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.tiltangle" func="yes">
			<Overload retVal="" descr='Return the current tilt-angle.&#10;&#10;No argument.&#10;&#10;Return the current tilt-angle, i. e. the angle between the&#10;orientation of the turtleshape and the heading of the turtle&#10;(its direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape("circle")&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(45)&#10;&gt;&gt;&gt; turtle.tiltangle()'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.towards" func="yes">
			<Overload retVal="" descr="Return the angle of the line from the turtle's position to (x, y).&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Return the angle, between the line from turtle-position to position&#10;specified by x, y and the turtle's start orientation. (Depends on&#10;modes - &quot;standard&quot; or &quot;logo&quot;)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(10.00, 10.00)&#10;&gt;&gt;&gt; turtle.towards(0,0)&#10;225.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.tracer" func="yes">
			<Overload retVal="" descr="Turns turtle animation on/off and set delay for update drawings.&#10;&#10;Optional arguments:&#10;n -- nonnegative  integer&#10;delay -- nonnegative  integer&#10;&#10;If n is given, only each n-th regular screen update is really performed.&#10;(Can be used to accelerate the drawing of complex graphics.)&#10;Second arguments sets delay value (see RawTurtle.delay())&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.tracer(8, 25)&#10;&gt;&gt;&gt; dist = 2&#10;&gt;&gt;&gt; for i in range(200):&#10;...     turtle.fd(dist)&#10;...     turtle.rt(90)&#10;...     dist += 2">
				<Param name="self" />
				<Param name="[flag=None" />
				<Param name="[delay=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.turtlesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.undo" func="yes">
			<Overload retVal="" descr="undo (repeatedly) the last turtle action.&#10;&#10;No argument.&#10;&#10;undo (repeatedly) the last turtle action.&#10;Number of available undo actions is determined by the size of&#10;the undobuffer.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(4):&#10;...     turtle.fd(50); turtle.lt(80)&#10;...&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.undo()&#10;...">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.undobufferentries" func="yes">
			<Overload retVal="" descr="Return count of entries in the undobuffer.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; while undobufferentries():&#10;...     undo()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.up" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.width" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.window_height" func="yes">
			<Overload retVal="" descr="Return the height of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_height()&#10;480">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.window_width" func="yes">
			<Overload retVal="" descr="Returns the width of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_width()&#10;640">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.write" func="yes">
			<Overload retVal="" descr="Write text at the current turtle position.&#10;&#10;Arguments:&#10;arg -- info, which is to be written to the TurtleScreen&#10;move (optional) -- True/False&#10;align (optional) -- one of the strings &quot;left&quot;, &quot;center&quot; or right&quot;&#10;font (optional) -- a triple (fontname, fontsize, fonttype)&#10;&#10;Write text - the string representation of arg - at the current&#10;turtle position according to align (&quot;left&quot;, &quot;center&quot; or right&quot;)&#10;and with the given font.&#10;If move is True, the pen is moved to the bottom-right corner&#10;of the text. By default, move is False.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.write('Home = ', True, align=&quot;center&quot;)&#10;&gt;&gt;&gt; turtle.write((0,0), True)">
				<Param name="self" />
				<Param name="arg" />
				<Param name="[move=False" />
				<Param name="[align=left" />
				<Param name="[font=('Arial', 8, 'normal')]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.xcor" func="yes">
			<Overload retVal="" descr="Return the turtle's x coordinate.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.xcor()&#10;50.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Pen.ycor" func="yes">
			<Overload retVal="" descr="Return the turtle's y coordinate&#10;---&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.ycor()&#10;86.6025403784">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen" func="yes">
			<Overload retVal="" descr="Animation part of the RawTurtle.&#10;Puts RawTurtle upon a TurtleScreen and provides tools for&#10;its animation.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.DEFAULT_ANGLEORIENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.DEFAULT_MODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.START_ORIENTATION" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.back" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.backward" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.begin_fill" func="yes">
			<Overload retVal="" descr="Called just before drawing a shape to be filled.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.begin_poly" func="yes">
			<Overload retVal="" descr="Start recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Start recording the vertices of a polygon. Current turtle position&#10;is first point of polygon.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.bk" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.circle" func="yes">
			<Overload retVal="" descr="Draw a circle with given radius.&#10;&#10;Arguments:&#10;radius -- a number&#10;extent (optional) -- a number&#10;steps (optional) -- an integer&#10;&#10;Draw a circle with given radius. The center is radius units left&#10;of the turtle; extent - an angle - determines which part of the&#10;circle is drawn. If extent is not given, draw the entire circle.&#10;If extent is not a full circle, one endpoint of the arc is the&#10;current pen position. Draw the arc in counterclockwise direction&#10;if radius is positive, otherwise in clockwise direction. Finally&#10;the direction of the turtle is changed by the amount of extent.&#10;&#10;As the circle is approximated by an inscribed regular polygon,&#10;steps determines the number of steps to use. If not given,&#10;it will be calculated automatically. Maybe used to draw regular&#10;polygons.&#10;&#10;call: circle(radius)                  # full circle&#10;--or: circle(radius, extent)          # arc&#10;--or: circle(radius, extent, steps)&#10;--or: circle(radius, steps=6)         # 6-sided polygon&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.circle(50)&#10;&gt;&gt;&gt; turtle.circle(120, 180)  # semicircle">
				<Param name="self" />
				<Param name="radius" />
				<Param name="[extent=None" />
				<Param name="[steps=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.clear" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings from the screen. Do not move turtle.&#10;&#10;No arguments.&#10;&#10;Delete the turtle's drawings from the screen. Do not move turtle.&#10;State and position of the turtle as well as drawings of other&#10;turtles are not affected.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.clear()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.clearstamp" func="yes">
			<Overload retVal="" descr='Delete stamp with given stampid&#10;&#10;Argument:&#10;stampid - an integer, must be return value of previous stamp() call.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; astamp = turtle.stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.clearstamp(astamp)'>
				<Param name="self" />
				<Param name="stampid" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.clearstamps" func="yes">
			<Overload retVal="" descr="Delete all or first/last n of turtle's stamps.&#10;&#10;Optional argument:&#10;n -- an integer&#10;&#10;If n is None, delete all of pen's stamps,&#10;else if n &gt; 0 delete first n stamps&#10;else if n &lt; 0 delete last n stamps.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.stamp(); turtle.fd(30)&#10;...&#10;&gt;&gt;&gt; turtle.clearstamps(2)&#10;&gt;&gt;&gt; turtle.clearstamps(-2)&#10;&gt;&gt;&gt; turtle.clearstamps()">
				<Param name="self" />
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.clone" func="yes">
			<Overload retVal="" descr="Create and return a clone of the turtle.&#10;&#10;No argument.&#10;&#10;Create and return a clone of the turtle with same position, heading&#10;and turtle properties.&#10;&#10;Example (for a Turtle instance named mick):&#10;mick = Turtle()&#10;joe = mick.clone()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.color" func="yes">
			<Overload retVal="" descr="Return or set the pencolor and fillcolor.&#10;&#10;Arguments:&#10;Several input formats are allowed.&#10;They use 0, 1, 2, or 3 arguments as follows:&#10;&#10;color()&#10;    Return the current pencolor and the current fillcolor&#10;    as a pair of color specification strings as are returned&#10;    by pencolor and fillcolor.&#10;color(colorstring), color((r,g,b)), color(r,g,b)&#10;    inputs as in pencolor, set both, fillcolor and pencolor,&#10;    to the given value.&#10;color(colorstring1, colorstring2),&#10;color((r1,g1,b1), (r2,g2,b2))&#10;    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)&#10;    and analogously, if the other input format is used.&#10;&#10;If turtleshape is a polygon, outline and interior of that polygon&#10;is drawn with the newly set colors.&#10;For mor info see: pencolor, fillcolor&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color('red', 'green')&#10;&gt;&gt;&gt; turtle.color()&#10;('red', 'green')&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))&#10;&gt;&gt;&gt; color()&#10;('#285078', '#a0c8f0')">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.degrees" func="yes">
			<Overload retVal="" descr="Set angle measurement units to degrees.&#10;&#10;Optional argument:&#10;fullcircle -  a number&#10;&#10;Set angle measurement units, i. e. set number&#10;of 'degrees' for a full circle. Dafault value is&#10;360 degrees.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&#10;Change angle measurement unit to grad (also known as gon,&#10;grade, or gradian and equals 1/100-th of the right angle.)&#10;&gt;&gt;&gt; turtle.degrees(400.0)&#10;&gt;&gt;&gt; turtle.heading()&#10;100">
				<Param name="self" />
				<Param name="[fullcircle=360.0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.distance" func="yes">
			<Overload retVal="" descr="Return the distance from the turtle to (x,y) in turtle step units.&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.distance(30,40)&#10;50.0&#10;&gt;&gt;&gt; pen = Turtle()&#10;&gt;&gt;&gt; pen.forward(77)&#10;&gt;&gt;&gt; turtle.distance(pen)&#10;77.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.dot" func="yes">
			<Overload retVal="" descr='Draw a dot with diameter size, using color.&#10;&#10;Optional arguments:&#10;size -- an integer &gt;= 1 (if given)&#10;color -- a colorstring or a numeric color tuple&#10;&#10;Draw a circular dot with diameter size, using color.&#10;If size is not given, the maximum of pensize+4 and 2*pensize is used.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.dot()&#10;&gt;&gt;&gt; turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)'>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.down" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.end_fill" func="yes">
			<Overload retVal="" descr="Fill the shape drawn after the call begin_fill().&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.end_poly" func="yes">
			<Overload retVal="" descr="Stop recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Stop recording the vertices of a polygon. Current turtle position is&#10;last point of polygon. This will be connected with the first point.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.end_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.fd" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.fill" func="yes">
			<Overload retVal="" descr="Call fill(True) before drawing a shape to fill, fill(False) when done.&#10;&#10;Optional argument:&#10;flag -- True/False (or 1/0 respectively)&#10;&#10;Call fill(True) before drawing the shape you want to fill,&#10;and  fill(False) when done.&#10;When used without argument: return fillstate (True if filling,&#10;False else)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fill(True)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.fill(False)">
				<Param name="self" />
				<Param name="[flag=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.fillcolor" func="yes">
			<Overload retVal="" descr="Return or set the fillcolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - fillcolor()&#10;    Return the current fillcolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - fillcolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - fillcolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - fillcolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the interior of that polygon is drawn&#10;with the newly set fillcolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fillcolor('violet')&#10;&gt;&gt;&gt; col = turtle.pencolor()&#10;&gt;&gt;&gt; turtle.fillcolor(col)&#10;&gt;&gt;&gt; turtle.fillcolor(0, .5, 0)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.forward" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.get_poly" func="yes">
			<Overload retVal="" descr='Return the lastly recorded polygon.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; p = turtle.get_poly()&#10;&gt;&gt;&gt; turtle.register_shape("myFavouriteShape", p)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.getpen" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.getscreen" func="yes">
			<Overload retVal="" descr='Return the TurtleScreen object, the turtle is drawing  on.&#10;&#10;No argument.&#10;&#10;Return the TurtleScreen object, the turtle is drawing  on.&#10;So TurtleScreen-methods can be called for that object.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; ts = turtle.getscreen()&#10;&gt;&gt;&gt; ts&#10;&lt;turtle.TurtleScreen object at 0x0106B770&gt;&#10;&gt;&gt;&gt; ts.bgcolor("pink")'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.getturtle" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.goto" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.heading" func="yes">
			<Overload retVal="" descr="Return the turtle's current heading.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(67)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.hideturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.home" func="yes">
			<Overload retVal="" descr="Move turtle to the origin - coordinates (0,0).&#10;&#10;No arguments.&#10;&#10;Move turtle to the origin - coordinates (0,0) and set its&#10;heading to its start-orientation (which depends on mode).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.home()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.ht" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.isdown" func="yes">
			<Overload retVal="" descr="Return True if pen is down, False if it's up.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.isdown()&#10;False&#10;&gt;&gt;&gt; turtle.pendown()&#10;&gt;&gt;&gt; turtle.isdown()&#10;True">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.isvisible" func="yes">
			<Overload retVal="" descr="Return True if the Turtle is shown, False if it's hidden.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; print turtle.isvisible():&#10;False">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.left" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.lt" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.onclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun --  a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;add --  True or False. If True, new binding will be added, otherwise&#10;        it will replace a former binding.&#10;&#10;Example for the anonymous turtle, i. e. the procedural way:&#10;&#10;&gt;&gt;&gt; def turn(x, y):&#10;...     left(360)&#10;...&#10;&gt;&gt;&gt; onclick(turn)  # Now clicking into the turtle will turn it.&#10;&gt;&gt;&gt; onclick(None)  # event-binding will be removed">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.ondrag" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-move event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;       the coordinates of the clicked point on the canvas.&#10;num -- number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Every sequence of mouse-move-events on a turtle is preceded by a&#10;mouse-click event on that turtle.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.ondrag(turtle.goto)&#10;&#10;Subsequently clicking and dragging a Turtle will move it&#10;across the screen thereby producing handdrawings (if pen is&#10;down).">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.onrelease" func="yes">
			<Overload retVal="" descr='Bind fun to mouse-button-release event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Example (for a MyTurtle instance named joe):&#10;&gt;&gt;&gt; class MyTurtle(Turtle):&#10;...     def glow(self,x,y):&#10;...             self.fillcolor("red")&#10;...     def unglow(self,x,y):&#10;...             self.fillcolor("")&#10;...&#10;&gt;&gt;&gt; joe = MyTurtle()&#10;&gt;&gt;&gt; joe.onclick(joe.glow)&#10;&gt;&gt;&gt; joe.onrelease(joe.unglow)&#10;&#10;Clicking on joe turns fillcolor red, unclicking turns it to&#10;transparent.'>
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pd" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pen" func="yes">
			<Overload retVal="" descr="Return or set the pen's attributes.&#10;&#10;Arguments:&#10;    pen -- a dictionary with some or all of the below listed keys.&#10;    **pendict -- one or more keyword-arguments with the below&#10;                 listed keys as keywords.&#10;&#10;Return or set the pen's attributes in a 'pen-dictionary'&#10;with the following key/value pairs:&#10;   &quot;shown&quot;      :   True/False&#10;   &quot;pendown&quot;    :   True/False&#10;   &quot;pencolor&quot;   :   color-string or color-tuple&#10;   &quot;fillcolor&quot;  :   color-string or color-tuple&#10;   &quot;pensize&quot;    :   positive number&#10;   &quot;speed&quot;      :   number in range 0..10&#10;   &quot;resizemode&quot; :   &quot;auto&quot; or &quot;user&quot; or &quot;noresize&quot;&#10;   &quot;stretchfactor&quot;: (positive number, positive number)&#10;   &quot;outline&quot;    :   positive number&#10;   &quot;tilt&quot;       :   number&#10;&#10;This dictionary can be used as argument for a subsequent&#10;pen()-call to restore the former pen-state. Moreover one&#10;or more of these attributes can be provided as keyword-arguments.&#10;This can be used to set several pen attributes in one statement.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pen(fillcolor=&quot;black&quot;, pencolor=&quot;red&quot;, pensize=10)&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; penstate=turtle.pen()&#10;&gt;&gt;&gt; turtle.color(&quot;yellow&quot;,&quot;&quot;)&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; p.pen(penstate, fillcolor=&quot;green&quot;)&#10;&gt;&gt;&gt; p.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',&#10;'stretchfactor': (1,1), 'speed': 3}">
				<Param name="self" />
				<Param name="[pen=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pencolor" func="yes">
			<Overload retVal="" descr="Return or set the pencolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - pencolor()&#10;    Return the current pencolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - pencolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - pencolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - pencolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the outline of that polygon is drawn&#10;with the newly set pencolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pencolor('brown')&#10;&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)&#10;&gt;&gt;&gt; turtle.pencolor(tup)&#10;&gt;&gt;&gt; turtle.pencolor()&#10;'#33cc8c'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pendown" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pensize" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.penup" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pos" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.position" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.pu" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.radians" func="yes">
			<Overload retVal="" descr="Set the angle measurement units to radians.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&gt;&gt;&gt; turtle.radians()&#10;&gt;&gt;&gt; turtle.heading()&#10;1.5707963267948966">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.reset" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings and restore its default values.&#10;&#10;        No argument.&#10;,&#10;        Delete the turtle's drawings from the screen, re-center the turtle&#10;        and set variables to the default values.&#10;&#10;        Example (for a Turtle instance named turtle):&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,-22.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        100.0&#10;        &gt;&gt;&gt; turtle.reset()&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,0.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        0.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.resizemode" func="yes">
			<Overload retVal="" descr="Set resizemode to one of the values: &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;.&#10;&#10;(Optional) Argument:&#10;rmode -- one of the strings &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;&#10;&#10;Different resizemodes have the following effects:&#10;  - &quot;auto&quot; adapts the appearance of the turtle&#10;           corresponding to the value of pensize.&#10;  - &quot;user&quot; adapts the appearance of the turtle according to the&#10;           values of stretchfactor and outlinewidth (outline),&#10;           which are set by shapesize()&#10;  - &quot;noresize&quot; no adaption of the turtle's appearance takes place.&#10;If no argument is given, return current resizemode.&#10;resizemode(&quot;user&quot;) is called by a call of shapesize with arguments.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;noresize&quot;)&#10;&gt;&gt;&gt; turtle.resizemode()&#10;'noresize'">
				<Param name="self" />
				<Param name="[rmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.right" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.rt" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.seth" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.setheading" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.setpos" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.setposition" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.settiltangle" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape to point in the specified direction&#10;&#10;Optional argument:&#10;angle -- number&#10;&#10;Rotate the turtleshape to point in the direction specified by angle,&#10;regardless of its current tilt-angle. DO NOT change the turtle's&#10;heading (direction of movement).&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.settiltangle(45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.settiltangle(-45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.setundobuffer" func="yes">
			<Overload retVal="" descr="Set or disable undobuffer.&#10;&#10;Argument:&#10;size -- an integer or None&#10;&#10;If size is an integer an empty undobuffer of given size is installed.&#10;Size gives the maximum number of turtle-actions that can be undone&#10;by the undo() function.&#10;If size is None, no undobuffer is present.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setundobuffer(42)">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.setx" func="yes">
			<Overload retVal="" descr="Set the turtle's first coordinate to x&#10;&#10;Argument:&#10;x -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, leave second coordinate&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 240.00)&#10;&gt;&gt;&gt; turtle.setx(10)&#10;&gt;&gt;&gt; turtle.position()&#10;(10.00, 240.00)">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.sety" func="yes">
			<Overload retVal="" descr="Set the turtle's second coordinate to y&#10;&#10;Argument:&#10;y -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, second coordinate remains&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 40.00)&#10;&gt;&gt;&gt; turtle.sety(-10)&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, -10.00)">
				<Param name="self" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.shape" func="yes">
			<Overload retVal="" descr="Set turtle shape to shape with given name / return current shapename.&#10;&#10;Optional argument:&#10;name -- a string, which is a valid shapename&#10;&#10;Set turtle shape to shape with given name or, if name is not given,&#10;return name of current shape.&#10;Shape with name must exist in the TurtleScreen's shape dictionary.&#10;Initially there are the following polygon shapes:&#10;'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.&#10;To learn about how to deal with shapes see Screen-method register_shape.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape()&#10;'arrow'&#10;&gt;&gt;&gt; turtle.shape(&quot;turtle&quot;)&#10;&gt;&gt;&gt; turtle.shape()&#10;'turtle'">
				<Param name="self" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.shapesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.showturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.speed" func="yes">
			<Overload retVal="" descr="Return or set the turtle's speed.&#10;&#10;Optional argument:&#10;speed -- an integer in the range 0..10 or a speedstring (see below)&#10;&#10;Set the turtle's speed to an integer value in the range 0 .. 10.&#10;If no argument is given: return current speed.&#10;&#10;If input is a number greater than 10 or smaller than 0.5,&#10;speed is set to 0.&#10;Speedstrings  are mapped to speedvalues in the following way:&#10;    'fastest' :  0&#10;    'fast'    :  10&#10;    'normal'  :  6&#10;    'slow'    :  3&#10;    'slowest' :  1&#10;speeds from 1 to 10 enforce increasingly faster animation of&#10;line drawing and turtle turning.&#10;&#10;Attention:&#10;speed = 0 : *no* animation takes place. forward/back makes turtle jump&#10;and likewise left/right make the turtle turn instantly.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.speed(3)">
				<Param name="self" />
				<Param name="[speed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.st" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.stamp" func="yes">
			<Overload retVal="" descr='Stamp a copy of the turtleshape onto the canvas and return its id.&#10;&#10;No argument.&#10;&#10;Stamp a copy of the turtle shape onto the canvas at the current&#10;turtle position. Return a stamp_id for that stamp, which can be&#10;used to delete it by calling clearstamp(stamp_id).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; turtle.stamp()&#10;13&#10;&gt;&gt;&gt; turtle.fd(50)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.tilt" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape by angle.&#10;&#10;Argument:&#10;angle - a number&#10;&#10;Rotate the turtleshape by angle from its current tilt-angle,&#10;but do NOT change the turtle's heading (direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.tiltangle" func="yes">
			<Overload retVal="" descr='Return the current tilt-angle.&#10;&#10;No argument.&#10;&#10;Return the current tilt-angle, i. e. the angle between the&#10;orientation of the turtleshape and the heading of the turtle&#10;(its direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape("circle")&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(45)&#10;&gt;&gt;&gt; turtle.tiltangle()'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.towards" func="yes">
			<Overload retVal="" descr="Return the angle of the line from the turtle's position to (x, y).&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Return the angle, between the line from turtle-position to position&#10;specified by x, y and the turtle's start orientation. (Depends on&#10;modes - &quot;standard&quot; or &quot;logo&quot;)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(10.00, 10.00)&#10;&gt;&gt;&gt; turtle.towards(0,0)&#10;225.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.tracer" func="yes">
			<Overload retVal="" descr="Turns turtle animation on/off and set delay for update drawings.&#10;&#10;Optional arguments:&#10;n -- nonnegative  integer&#10;delay -- nonnegative  integer&#10;&#10;If n is given, only each n-th regular screen update is really performed.&#10;(Can be used to accelerate the drawing of complex graphics.)&#10;Second arguments sets delay value (see RawTurtle.delay())&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.tracer(8, 25)&#10;&gt;&gt;&gt; dist = 2&#10;&gt;&gt;&gt; for i in range(200):&#10;...     turtle.fd(dist)&#10;...     turtle.rt(90)&#10;...     dist += 2">
				<Param name="self" />
				<Param name="[flag=None" />
				<Param name="[delay=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.turtlesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.undo" func="yes">
			<Overload retVal="" descr="undo (repeatedly) the last turtle action.&#10;&#10;No argument.&#10;&#10;undo (repeatedly) the last turtle action.&#10;Number of available undo actions is determined by the size of&#10;the undobuffer.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(4):&#10;...     turtle.fd(50); turtle.lt(80)&#10;...&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.undo()&#10;...">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.undobufferentries" func="yes">
			<Overload retVal="" descr="Return count of entries in the undobuffer.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; while undobufferentries():&#10;...     undo()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.up" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.width" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.window_height" func="yes">
			<Overload retVal="" descr="Return the height of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_height()&#10;480">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.window_width" func="yes">
			<Overload retVal="" descr="Returns the width of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_width()&#10;640">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.write" func="yes">
			<Overload retVal="" descr="Write text at the current turtle position.&#10;&#10;Arguments:&#10;arg -- info, which is to be written to the TurtleScreen&#10;move (optional) -- True/False&#10;align (optional) -- one of the strings &quot;left&quot;, &quot;center&quot; or right&quot;&#10;font (optional) -- a triple (fontname, fontsize, fonttype)&#10;&#10;Write text - the string representation of arg - at the current&#10;turtle position according to align (&quot;left&quot;, &quot;center&quot; or right&quot;)&#10;and with the given font.&#10;If move is True, the pen is moved to the bottom-right corner&#10;of the text. By default, move is False.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.write('Home = ', True, align=&quot;center&quot;)&#10;&gt;&gt;&gt; turtle.write((0,0), True)">
				<Param name="self" />
				<Param name="arg" />
				<Param name="[move=False" />
				<Param name="[align=left" />
				<Param name="[font=('Arial', 8, 'normal')]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.xcor" func="yes">
			<Overload retVal="" descr="Return the turtle's x coordinate.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.xcor()&#10;50.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawPen.ycor" func="yes">
			<Overload retVal="" descr="Return the turtle's y coordinate&#10;---&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.ycor()&#10;86.6025403784">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle" func="yes">
			<Overload retVal="" descr="Animation part of the RawTurtle.&#10;Puts RawTurtle upon a TurtleScreen and provides tools for&#10;its animation.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.DEFAULT_ANGLEORIENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.DEFAULT_MODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.START_ORIENTATION" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.back" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.backward" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.begin_fill" func="yes">
			<Overload retVal="" descr="Called just before drawing a shape to be filled.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.begin_poly" func="yes">
			<Overload retVal="" descr="Start recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Start recording the vertices of a polygon. Current turtle position&#10;is first point of polygon.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.bk" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.circle" func="yes">
			<Overload retVal="" descr="Draw a circle with given radius.&#10;&#10;Arguments:&#10;radius -- a number&#10;extent (optional) -- a number&#10;steps (optional) -- an integer&#10;&#10;Draw a circle with given radius. The center is radius units left&#10;of the turtle; extent - an angle - determines which part of the&#10;circle is drawn. If extent is not given, draw the entire circle.&#10;If extent is not a full circle, one endpoint of the arc is the&#10;current pen position. Draw the arc in counterclockwise direction&#10;if radius is positive, otherwise in clockwise direction. Finally&#10;the direction of the turtle is changed by the amount of extent.&#10;&#10;As the circle is approximated by an inscribed regular polygon,&#10;steps determines the number of steps to use. If not given,&#10;it will be calculated automatically. Maybe used to draw regular&#10;polygons.&#10;&#10;call: circle(radius)                  # full circle&#10;--or: circle(radius, extent)          # arc&#10;--or: circle(radius, extent, steps)&#10;--or: circle(radius, steps=6)         # 6-sided polygon&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.circle(50)&#10;&gt;&gt;&gt; turtle.circle(120, 180)  # semicircle">
				<Param name="self" />
				<Param name="radius" />
				<Param name="[extent=None" />
				<Param name="[steps=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.clear" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings from the screen. Do not move turtle.&#10;&#10;No arguments.&#10;&#10;Delete the turtle's drawings from the screen. Do not move turtle.&#10;State and position of the turtle as well as drawings of other&#10;turtles are not affected.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.clear()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.clearstamp" func="yes">
			<Overload retVal="" descr='Delete stamp with given stampid&#10;&#10;Argument:&#10;stampid - an integer, must be return value of previous stamp() call.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; astamp = turtle.stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.clearstamp(astamp)'>
				<Param name="self" />
				<Param name="stampid" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.clearstamps" func="yes">
			<Overload retVal="" descr="Delete all or first/last n of turtle's stamps.&#10;&#10;Optional argument:&#10;n -- an integer&#10;&#10;If n is None, delete all of pen's stamps,&#10;else if n &gt; 0 delete first n stamps&#10;else if n &lt; 0 delete last n stamps.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.stamp(); turtle.fd(30)&#10;...&#10;&gt;&gt;&gt; turtle.clearstamps(2)&#10;&gt;&gt;&gt; turtle.clearstamps(-2)&#10;&gt;&gt;&gt; turtle.clearstamps()">
				<Param name="self" />
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.clone" func="yes">
			<Overload retVal="" descr="Create and return a clone of the turtle.&#10;&#10;No argument.&#10;&#10;Create and return a clone of the turtle with same position, heading&#10;and turtle properties.&#10;&#10;Example (for a Turtle instance named mick):&#10;mick = Turtle()&#10;joe = mick.clone()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.color" func="yes">
			<Overload retVal="" descr="Return or set the pencolor and fillcolor.&#10;&#10;Arguments:&#10;Several input formats are allowed.&#10;They use 0, 1, 2, or 3 arguments as follows:&#10;&#10;color()&#10;    Return the current pencolor and the current fillcolor&#10;    as a pair of color specification strings as are returned&#10;    by pencolor and fillcolor.&#10;color(colorstring), color((r,g,b)), color(r,g,b)&#10;    inputs as in pencolor, set both, fillcolor and pencolor,&#10;    to the given value.&#10;color(colorstring1, colorstring2),&#10;color((r1,g1,b1), (r2,g2,b2))&#10;    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)&#10;    and analogously, if the other input format is used.&#10;&#10;If turtleshape is a polygon, outline and interior of that polygon&#10;is drawn with the newly set colors.&#10;For mor info see: pencolor, fillcolor&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color('red', 'green')&#10;&gt;&gt;&gt; turtle.color()&#10;('red', 'green')&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))&#10;&gt;&gt;&gt; color()&#10;('#285078', '#a0c8f0')">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.degrees" func="yes">
			<Overload retVal="" descr="Set angle measurement units to degrees.&#10;&#10;Optional argument:&#10;fullcircle -  a number&#10;&#10;Set angle measurement units, i. e. set number&#10;of 'degrees' for a full circle. Dafault value is&#10;360 degrees.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&#10;Change angle measurement unit to grad (also known as gon,&#10;grade, or gradian and equals 1/100-th of the right angle.)&#10;&gt;&gt;&gt; turtle.degrees(400.0)&#10;&gt;&gt;&gt; turtle.heading()&#10;100">
				<Param name="self" />
				<Param name="[fullcircle=360.0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.distance" func="yes">
			<Overload retVal="" descr="Return the distance from the turtle to (x,y) in turtle step units.&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.distance(30,40)&#10;50.0&#10;&gt;&gt;&gt; pen = Turtle()&#10;&gt;&gt;&gt; pen.forward(77)&#10;&gt;&gt;&gt; turtle.distance(pen)&#10;77.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.dot" func="yes">
			<Overload retVal="" descr='Draw a dot with diameter size, using color.&#10;&#10;Optional arguments:&#10;size -- an integer &gt;= 1 (if given)&#10;color -- a colorstring or a numeric color tuple&#10;&#10;Draw a circular dot with diameter size, using color.&#10;If size is not given, the maximum of pensize+4 and 2*pensize is used.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.dot()&#10;&gt;&gt;&gt; turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)'>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.down" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.end_fill" func="yes">
			<Overload retVal="" descr="Fill the shape drawn after the call begin_fill().&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.end_poly" func="yes">
			<Overload retVal="" descr="Stop recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Stop recording the vertices of a polygon. Current turtle position is&#10;last point of polygon. This will be connected with the first point.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.end_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.fd" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.fill" func="yes">
			<Overload retVal="" descr="Call fill(True) before drawing a shape to fill, fill(False) when done.&#10;&#10;Optional argument:&#10;flag -- True/False (or 1/0 respectively)&#10;&#10;Call fill(True) before drawing the shape you want to fill,&#10;and  fill(False) when done.&#10;When used without argument: return fillstate (True if filling,&#10;False else)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fill(True)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.fill(False)">
				<Param name="self" />
				<Param name="[flag=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.fillcolor" func="yes">
			<Overload retVal="" descr="Return or set the fillcolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - fillcolor()&#10;    Return the current fillcolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - fillcolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - fillcolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - fillcolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the interior of that polygon is drawn&#10;with the newly set fillcolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fillcolor('violet')&#10;&gt;&gt;&gt; col = turtle.pencolor()&#10;&gt;&gt;&gt; turtle.fillcolor(col)&#10;&gt;&gt;&gt; turtle.fillcolor(0, .5, 0)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.forward" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.get_poly" func="yes">
			<Overload retVal="" descr='Return the lastly recorded polygon.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; p = turtle.get_poly()&#10;&gt;&gt;&gt; turtle.register_shape("myFavouriteShape", p)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.getpen" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.getscreen" func="yes">
			<Overload retVal="" descr='Return the TurtleScreen object, the turtle is drawing  on.&#10;&#10;No argument.&#10;&#10;Return the TurtleScreen object, the turtle is drawing  on.&#10;So TurtleScreen-methods can be called for that object.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; ts = turtle.getscreen()&#10;&gt;&gt;&gt; ts&#10;&lt;turtle.TurtleScreen object at 0x0106B770&gt;&#10;&gt;&gt;&gt; ts.bgcolor("pink")'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.getturtle" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.goto" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.heading" func="yes">
			<Overload retVal="" descr="Return the turtle's current heading.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(67)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.hideturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.home" func="yes">
			<Overload retVal="" descr="Move turtle to the origin - coordinates (0,0).&#10;&#10;No arguments.&#10;&#10;Move turtle to the origin - coordinates (0,0) and set its&#10;heading to its start-orientation (which depends on mode).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.home()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.ht" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.isdown" func="yes">
			<Overload retVal="" descr="Return True if pen is down, False if it's up.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.isdown()&#10;False&#10;&gt;&gt;&gt; turtle.pendown()&#10;&gt;&gt;&gt; turtle.isdown()&#10;True">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.isvisible" func="yes">
			<Overload retVal="" descr="Return True if the Turtle is shown, False if it's hidden.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; print turtle.isvisible():&#10;False">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.left" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.lt" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.onclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun --  a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;add --  True or False. If True, new binding will be added, otherwise&#10;        it will replace a former binding.&#10;&#10;Example for the anonymous turtle, i. e. the procedural way:&#10;&#10;&gt;&gt;&gt; def turn(x, y):&#10;...     left(360)&#10;...&#10;&gt;&gt;&gt; onclick(turn)  # Now clicking into the turtle will turn it.&#10;&gt;&gt;&gt; onclick(None)  # event-binding will be removed">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.ondrag" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-move event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;       the coordinates of the clicked point on the canvas.&#10;num -- number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Every sequence of mouse-move-events on a turtle is preceded by a&#10;mouse-click event on that turtle.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.ondrag(turtle.goto)&#10;&#10;Subsequently clicking and dragging a Turtle will move it&#10;across the screen thereby producing handdrawings (if pen is&#10;down).">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.onrelease" func="yes">
			<Overload retVal="" descr='Bind fun to mouse-button-release event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Example (for a MyTurtle instance named joe):&#10;&gt;&gt;&gt; class MyTurtle(Turtle):&#10;...     def glow(self,x,y):&#10;...             self.fillcolor("red")&#10;...     def unglow(self,x,y):&#10;...             self.fillcolor("")&#10;...&#10;&gt;&gt;&gt; joe = MyTurtle()&#10;&gt;&gt;&gt; joe.onclick(joe.glow)&#10;&gt;&gt;&gt; joe.onrelease(joe.unglow)&#10;&#10;Clicking on joe turns fillcolor red, unclicking turns it to&#10;transparent.'>
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pd" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pen" func="yes">
			<Overload retVal="" descr="Return or set the pen's attributes.&#10;&#10;Arguments:&#10;    pen -- a dictionary with some or all of the below listed keys.&#10;    **pendict -- one or more keyword-arguments with the below&#10;                 listed keys as keywords.&#10;&#10;Return or set the pen's attributes in a 'pen-dictionary'&#10;with the following key/value pairs:&#10;   &quot;shown&quot;      :   True/False&#10;   &quot;pendown&quot;    :   True/False&#10;   &quot;pencolor&quot;   :   color-string or color-tuple&#10;   &quot;fillcolor&quot;  :   color-string or color-tuple&#10;   &quot;pensize&quot;    :   positive number&#10;   &quot;speed&quot;      :   number in range 0..10&#10;   &quot;resizemode&quot; :   &quot;auto&quot; or &quot;user&quot; or &quot;noresize&quot;&#10;   &quot;stretchfactor&quot;: (positive number, positive number)&#10;   &quot;outline&quot;    :   positive number&#10;   &quot;tilt&quot;       :   number&#10;&#10;This dictionary can be used as argument for a subsequent&#10;pen()-call to restore the former pen-state. Moreover one&#10;or more of these attributes can be provided as keyword-arguments.&#10;This can be used to set several pen attributes in one statement.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pen(fillcolor=&quot;black&quot;, pencolor=&quot;red&quot;, pensize=10)&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; penstate=turtle.pen()&#10;&gt;&gt;&gt; turtle.color(&quot;yellow&quot;,&quot;&quot;)&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; p.pen(penstate, fillcolor=&quot;green&quot;)&#10;&gt;&gt;&gt; p.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',&#10;'stretchfactor': (1,1), 'speed': 3}">
				<Param name="self" />
				<Param name="[pen=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pencolor" func="yes">
			<Overload retVal="" descr="Return or set the pencolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - pencolor()&#10;    Return the current pencolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - pencolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - pencolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - pencolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the outline of that polygon is drawn&#10;with the newly set pencolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pencolor('brown')&#10;&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)&#10;&gt;&gt;&gt; turtle.pencolor(tup)&#10;&gt;&gt;&gt; turtle.pencolor()&#10;'#33cc8c'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pendown" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pensize" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.penup" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pos" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.position" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.pu" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.radians" func="yes">
			<Overload retVal="" descr="Set the angle measurement units to radians.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&gt;&gt;&gt; turtle.radians()&#10;&gt;&gt;&gt; turtle.heading()&#10;1.5707963267948966">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.reset" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings and restore its default values.&#10;&#10;        No argument.&#10;,&#10;        Delete the turtle's drawings from the screen, re-center the turtle&#10;        and set variables to the default values.&#10;&#10;        Example (for a Turtle instance named turtle):&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,-22.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        100.0&#10;        &gt;&gt;&gt; turtle.reset()&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,0.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        0.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.resizemode" func="yes">
			<Overload retVal="" descr="Set resizemode to one of the values: &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;.&#10;&#10;(Optional) Argument:&#10;rmode -- one of the strings &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;&#10;&#10;Different resizemodes have the following effects:&#10;  - &quot;auto&quot; adapts the appearance of the turtle&#10;           corresponding to the value of pensize.&#10;  - &quot;user&quot; adapts the appearance of the turtle according to the&#10;           values of stretchfactor and outlinewidth (outline),&#10;           which are set by shapesize()&#10;  - &quot;noresize&quot; no adaption of the turtle's appearance takes place.&#10;If no argument is given, return current resizemode.&#10;resizemode(&quot;user&quot;) is called by a call of shapesize with arguments.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;noresize&quot;)&#10;&gt;&gt;&gt; turtle.resizemode()&#10;'noresize'">
				<Param name="self" />
				<Param name="[rmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.right" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.rt" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.seth" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.setheading" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.setpos" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.setposition" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.settiltangle" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape to point in the specified direction&#10;&#10;Optional argument:&#10;angle -- number&#10;&#10;Rotate the turtleshape to point in the direction specified by angle,&#10;regardless of its current tilt-angle. DO NOT change the turtle's&#10;heading (direction of movement).&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.settiltangle(45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.settiltangle(-45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.setundobuffer" func="yes">
			<Overload retVal="" descr="Set or disable undobuffer.&#10;&#10;Argument:&#10;size -- an integer or None&#10;&#10;If size is an integer an empty undobuffer of given size is installed.&#10;Size gives the maximum number of turtle-actions that can be undone&#10;by the undo() function.&#10;If size is None, no undobuffer is present.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setundobuffer(42)">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.setx" func="yes">
			<Overload retVal="" descr="Set the turtle's first coordinate to x&#10;&#10;Argument:&#10;x -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, leave second coordinate&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 240.00)&#10;&gt;&gt;&gt; turtle.setx(10)&#10;&gt;&gt;&gt; turtle.position()&#10;(10.00, 240.00)">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.sety" func="yes">
			<Overload retVal="" descr="Set the turtle's second coordinate to y&#10;&#10;Argument:&#10;y -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, second coordinate remains&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 40.00)&#10;&gt;&gt;&gt; turtle.sety(-10)&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, -10.00)">
				<Param name="self" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.shape" func="yes">
			<Overload retVal="" descr="Set turtle shape to shape with given name / return current shapename.&#10;&#10;Optional argument:&#10;name -- a string, which is a valid shapename&#10;&#10;Set turtle shape to shape with given name or, if name is not given,&#10;return name of current shape.&#10;Shape with name must exist in the TurtleScreen's shape dictionary.&#10;Initially there are the following polygon shapes:&#10;'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.&#10;To learn about how to deal with shapes see Screen-method register_shape.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape()&#10;'arrow'&#10;&gt;&gt;&gt; turtle.shape(&quot;turtle&quot;)&#10;&gt;&gt;&gt; turtle.shape()&#10;'turtle'">
				<Param name="self" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.shapesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.showturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.speed" func="yes">
			<Overload retVal="" descr="Return or set the turtle's speed.&#10;&#10;Optional argument:&#10;speed -- an integer in the range 0..10 or a speedstring (see below)&#10;&#10;Set the turtle's speed to an integer value in the range 0 .. 10.&#10;If no argument is given: return current speed.&#10;&#10;If input is a number greater than 10 or smaller than 0.5,&#10;speed is set to 0.&#10;Speedstrings  are mapped to speedvalues in the following way:&#10;    'fastest' :  0&#10;    'fast'    :  10&#10;    'normal'  :  6&#10;    'slow'    :  3&#10;    'slowest' :  1&#10;speeds from 1 to 10 enforce increasingly faster animation of&#10;line drawing and turtle turning.&#10;&#10;Attention:&#10;speed = 0 : *no* animation takes place. forward/back makes turtle jump&#10;and likewise left/right make the turtle turn instantly.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.speed(3)">
				<Param name="self" />
				<Param name="[speed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.st" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.stamp" func="yes">
			<Overload retVal="" descr='Stamp a copy of the turtleshape onto the canvas and return its id.&#10;&#10;No argument.&#10;&#10;Stamp a copy of the turtle shape onto the canvas at the current&#10;turtle position. Return a stamp_id for that stamp, which can be&#10;used to delete it by calling clearstamp(stamp_id).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; turtle.stamp()&#10;13&#10;&gt;&gt;&gt; turtle.fd(50)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.tilt" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape by angle.&#10;&#10;Argument:&#10;angle - a number&#10;&#10;Rotate the turtleshape by angle from its current tilt-angle,&#10;but do NOT change the turtle's heading (direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.tiltangle" func="yes">
			<Overload retVal="" descr='Return the current tilt-angle.&#10;&#10;No argument.&#10;&#10;Return the current tilt-angle, i. e. the angle between the&#10;orientation of the turtleshape and the heading of the turtle&#10;(its direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape("circle")&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(45)&#10;&gt;&gt;&gt; turtle.tiltangle()'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.towards" func="yes">
			<Overload retVal="" descr="Return the angle of the line from the turtle's position to (x, y).&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Return the angle, between the line from turtle-position to position&#10;specified by x, y and the turtle's start orientation. (Depends on&#10;modes - &quot;standard&quot; or &quot;logo&quot;)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(10.00, 10.00)&#10;&gt;&gt;&gt; turtle.towards(0,0)&#10;225.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.tracer" func="yes">
			<Overload retVal="" descr="Turns turtle animation on/off and set delay for update drawings.&#10;&#10;Optional arguments:&#10;n -- nonnegative  integer&#10;delay -- nonnegative  integer&#10;&#10;If n is given, only each n-th regular screen update is really performed.&#10;(Can be used to accelerate the drawing of complex graphics.)&#10;Second arguments sets delay value (see RawTurtle.delay())&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.tracer(8, 25)&#10;&gt;&gt;&gt; dist = 2&#10;&gt;&gt;&gt; for i in range(200):&#10;...     turtle.fd(dist)&#10;...     turtle.rt(90)&#10;...     dist += 2">
				<Param name="self" />
				<Param name="[flag=None" />
				<Param name="[delay=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.turtlesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.undo" func="yes">
			<Overload retVal="" descr="undo (repeatedly) the last turtle action.&#10;&#10;No argument.&#10;&#10;undo (repeatedly) the last turtle action.&#10;Number of available undo actions is determined by the size of&#10;the undobuffer.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(4):&#10;...     turtle.fd(50); turtle.lt(80)&#10;...&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.undo()&#10;...">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.undobufferentries" func="yes">
			<Overload retVal="" descr="Return count of entries in the undobuffer.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; while undobufferentries():&#10;...     undo()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.up" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.width" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.window_height" func="yes">
			<Overload retVal="" descr="Return the height of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_height()&#10;480">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.window_width" func="yes">
			<Overload retVal="" descr="Returns the width of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_width()&#10;640">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.write" func="yes">
			<Overload retVal="" descr="Write text at the current turtle position.&#10;&#10;Arguments:&#10;arg -- info, which is to be written to the TurtleScreen&#10;move (optional) -- True/False&#10;align (optional) -- one of the strings &quot;left&quot;, &quot;center&quot; or right&quot;&#10;font (optional) -- a triple (fontname, fontsize, fonttype)&#10;&#10;Write text - the string representation of arg - at the current&#10;turtle position according to align (&quot;left&quot;, &quot;center&quot; or right&quot;)&#10;and with the given font.&#10;If move is True, the pen is moved to the bottom-right corner&#10;of the text. By default, move is False.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.write('Home = ', True, align=&quot;center&quot;)&#10;&gt;&gt;&gt; turtle.write((0,0), True)">
				<Param name="self" />
				<Param name="arg" />
				<Param name="[move=False" />
				<Param name="[align=left" />
				<Param name="[font=('Arial', 8, 'normal')]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.xcor" func="yes">
			<Overload retVal="" descr="Return the turtle's x coordinate.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.xcor()&#10;50.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.RawTurtle.ycor" func="yes">
			<Overload retVal="" descr="Return the turtle's y coordinate&#10;---&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.ycor()&#10;86.6025403784">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Screen" func="yes">
			<Overload retVal="" descr="Return the singleton screen object.&#10;If none exists at the moment, create a new one and return it,&#10;else return the existing one.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ScrolledCanvas" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Shape" func="yes">
			<Overload retVal="" descr='Data structure modeling shapes.&#10;&#10;attribute _type is one of "polygon", "image", "compound"&#10;attribute _data is - depending on _type a poygon-tuple,&#10;an image or a list constructed using the addcomponent method.'>
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Shape.addcomponent" func="yes">
			<Overload retVal="" descr='Add component to a shape of type compound.&#10;&#10;Arguments: poly is a polygon, i. e. a tuple of number pairs.&#10;fill is the fillcolor of the component,&#10;outline is the outline color of the component.&#10;&#10;call (for a Shapeobject namend s):&#10;--   s.addcomponent(((0,0), (10,10), (-10,10)), "red", "blue")&#10;&#10;Example:&#10;&gt;&gt;&gt; poly = ((0,0),(10,-5),(0,10),(-10,-5))&#10;&gt;&gt;&gt; s = Shape("compound")&#10;&gt;&gt;&gt; s.addcomponent(poly, "red", "blue")&#10;&gt;&gt;&gt; # .. add more components and then use register_shape()'>
				<Param name="self" />
				<Param name="poly" />
				<Param name="fill" />
				<Param name="[outline=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator" func="yes">
			<Overload retVal="" descr="Navigation part of the RawTurtle.&#10;Implements methods for turtle movement.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.DEFAULT_ANGLEORIENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.DEFAULT_MODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.START_ORIENTATION" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.back" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.backward" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.bk" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.circle" func="yes">
			<Overload retVal="" descr="Draw a circle with given radius.&#10;&#10;Arguments:&#10;radius -- a number&#10;extent (optional) -- a number&#10;steps (optional) -- an integer&#10;&#10;Draw a circle with given radius. The center is radius units left&#10;of the turtle; extent - an angle - determines which part of the&#10;circle is drawn. If extent is not given, draw the entire circle.&#10;If extent is not a full circle, one endpoint of the arc is the&#10;current pen position. Draw the arc in counterclockwise direction&#10;if radius is positive, otherwise in clockwise direction. Finally&#10;the direction of the turtle is changed by the amount of extent.&#10;&#10;As the circle is approximated by an inscribed regular polygon,&#10;steps determines the number of steps to use. If not given,&#10;it will be calculated automatically. Maybe used to draw regular&#10;polygons.&#10;&#10;call: circle(radius)                  # full circle&#10;--or: circle(radius, extent)          # arc&#10;--or: circle(radius, extent, steps)&#10;--or: circle(radius, steps=6)         # 6-sided polygon&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.circle(50)&#10;&gt;&gt;&gt; turtle.circle(120, 180)  # semicircle">
				<Param name="self" />
				<Param name="radius" />
				<Param name="[extent=None" />
				<Param name="[steps=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.degrees" func="yes">
			<Overload retVal="" descr="Set angle measurement units to degrees.&#10;&#10;Optional argument:&#10;fullcircle -  a number&#10;&#10;Set angle measurement units, i. e. set number&#10;of 'degrees' for a full circle. Dafault value is&#10;360 degrees.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&#10;Change angle measurement unit to grad (also known as gon,&#10;grade, or gradian and equals 1/100-th of the right angle.)&#10;&gt;&gt;&gt; turtle.degrees(400.0)&#10;&gt;&gt;&gt; turtle.heading()&#10;100">
				<Param name="self" />
				<Param name="[fullcircle=360.0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.distance" func="yes">
			<Overload retVal="" descr="Return the distance from the turtle to (x,y) in turtle step units.&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.distance(30,40)&#10;50.0&#10;&gt;&gt;&gt; pen = Turtle()&#10;&gt;&gt;&gt; pen.forward(77)&#10;&gt;&gt;&gt; turtle.distance(pen)&#10;77.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.fd" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.forward" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.goto" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.heading" func="yes">
			<Overload retVal="" descr="Return the turtle's current heading.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(67)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.home" func="yes">
			<Overload retVal="" descr="Move turtle to the origin - coordinates (0,0).&#10;&#10;No arguments.&#10;&#10;Move turtle to the origin - coordinates (0,0) and set its&#10;heading to its start-orientation (which depends on mode).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.home()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.left" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.lt" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.pos" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.position" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.radians" func="yes">
			<Overload retVal="" descr="Set the angle measurement units to radians.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&gt;&gt;&gt; turtle.radians()&#10;&gt;&gt;&gt; turtle.heading()&#10;1.5707963267948966">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.reset" func="yes">
			<Overload retVal="" descr="reset turtle to its initial values&#10;&#10;Will be overwritten by parent class">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.right" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.rt" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.seth" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.setheading" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.setpos" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.setposition" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.setx" func="yes">
			<Overload retVal="" descr="Set the turtle's first coordinate to x&#10;&#10;Argument:&#10;x -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, leave second coordinate&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 240.00)&#10;&gt;&gt;&gt; turtle.setx(10)&#10;&gt;&gt;&gt; turtle.position()&#10;(10.00, 240.00)">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.sety" func="yes">
			<Overload retVal="" descr="Set the turtle's second coordinate to y&#10;&#10;Argument:&#10;y -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, second coordinate remains&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 40.00)&#10;&gt;&gt;&gt; turtle.sety(-10)&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, -10.00)">
				<Param name="self" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.speed" func="yes">
			<Overload retVal="" descr="dummy method - to be overwritten by child class">
				<Param name="self" />
				<Param name="[s=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.towards" func="yes">
			<Overload retVal="" descr="Return the angle of the line from the turtle's position to (x, y).&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Return the angle, between the line from turtle-position to position&#10;specified by x, y and the turtle's start orientation. (Depends on&#10;modes - &quot;standard&quot; or &quot;logo&quot;)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(10.00, 10.00)&#10;&gt;&gt;&gt; turtle.towards(0,0)&#10;225.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.tracer" func="yes">
			<Overload retVal="" descr="dummy method - to be overwritten by child class">
				<Param name="self" />
				<Param name="[a=None" />
				<Param name="[b=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.xcor" func="yes">
			<Overload retVal="" descr="Return the turtle's x coordinate.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.xcor()&#10;50.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TNavigator.ycor" func="yes">
			<Overload retVal="" descr="Return the turtle's y coordinate&#10;---&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.ycor()&#10;86.6025403784">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen" func="yes">
			<Overload retVal="" descr="Drawing part of the RawTurtle.&#10;Implements drawing properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.color" func="yes">
			<Overload retVal="" descr="Return or set the pencolor and fillcolor.&#10;&#10;Arguments:&#10;Several input formats are allowed.&#10;They use 0, 1, 2, or 3 arguments as follows:&#10;&#10;color()&#10;    Return the current pencolor and the current fillcolor&#10;    as a pair of color specification strings as are returned&#10;    by pencolor and fillcolor.&#10;color(colorstring), color((r,g,b)), color(r,g,b)&#10;    inputs as in pencolor, set both, fillcolor and pencolor,&#10;    to the given value.&#10;color(colorstring1, colorstring2),&#10;color((r1,g1,b1), (r2,g2,b2))&#10;    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)&#10;    and analogously, if the other input format is used.&#10;&#10;If turtleshape is a polygon, outline and interior of that polygon&#10;is drawn with the newly set colors.&#10;For mor info see: pencolor, fillcolor&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color('red', 'green')&#10;&gt;&gt;&gt; turtle.color()&#10;('red', 'green')&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))&#10;&gt;&gt;&gt; color()&#10;('#285078', '#a0c8f0')">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.down" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.fillcolor" func="yes">
			<Overload retVal="" descr="Return or set the fillcolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - fillcolor()&#10;    Return the current fillcolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - fillcolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - fillcolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - fillcolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the interior of that polygon is drawn&#10;with the newly set fillcolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fillcolor('violet')&#10;&gt;&gt;&gt; col = turtle.pencolor()&#10;&gt;&gt;&gt; turtle.fillcolor(col)&#10;&gt;&gt;&gt; turtle.fillcolor(0, .5, 0)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.hideturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.ht" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.isdown" func="yes">
			<Overload retVal="" descr="Return True if pen is down, False if it's up.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.isdown()&#10;False&#10;&gt;&gt;&gt; turtle.pendown()&#10;&gt;&gt;&gt; turtle.isdown()&#10;True">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.isvisible" func="yes">
			<Overload retVal="" descr="Return True if the Turtle is shown, False if it's hidden.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; print turtle.isvisible():&#10;False">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.pd" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.pen" func="yes">
			<Overload retVal="" descr="Return or set the pen's attributes.&#10;&#10;Arguments:&#10;    pen -- a dictionary with some or all of the below listed keys.&#10;    **pendict -- one or more keyword-arguments with the below&#10;                 listed keys as keywords.&#10;&#10;Return or set the pen's attributes in a 'pen-dictionary'&#10;with the following key/value pairs:&#10;   &quot;shown&quot;      :   True/False&#10;   &quot;pendown&quot;    :   True/False&#10;   &quot;pencolor&quot;   :   color-string or color-tuple&#10;   &quot;fillcolor&quot;  :   color-string or color-tuple&#10;   &quot;pensize&quot;    :   positive number&#10;   &quot;speed&quot;      :   number in range 0..10&#10;   &quot;resizemode&quot; :   &quot;auto&quot; or &quot;user&quot; or &quot;noresize&quot;&#10;   &quot;stretchfactor&quot;: (positive number, positive number)&#10;   &quot;outline&quot;    :   positive number&#10;   &quot;tilt&quot;       :   number&#10;&#10;This dictionary can be used as argument for a subsequent&#10;pen()-call to restore the former pen-state. Moreover one&#10;or more of these attributes can be provided as keyword-arguments.&#10;This can be used to set several pen attributes in one statement.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pen(fillcolor=&quot;black&quot;, pencolor=&quot;red&quot;, pensize=10)&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; penstate=turtle.pen()&#10;&gt;&gt;&gt; turtle.color(&quot;yellow&quot;,&quot;&quot;)&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; p.pen(penstate, fillcolor=&quot;green&quot;)&#10;&gt;&gt;&gt; p.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',&#10;'stretchfactor': (1,1), 'speed': 3}">
				<Param name="self" />
				<Param name="[pen=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.pencolor" func="yes">
			<Overload retVal="" descr="Return or set the pencolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - pencolor()&#10;    Return the current pencolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - pencolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - pencolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - pencolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the outline of that polygon is drawn&#10;with the newly set pencolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pencolor('brown')&#10;&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)&#10;&gt;&gt;&gt; turtle.pencolor(tup)&#10;&gt;&gt;&gt; turtle.pencolor()&#10;'#33cc8c'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.pendown" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.pensize" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.penup" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.pu" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.resizemode" func="yes">
			<Overload retVal="" descr="Set resizemode to one of the values: &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;.&#10;&#10;(Optional) Argument:&#10;rmode -- one of the strings &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;&#10;&#10;Different resizemodes have the following effects:&#10;  - &quot;auto&quot; adapts the appearance of the turtle&#10;           corresponding to the value of pensize.&#10;  - &quot;user&quot; adapts the appearance of the turtle according to the&#10;           values of stretchfactor and outlinewidth (outline),&#10;           which are set by shapesize()&#10;  - &quot;noresize&quot; no adaption of the turtle's appearance takes place.&#10;If no argument is given, return current resizemode.&#10;resizemode(&quot;user&quot;) is called by a call of shapesize with arguments.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;noresize&quot;)&#10;&gt;&gt;&gt; turtle.resizemode()&#10;'noresize'">
				<Param name="self" />
				<Param name="[rmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.showturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.speed" func="yes">
			<Overload retVal="" descr="Return or set the turtle's speed.&#10;&#10;Optional argument:&#10;speed -- an integer in the range 0..10 or a speedstring (see below)&#10;&#10;Set the turtle's speed to an integer value in the range 0 .. 10.&#10;If no argument is given: return current speed.&#10;&#10;If input is a number greater than 10 or smaller than 0.5,&#10;speed is set to 0.&#10;Speedstrings  are mapped to speedvalues in the following way:&#10;    'fastest' :  0&#10;    'fast'    :  10&#10;    'normal'  :  6&#10;    'slow'    :  3&#10;    'slowest' :  1&#10;speeds from 1 to 10 enforce increasingly faster animation of&#10;line drawing and turtle turning.&#10;&#10;Attention:&#10;speed = 0 : *no* animation takes place. forward/back makes turtle jump&#10;and likewise left/right make the turtle turn instantly.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.speed(3)">
				<Param name="self" />
				<Param name="[speed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.st" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.up" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TPen.width" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Tbuffer" func="yes">
			<Overload retVal="" descr="Ring buffer used as undobuffer for RawTurtle objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Tbuffer.nr_of_items" />
		<KeyWord name="turtle.Tbuffer.pop" />
		<KeyWord name="turtle.Tbuffer.push" />
		<KeyWord name="turtle.Tbuffer.reset" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[bufsize=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Terminator" func="yes">
			<Overload retVal="" descr="Will be raised in TurtleScreen.update, if _RUNNING becomes False.&#10;&#10;This stops execution of a turtle graphics script.&#10;Main purpose: use in the Demo-Viewer turtle.Demo.py.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Terminator.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Terminator.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle" func="yes">
			<Overload retVal="" descr="RawTurtle auto-creating (scrolled) canvas.&#10;&#10;When a Turtle object is created or a function derived from some&#10;Turtle method is called a TurtleScreen object is automatically created.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.DEFAULT_ANGLEORIENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.DEFAULT_MODE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.START_ORIENTATION" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.back" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.backward" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.begin_fill" func="yes">
			<Overload retVal="" descr="Called just before drawing a shape to be filled.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.begin_poly" func="yes">
			<Overload retVal="" descr="Start recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Start recording the vertices of a polygon. Current turtle position&#10;is first point of polygon.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.bk" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.backward(30)&#10;&gt;&gt;&gt; turtle.position()&#10;(-30.00, 0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.circle" func="yes">
			<Overload retVal="" descr="Draw a circle with given radius.&#10;&#10;Arguments:&#10;radius -- a number&#10;extent (optional) -- a number&#10;steps (optional) -- an integer&#10;&#10;Draw a circle with given radius. The center is radius units left&#10;of the turtle; extent - an angle - determines which part of the&#10;circle is drawn. If extent is not given, draw the entire circle.&#10;If extent is not a full circle, one endpoint of the arc is the&#10;current pen position. Draw the arc in counterclockwise direction&#10;if radius is positive, otherwise in clockwise direction. Finally&#10;the direction of the turtle is changed by the amount of extent.&#10;&#10;As the circle is approximated by an inscribed regular polygon,&#10;steps determines the number of steps to use. If not given,&#10;it will be calculated automatically. Maybe used to draw regular&#10;polygons.&#10;&#10;call: circle(radius)                  # full circle&#10;--or: circle(radius, extent)          # arc&#10;--or: circle(radius, extent, steps)&#10;--or: circle(radius, steps=6)         # 6-sided polygon&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.circle(50)&#10;&gt;&gt;&gt; turtle.circle(120, 180)  # semicircle">
				<Param name="self" />
				<Param name="radius" />
				<Param name="[extent=None" />
				<Param name="[steps=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.clear" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings from the screen. Do not move turtle.&#10;&#10;No arguments.&#10;&#10;Delete the turtle's drawings from the screen. Do not move turtle.&#10;State and position of the turtle as well as drawings of other&#10;turtles are not affected.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.clear()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.clearstamp" func="yes">
			<Overload retVal="" descr='Delete stamp with given stampid&#10;&#10;Argument:&#10;stampid - an integer, must be return value of previous stamp() call.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; astamp = turtle.stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.clearstamp(astamp)'>
				<Param name="self" />
				<Param name="stampid" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.clearstamps" func="yes">
			<Overload retVal="" descr="Delete all or first/last n of turtle's stamps.&#10;&#10;Optional argument:&#10;n -- an integer&#10;&#10;If n is None, delete all of pen's stamps,&#10;else if n &gt; 0 delete first n stamps&#10;else if n &lt; 0 delete last n stamps.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.stamp(); turtle.fd(30)&#10;...&#10;&gt;&gt;&gt; turtle.clearstamps(2)&#10;&gt;&gt;&gt; turtle.clearstamps(-2)&#10;&gt;&gt;&gt; turtle.clearstamps()">
				<Param name="self" />
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.clone" func="yes">
			<Overload retVal="" descr="Create and return a clone of the turtle.&#10;&#10;No argument.&#10;&#10;Create and return a clone of the turtle with same position, heading&#10;and turtle properties.&#10;&#10;Example (for a Turtle instance named mick):&#10;mick = Turtle()&#10;joe = mick.clone()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.color" func="yes">
			<Overload retVal="" descr="Return or set the pencolor and fillcolor.&#10;&#10;Arguments:&#10;Several input formats are allowed.&#10;They use 0, 1, 2, or 3 arguments as follows:&#10;&#10;color()&#10;    Return the current pencolor and the current fillcolor&#10;    as a pair of color specification strings as are returned&#10;    by pencolor and fillcolor.&#10;color(colorstring), color((r,g,b)), color(r,g,b)&#10;    inputs as in pencolor, set both, fillcolor and pencolor,&#10;    to the given value.&#10;color(colorstring1, colorstring2),&#10;color((r1,g1,b1), (r2,g2,b2))&#10;    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)&#10;    and analogously, if the other input format is used.&#10;&#10;If turtleshape is a polygon, outline and interior of that polygon&#10;is drawn with the newly set colors.&#10;For mor info see: pencolor, fillcolor&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color('red', 'green')&#10;&gt;&gt;&gt; turtle.color()&#10;('red', 'green')&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))&#10;&gt;&gt;&gt; color()&#10;('#285078', '#a0c8f0')">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.degrees" func="yes">
			<Overload retVal="" descr="Set angle measurement units to degrees.&#10;&#10;Optional argument:&#10;fullcircle -  a number&#10;&#10;Set angle measurement units, i. e. set number&#10;of 'degrees' for a full circle. Dafault value is&#10;360 degrees.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&#10;Change angle measurement unit to grad (also known as gon,&#10;grade, or gradian and equals 1/100-th of the right angle.)&#10;&gt;&gt;&gt; turtle.degrees(400.0)&#10;&gt;&gt;&gt; turtle.heading()&#10;100">
				<Param name="self" />
				<Param name="[fullcircle=360.0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.distance" func="yes">
			<Overload retVal="" descr="Return the distance from the turtle to (x,y) in turtle step units.&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.distance(30,40)&#10;50.0&#10;&gt;&gt;&gt; pen = Turtle()&#10;&gt;&gt;&gt; pen.forward(77)&#10;&gt;&gt;&gt; turtle.distance(pen)&#10;77.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.dot" func="yes">
			<Overload retVal="" descr='Draw a dot with diameter size, using color.&#10;&#10;Optional arguments:&#10;size -- an integer &gt;= 1 (if given)&#10;color -- a colorstring or a numeric color tuple&#10;&#10;Draw a circular dot with diameter size, using color.&#10;If size is not given, the maximum of pensize+4 and 2*pensize is used.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.dot()&#10;&gt;&gt;&gt; turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)'>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.down" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.end_fill" func="yes">
			<Overload retVal="" descr="Fill the shape drawn after the call begin_fill().&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.begin_fill()&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.end_fill()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.end_poly" func="yes">
			<Overload retVal="" descr="Stop recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Stop recording the vertices of a polygon. Current turtle position is&#10;last point of polygon. This will be connected with the first point.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.end_poly()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.fd" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.fill" func="yes">
			<Overload retVal="" descr="Call fill(True) before drawing a shape to fill, fill(False) when done.&#10;&#10;Optional argument:&#10;flag -- True/False (or 1/0 respectively)&#10;&#10;Call fill(True) before drawing the shape you want to fill,&#10;and  fill(False) when done.&#10;When used without argument: return fillstate (True if filling,&#10;False else)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fill(True)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.left(90)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; turtle.fill(False)">
				<Param name="self" />
				<Param name="[flag=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.fillcolor" func="yes">
			<Overload retVal="" descr="Return or set the fillcolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - fillcolor()&#10;    Return the current fillcolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - fillcolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - fillcolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - fillcolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the interior of that polygon is drawn&#10;with the newly set fillcolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.fillcolor('violet')&#10;&gt;&gt;&gt; col = turtle.pencolor()&#10;&gt;&gt;&gt; turtle.fillcolor(col)&#10;&gt;&gt;&gt; turtle.fillcolor(0, .5, 0)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.forward" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.forward(25)&#10;&gt;&gt;&gt; turtle.position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; turtle.forward(-75)&#10;&gt;&gt;&gt; turtle.position()&#10;(-50.00,0.00)">
				<Param name="self" />
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.get_poly" func="yes">
			<Overload retVal="" descr='Return the lastly recorded polygon.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; p = turtle.get_poly()&#10;&gt;&gt;&gt; turtle.register_shape("myFavouriteShape", p)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.getpen" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.getscreen" func="yes">
			<Overload retVal="" descr='Return the TurtleScreen object, the turtle is drawing  on.&#10;&#10;No argument.&#10;&#10;Return the TurtleScreen object, the turtle is drawing  on.&#10;So TurtleScreen-methods can be called for that object.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; ts = turtle.getscreen()&#10;&gt;&gt;&gt; ts&#10;&lt;turtle.TurtleScreen object at 0x0106B770&gt;&#10;&gt;&gt;&gt; ts.bgcolor("pink")'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.getturtle" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;turtle.Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x0187D810&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.goto" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.heading" func="yes">
			<Overload retVal="" descr="Return the turtle's current heading.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.left(67)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.hideturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.home" func="yes">
			<Overload retVal="" descr="Move turtle to the origin - coordinates (0,0).&#10;&#10;No arguments.&#10;&#10;Move turtle to the origin - coordinates (0,0) and set its&#10;heading to its start-orientation (which depends on mode).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.home()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.ht" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.isdown" func="yes">
			<Overload retVal="" descr="Return True if pen is down, False if it's up.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.isdown()&#10;False&#10;&gt;&gt;&gt; turtle.pendown()&#10;&gt;&gt;&gt; turtle.isdown()&#10;True">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.isvisible" func="yes">
			<Overload retVal="" descr="Return True if the Turtle is shown, False if it's hidden.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; print turtle.isvisible():&#10;False">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.left" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.lt" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.left(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;67.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.onclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun --  a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;add --  True or False. If True, new binding will be added, otherwise&#10;        it will replace a former binding.&#10;&#10;Example for the anonymous turtle, i. e. the procedural way:&#10;&#10;&gt;&gt;&gt; def turn(x, y):&#10;...     left(360)&#10;...&#10;&gt;&gt;&gt; onclick(turn)  # Now clicking into the turtle will turn it.&#10;&gt;&gt;&gt; onclick(None)  # event-binding will be removed">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.ondrag" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-move event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;       the coordinates of the clicked point on the canvas.&#10;num -- number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Every sequence of mouse-move-events on a turtle is preceded by a&#10;mouse-click event on that turtle.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.ondrag(turtle.goto)&#10;&#10;Subsequently clicking and dragging a Turtle will move it&#10;across the screen thereby producing handdrawings (if pen is&#10;down).">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.onrelease" func="yes">
			<Overload retVal="" descr='Bind fun to mouse-button-release event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Example (for a MyTurtle instance named joe):&#10;&gt;&gt;&gt; class MyTurtle(Turtle):&#10;...     def glow(self,x,y):&#10;...             self.fillcolor("red")&#10;...     def unglow(self,x,y):&#10;...             self.fillcolor("")&#10;...&#10;&gt;&gt;&gt; joe = MyTurtle()&#10;&gt;&gt;&gt; joe.onclick(joe.glow)&#10;&gt;&gt;&gt; joe.onrelease(joe.unglow)&#10;&#10;Clicking on joe turns fillcolor red, unclicking turns it to&#10;transparent.'>
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pd" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pen" func="yes">
			<Overload retVal="" descr="Return or set the pen's attributes.&#10;&#10;Arguments:&#10;    pen -- a dictionary with some or all of the below listed keys.&#10;    **pendict -- one or more keyword-arguments with the below&#10;                 listed keys as keywords.&#10;&#10;Return or set the pen's attributes in a 'pen-dictionary'&#10;with the following key/value pairs:&#10;   &quot;shown&quot;      :   True/False&#10;   &quot;pendown&quot;    :   True/False&#10;   &quot;pencolor&quot;   :   color-string or color-tuple&#10;   &quot;fillcolor&quot;  :   color-string or color-tuple&#10;   &quot;pensize&quot;    :   positive number&#10;   &quot;speed&quot;      :   number in range 0..10&#10;   &quot;resizemode&quot; :   &quot;auto&quot; or &quot;user&quot; or &quot;noresize&quot;&#10;   &quot;stretchfactor&quot;: (positive number, positive number)&#10;   &quot;outline&quot;    :   positive number&#10;   &quot;tilt&quot;       :   number&#10;&#10;This dictionary can be used as argument for a subsequent&#10;pen()-call to restore the former pen-state. Moreover one&#10;or more of these attributes can be provided as keyword-arguments.&#10;This can be used to set several pen attributes in one statement.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pen(fillcolor=&quot;black&quot;, pencolor=&quot;red&quot;, pensize=10)&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; penstate=turtle.pen()&#10;&gt;&gt;&gt; turtle.color(&quot;yellow&quot;,&quot;&quot;)&#10;&gt;&gt;&gt; turtle.penup()&#10;&gt;&gt;&gt; turtle.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; p.pen(penstate, fillcolor=&quot;green&quot;)&#10;&gt;&gt;&gt; p.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',&#10;'stretchfactor': (1,1), 'speed': 3}">
				<Param name="self" />
				<Param name="[pen=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pencolor" func="yes">
			<Overload retVal="" descr="Return or set the pencolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - pencolor()&#10;    Return the current pencolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - pencolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - pencolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - pencolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the outline of that polygon is drawn&#10;with the newly set pencolor.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pencolor('brown')&#10;&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)&#10;&gt;&gt;&gt; turtle.pencolor(tup)&#10;&gt;&gt;&gt; turtle.pencolor()&#10;'#33cc8c'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pendown" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pendown()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pensize" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.penup" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pos" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.position" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00, 240.00)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.pu" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.radians" func="yes">
			<Overload retVal="" descr="Set the angle measurement units to radians.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;90&#10;&gt;&gt;&gt; turtle.radians()&#10;&gt;&gt;&gt; turtle.heading()&#10;1.5707963267948966">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.reset" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings and restore its default values.&#10;&#10;        No argument.&#10;,&#10;        Delete the turtle's drawings from the screen, re-center the turtle&#10;        and set variables to the default values.&#10;&#10;        Example (for a Turtle instance named turtle):&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,-22.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        100.0&#10;        &gt;&gt;&gt; turtle.reset()&#10;        &gt;&gt;&gt; turtle.position()&#10;        (0.00,0.00)&#10;        &gt;&gt;&gt; turtle.heading()&#10;        0.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.resizemode" func="yes">
			<Overload retVal="" descr="Set resizemode to one of the values: &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;.&#10;&#10;(Optional) Argument:&#10;rmode -- one of the strings &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;&#10;&#10;Different resizemodes have the following effects:&#10;  - &quot;auto&quot; adapts the appearance of the turtle&#10;           corresponding to the value of pensize.&#10;  - &quot;user&quot; adapts the appearance of the turtle according to the&#10;           values of stretchfactor and outlinewidth (outline),&#10;           which are set by shapesize()&#10;  - &quot;noresize&quot; no adaption of the turtle's appearance takes place.&#10;If no argument is given, return current resizemode.&#10;resizemode(&quot;user&quot;) is called by a call of shapesize with arguments.&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;noresize&quot;)&#10;&gt;&gt;&gt; turtle.resizemode()&#10;'noresize'">
				<Param name="self" />
				<Param name="[rmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.right" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.rt" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.heading()&#10;22.0&#10;&gt;&gt;&gt; turtle.right(45)&#10;&gt;&gt;&gt; turtle.heading()&#10;337.0">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.seth" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.setheading" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setheading(90)&#10;&gt;&gt;&gt; turtle.heading()&#10;90">
				<Param name="self" />
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.setpos" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.setposition" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; tp = turtle.pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; turtle.setpos(60,30)&#10;&gt;&gt;&gt; turtle.pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; turtle.setpos((20,80))&#10;&gt;&gt;&gt; turtle.pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; turtle.setpos(tp)&#10;&gt;&gt;&gt; turtle.pos()&#10;(0.00,0.00)">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.settiltangle" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape to point in the specified direction&#10;&#10;Optional argument:&#10;angle -- number&#10;&#10;Rotate the turtleshape to point in the direction specified by angle,&#10;regardless of its current tilt-angle. DO NOT change the turtle's&#10;heading (direction of movement).&#10;&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.settiltangle(45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.settiltangle(-45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.setundobuffer" func="yes">
			<Overload retVal="" descr="Set or disable undobuffer.&#10;&#10;Argument:&#10;size -- an integer or None&#10;&#10;If size is an integer an empty undobuffer of given size is installed.&#10;Size gives the maximum number of turtle-actions that can be undone&#10;by the undo() function.&#10;If size is None, no undobuffer is present.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.setundobuffer(42)">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.setx" func="yes">
			<Overload retVal="" descr="Set the turtle's first coordinate to x&#10;&#10;Argument:&#10;x -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, leave second coordinate&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 240.00)&#10;&gt;&gt;&gt; turtle.setx(10)&#10;&gt;&gt;&gt; turtle.position()&#10;(10.00, 240.00)">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.sety" func="yes">
			<Overload retVal="" descr="Set the turtle's second coordinate to y&#10;&#10;Argument:&#10;y -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, second coordinate remains&#10;unchanged.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, 40.00)&#10;&gt;&gt;&gt; turtle.sety(-10)&#10;&gt;&gt;&gt; turtle.position()&#10;(0.00, -10.00)">
				<Param name="self" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.shape" func="yes">
			<Overload retVal="" descr="Set turtle shape to shape with given name / return current shapename.&#10;&#10;Optional argument:&#10;name -- a string, which is a valid shapename&#10;&#10;Set turtle shape to shape with given name or, if name is not given,&#10;return name of current shape.&#10;Shape with name must exist in the TurtleScreen's shape dictionary.&#10;Initially there are the following polygon shapes:&#10;'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.&#10;To learn about how to deal with shapes see Screen-method register_shape.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape()&#10;'arrow'&#10;&gt;&gt;&gt; turtle.shape(&quot;turtle&quot;)&#10;&gt;&gt;&gt; turtle.shape()&#10;'turtle'">
				<Param name="self" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.shapesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.showturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.speed" func="yes">
			<Overload retVal="" descr="Return or set the turtle's speed.&#10;&#10;Optional argument:&#10;speed -- an integer in the range 0..10 or a speedstring (see below)&#10;&#10;Set the turtle's speed to an integer value in the range 0 .. 10.&#10;If no argument is given: return current speed.&#10;&#10;If input is a number greater than 10 or smaller than 0.5,&#10;speed is set to 0.&#10;Speedstrings  are mapped to speedvalues in the following way:&#10;    'fastest' :  0&#10;    'fast'    :  10&#10;    'normal'  :  6&#10;    'slow'    :  3&#10;    'slowest' :  1&#10;speeds from 1 to 10 enforce increasingly faster animation of&#10;line drawing and turtle turning.&#10;&#10;Attention:&#10;speed = 0 : *no* animation takes place. forward/back makes turtle jump&#10;and likewise left/right make the turtle turn instantly.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.speed(3)">
				<Param name="self" />
				<Param name="[speed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.st" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.hideturtle()&#10;&gt;&gt;&gt; turtle.showturtle()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.stamp" func="yes">
			<Overload retVal="" descr='Stamp a copy of the turtleshape onto the canvas and return its id.&#10;&#10;No argument.&#10;&#10;Stamp a copy of the turtle shape onto the canvas at the current&#10;turtle position. Return a stamp_id for that stamp, which can be&#10;used to delete it by calling clearstamp(stamp_id).&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.color("blue")&#10;&gt;&gt;&gt; turtle.stamp()&#10;13&#10;&gt;&gt;&gt; turtle.fd(50)'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.tilt" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape by angle.&#10;&#10;Argument:&#10;angle - a number&#10;&#10;Rotate the turtleshape by angle from its current tilt-angle,&#10;but do NOT change the turtle's heading (direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)&#10;&gt;&gt;&gt; turtle.tilt(30)&#10;&gt;&gt;&gt; turtle.fd(50)">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.tiltangle" func="yes">
			<Overload retVal="" descr='Return the current tilt-angle.&#10;&#10;No argument.&#10;&#10;Return the current tilt-angle, i. e. the angle between the&#10;orientation of the turtleshape and the heading of the turtle&#10;(its direction of movement).&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.shape("circle")&#10;&gt;&gt;&gt; turtle.shapesize(5,2)&#10;&gt;&gt;&gt; turtle.tilt(45)&#10;&gt;&gt;&gt; turtle.tiltangle()'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.towards" func="yes">
			<Overload retVal="" descr="Return the angle of the line from the turtle's position to (x, y).&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Return the angle, between the line from turtle-position to position&#10;specified by x, y and the turtle's start orientation. (Depends on&#10;modes - &quot;standard&quot; or &quot;logo&quot;)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pos()&#10;(10.00, 10.00)&#10;&gt;&gt;&gt; turtle.towards(0,0)&#10;225.0">
				<Param name="self" />
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.tracer" func="yes">
			<Overload retVal="" descr="Turns turtle animation on/off and set delay for update drawings.&#10;&#10;Optional arguments:&#10;n -- nonnegative  integer&#10;delay -- nonnegative  integer&#10;&#10;If n is given, only each n-th regular screen update is really performed.&#10;(Can be used to accelerate the drawing of complex graphics.)&#10;Second arguments sets delay value (see RawTurtle.delay())&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.tracer(8, 25)&#10;&gt;&gt;&gt; dist = 2&#10;&gt;&gt;&gt; for i in range(200):&#10;...     turtle.fd(dist)&#10;...     turtle.rt(90)&#10;...     dist += 2">
				<Param name="self" />
				<Param name="[flag=None" />
				<Param name="[delay=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.turtlesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; turtle.shapesize(5, 5, 12)&#10;&gt;&gt;&gt; turtle.shapesize(outline=8)">
				<Param name="self" />
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.undo" func="yes">
			<Overload retVal="" descr="undo (repeatedly) the last turtle action.&#10;&#10;No argument.&#10;&#10;undo (repeatedly) the last turtle action.&#10;Number of available undo actions is determined by the size of&#10;the undobuffer.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; for i in range(4):&#10;...     turtle.fd(50); turtle.lt(80)&#10;...&#10;&gt;&gt;&gt; for i in range(8):&#10;...     turtle.undo()&#10;...">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.undobufferentries" func="yes">
			<Overload retVal="" descr="Return count of entries in the undobuffer.&#10;&#10;No argument.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; while undobufferentries():&#10;...     undo()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.up" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.penup()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.width" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.pensize()&#10;1&#10;&gt;&gt;&gt; turtle.pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="self" />
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.window_height" func="yes">
			<Overload retVal="" descr="Return the height of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_height()&#10;480">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.window_width" func="yes">
			<Overload retVal="" descr="Returns the width of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_width()&#10;640">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.write" func="yes">
			<Overload retVal="" descr="Write text at the current turtle position.&#10;&#10;Arguments:&#10;arg -- info, which is to be written to the TurtleScreen&#10;move (optional) -- True/False&#10;align (optional) -- one of the strings &quot;left&quot;, &quot;center&quot; or right&quot;&#10;font (optional) -- a triple (fontname, fontsize, fonttype)&#10;&#10;Write text - the string representation of arg - at the current&#10;turtle position according to align (&quot;left&quot;, &quot;center&quot; or right&quot;)&#10;and with the given font.&#10;If move is True, the pen is moved to the bottom-right corner&#10;of the text. By default, move is False.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.write('Home = ', True, align=&quot;center&quot;)&#10;&gt;&gt;&gt; turtle.write((0,0), True)">
				<Param name="self" />
				<Param name="arg" />
				<Param name="[move=False" />
				<Param name="[align=left" />
				<Param name="[font=('Arial', 8, 'normal')]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.xcor" func="yes">
			<Overload retVal="" descr="Return the turtle's x coordinate.&#10;&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.xcor()&#10;50.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Turtle.ycor" func="yes">
			<Overload retVal="" descr="Return the turtle's y coordinate&#10;---&#10;No arguments.&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; turtle.left(60)&#10;&gt;&gt;&gt; turtle.forward(100)&#10;&gt;&gt;&gt; print turtle.ycor()&#10;86.6025403784">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleGraphicsError" func="yes">
			<Overload retVal="" descr="Some TurtleGraphics Error">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleGraphicsError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleGraphicsError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen" func="yes">
			<Overload retVal="" descr="Provides screen oriented methods like setbg etc.&#10;&#10;Only relies upon the methods of TurtleScreenBase and NOT&#10;upon components of the underlying graphics toolkit -&#10;which is Tkinter in this case.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.addshape" func="yes">
			<Overload retVal="" descr="Adds a turtle shape to TurtleScreen's shapelist.&#10;&#10;Arguments:&#10;(1) name is the name of a gif-file and shape is None.&#10;    Installs the corresponding image shape.&#10;    !! Image-shapes DO NOT rotate when turning the turtle,&#10;    !! so they do not display the heading of the turtle!&#10;(2) name is an arbitrary string and shape is a tuple&#10;    of pairs of coordinates. Installs the corresponding&#10;    polygon shape&#10;(3) name is an arbitrary string and shape is a&#10;    (compound) Shape object. Installs the corresponding&#10;    compound shape.&#10;To use a shape, you have to issue the command shape(shapename).&#10;&#10;call: register_shape(&quot;turtle.gif&quot;)&#10;--or: register_shape(&quot;tri&quot;, ((0,0), (10,10), (-10,10)))&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.register_shape(&quot;triangle&quot;, ((5,-3),(0,5),(-5,-3)))">
				<Param name="self" />
				<Param name="name" />
				<Param name="[shape=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.bgcolor" func="yes">
			<Overload retVal="" descr="Set or return backgroundcolor of the TurtleScreen.&#10;&#10;Arguments (if given): a color string or three numbers&#10;in the range 0..colormode or a 3-tuple of such numbers.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.bgcolor(&quot;orange&quot;)&#10;&gt;&gt;&gt; screen.bgcolor()&#10;'orange'&#10;&gt;&gt;&gt; screen.bgcolor(0.5,0,0.5)&#10;&gt;&gt;&gt; screen.bgcolor()&#10;'#800080'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.bgpic" func="yes">
			<Overload retVal="" descr="Set background image or return name of current backgroundimage.&#10;&#10;Optional argument:&#10;picname -- a string, name of a gif-file or &quot;nopic&quot;.&#10;&#10;If picname is a filename, set the corresponding image as background.&#10;If picname is &quot;nopic&quot;, delete backgroundimage, if present.&#10;If picname is None, return the filename of the current backgroundimage.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.bgpic()&#10;'nopic'&#10;&gt;&gt;&gt; screen.bgpic(&quot;landscape.gif&quot;)&#10;&gt;&gt;&gt; screen.bgpic()&#10;'landscape.gif'">
				<Param name="self" />
				<Param name="[picname=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.clear" func="yes">
			<Overload retVal="" descr="Delete all drawings and all turtles from the TurtleScreen.&#10;&#10;Reset empty TurtleScreen to its initial state: white background,&#10;no backgroundimage, no eventbindings and tracing on.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.clear()&#10;&#10;Note: this method is not available as function.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.clearscreen" func="yes">
			<Overload retVal="" descr="Delete all drawings and all turtles from the TurtleScreen.&#10;&#10;Reset empty TurtleScreen to its initial state: white background,&#10;no backgroundimage, no eventbindings and tracing on.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.clear()&#10;&#10;Note: this method is not available as function.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.colormode" func="yes">
			<Overload retVal="" descr="Return the colormode or set it to 1.0 or 255.&#10;&#10;Optional argument:&#10;cmode -- one of the values 1.0 or 255&#10;&#10;r, g, b values of colortriples have to be in range 0..cmode.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.colormode()&#10;1.0&#10;&gt;&gt;&gt; screen.colormode(255)&#10;&gt;&gt;&gt; pencolor(240,160,80)">
				<Param name="self" />
				<Param name="[cmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.delay" func="yes">
			<Overload retVal="" descr="Return or set the drawing delay in milliseconds.&#10;&#10;Optional argument:&#10;delay -- positive integer&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.delay(15)&#10;&gt;&gt;&gt; screen.delay()&#10;15">
				<Param name="self" />
				<Param name="[delay=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.getcanvas" func="yes">
			<Overload retVal="" descr="Return the Canvas of this TurtleScreen.&#10;&#10;No argument.&#10;&#10;Example (for a Screen instance named screen):&#10;&gt;&gt;&gt; cv = screen.getcanvas()&#10;&gt;&gt;&gt; cv&#10;&lt;turtle.ScrolledCanvas instance at 0x010742D8&gt;">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.getshapes" func="yes">
			<Overload retVal="" descr="Return a list of names of all currently available turtle shapes.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.getshapes()&#10;['arrow', 'blank', 'circle', ... , 'turtle']">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.listen" func="yes">
			<Overload retVal="" descr="Set focus on TurtleScreen (in order to collect key-events)&#10;&#10;No arguments.&#10;Dummy arguments are provided in order&#10;to be able to pass listen to the onclick method.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.listen()">
				<Param name="self" />
				<Param name="[xdummy=None" />
				<Param name="[ydummy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.mode" func="yes">
			<Overload retVal="" descr="Set turtle-mode ('standard', 'logo' or 'world') and perform reset.&#10;&#10;Optional argument:&#10;mode -- on of the strings 'standard', 'logo' or 'world'&#10;&#10;Mode 'standard' is compatible with turtle.py.&#10;Mode 'logo' is compatible with most Logo-Turtle-Graphics.&#10;Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in&#10;this mode angles appear distorted if x/y unit-ratio doesn't equal 1.&#10;If mode is not given, return the current mode.&#10;&#10;     Mode      Initial turtle heading     positive angles&#10; ------------|-------------------------|-------------------&#10;  'standard'    to the right (east)       counterclockwise&#10;    'logo'        upward    (north)         clockwise&#10;&#10;Examples:&#10;&gt;&gt;&gt; mode('logo')   # resets turtle heading to north&#10;&gt;&gt;&gt; mode()&#10;'logo'">
				<Param name="self" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.onclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, the coordinates of the&#10;       clicked point on the canvas.&#10;num -- the number of the mouse-button, defaults to 1&#10;&#10;Example (for a TurtleScreen instance named screen&#10;and a Turtle instance named turtle):&#10;&#10;&gt;&gt;&gt; screen.onclick(goto)&#10;&gt;&gt;&gt; # Subsequently clicking into the TurtleScreen will&#10;&gt;&gt;&gt; # make the turtle move to the clicked point.&#10;&gt;&gt;&gt; screen.onclick(None)">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.onkey" func="yes">
			<Overload retVal="" descr='Bind fun to key-release event of key.&#10;&#10;Arguments:&#10;fun -- a function with no arguments&#10;key -- a string: key (e.g. "a") or key-symbol (e.g. "space")&#10;&#10;In order to be able to register key-events, TurtleScreen&#10;must have focus. (See method listen.)&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&#10;&gt;&gt;&gt; def f():&#10;...     fd(50)&#10;...     lt(60)&#10;...&#10;&gt;&gt;&gt; screen.onkey(f, "Up")&#10;&gt;&gt;&gt; screen.listen()&#10;&#10;Subsequently the turtle can be moved by repeatedly pressing&#10;the up-arrow key, consequently drawing a hexagon'>
				<Param name="self" />
				<Param name="fun" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.onscreenclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, the coordinates of the&#10;       clicked point on the canvas.&#10;num -- the number of the mouse-button, defaults to 1&#10;&#10;Example (for a TurtleScreen instance named screen&#10;and a Turtle instance named turtle):&#10;&#10;&gt;&gt;&gt; screen.onclick(goto)&#10;&gt;&gt;&gt; # Subsequently clicking into the TurtleScreen will&#10;&gt;&gt;&gt; # make the turtle move to the clicked point.&#10;&gt;&gt;&gt; screen.onclick(None)">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.ontimer" func="yes">
			<Overload retVal="" descr="Install a timer, which calls fun after t milliseconds.&#10;&#10;Arguments:&#10;fun -- a function with no arguments.&#10;t -- a number &gt;= 0&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&#10;&gt;&gt;&gt; running = True&#10;&gt;&gt;&gt; def f():&#10;...     if running:&#10;...             fd(50)&#10;...             lt(60)&#10;...             screen.ontimer(f, 250)&#10;...&#10;&gt;&gt;&gt; f()   # makes the turtle marching around&#10;&gt;&gt;&gt; running = False">
				<Param name="self" />
				<Param name="fun" />
				<Param name="[t=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.register_shape" func="yes">
			<Overload retVal="" descr="Adds a turtle shape to TurtleScreen's shapelist.&#10;&#10;Arguments:&#10;(1) name is the name of a gif-file and shape is None.&#10;    Installs the corresponding image shape.&#10;    !! Image-shapes DO NOT rotate when turning the turtle,&#10;    !! so they do not display the heading of the turtle!&#10;(2) name is an arbitrary string and shape is a tuple&#10;    of pairs of coordinates. Installs the corresponding&#10;    polygon shape&#10;(3) name is an arbitrary string and shape is a&#10;    (compound) Shape object. Installs the corresponding&#10;    compound shape.&#10;To use a shape, you have to issue the command shape(shapename).&#10;&#10;call: register_shape(&quot;turtle.gif&quot;)&#10;--or: register_shape(&quot;tri&quot;, ((0,0), (10,10), (-10,10)))&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.register_shape(&quot;triangle&quot;, ((5,-3),(0,5),(-5,-3)))">
				<Param name="self" />
				<Param name="name" />
				<Param name="[shape=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.reset" func="yes">
			<Overload retVal="" descr="Reset all Turtles on the Screen to their initial state.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.reset()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.resetscreen" func="yes">
			<Overload retVal="" descr="Reset all Turtles on the Screen to their initial state.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.reset()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.screensize" func="yes">
			<Overload retVal="" descr="Resize the canvas the turtles are drawing on.&#10;&#10;Optional arguments:&#10;canvwidth -- positive integer, new width of canvas in pixels&#10;canvheight --  positive integer, new height of canvas in pixels&#10;bg -- colorstring or color-tuple, new backgroundcolor&#10;If no arguments are given, return current (canvaswidth, canvasheight)&#10;&#10;Do not alter the drawing window. To observe hidden parts of&#10;the canvas use the scrollbars. (Can make visible those parts&#10;of a drawing, which were outside the canvas before!)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.screensize(2000,1500)&#10;&gt;&gt;&gt; # e. g. to search for an erroneously escaped turtle ;-)">
				<Param name="self" />
				<Param name="[canvwidth=None" />
				<Param name="[canvheight=None" />
				<Param name="[bg=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.setworldcoordinates" func="yes">
			<Overload retVal="" descr="Set up a user defined coordinate-system.&#10;&#10;Arguments:&#10;llx -- a number, x-coordinate of lower left corner of canvas&#10;lly -- a number, y-coordinate of lower left corner of canvas&#10;urx -- a number, x-coordinate of upper right corner of canvas&#10;ury -- a number, y-coordinate of upper right corner of canvas&#10;&#10;Set up user coodinat-system and switch to mode 'world' if necessary.&#10;This performs a screen.reset. If mode 'world' is already active,&#10;all drawings are redrawn according to the new coordinates.&#10;&#10;But ATTENTION: in user-defined coordinatesystems angles may appear&#10;distorted. (see Screen.mode())&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.setworldcoordinates(-10,-0.5,50,1.5)&#10;&gt;&gt;&gt; for _ in range(36):&#10;...     left(10)&#10;...     forward(0.5)">
				<Param name="self" />
				<Param name="llx" />
				<Param name="lly" />
				<Param name="urx" />
				<Param name="ury" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.tracer" func="yes">
			<Overload retVal="" descr="Turns turtle animation on/off and set delay for update drawings.&#10;&#10;Optional arguments:&#10;n -- nonnegative  integer&#10;delay -- nonnegative  integer&#10;&#10;If n is given, only each n-th regular screen update is really performed.&#10;(Can be used to accelerate the drawing of complex graphics.)&#10;Second arguments sets delay value (see RawTurtle.delay())&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.tracer(8, 25)&#10;&gt;&gt;&gt; dist = 2&#10;&gt;&gt;&gt; for i in range(200):&#10;...     fd(dist)&#10;...     rt(90)&#10;...     dist += 2">
				<Param name="self" />
				<Param name="[n=None" />
				<Param name="[delay=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.turtles" func="yes">
			<Overload retVal="" descr="Return the list of turtles on the screen.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.turtles()&#10;[&lt;turtle.Turtle object at 0x00E11FB0&gt;]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.update" func="yes">
			<Overload retVal="" descr="Perform a TurtleScreen update.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.window_height" func="yes">
			<Overload retVal="" descr="Return the height of the turtle window.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_height()&#10;480">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreen.window_width" func="yes">
			<Overload retVal="" descr="Return the width of the turtle window.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_width()&#10;640">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.TurtleScreenBase" func="yes">
			<Overload retVal="" descr="Provide the basic graphics functionality.&#10;Interface between Tkinter and turtle.py.&#10;&#10;To port turtle.py to some different graphics toolkit&#10;a corresponding TurtleScreenBase class has to be implemented.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Vec2D" func="yes">
			<Overload retVal="" descr="A 2 dimensional vector class, used as a helper class&#10;for implementing turtle graphics.&#10;May be useful for turtle graphics programs also.&#10;Derived from tuple, so a vector is a tuple!&#10;&#10;Provides (for a, b vectors, k number):&#10;   a+b vector addition&#10;   a-b vector subtraction&#10;   a*b inner product&#10;   k*a and a*k multiplication with scalar&#10;   |a| absolute value of a&#10;   a.rotate(angle) rotation">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Vec2D.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Vec2D.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.Vec2D.rotate" func="yes">
			<Overload retVal="" descr="rotate self counterclockwise by angle">
				<Param name="self" />
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.acos" func="yes">
			<Overload retVal="" descr="acos(x)&#10;&#10;Return the arc cosine (measured in radians) of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.acosh" func="yes">
			<Overload retVal="" descr="acosh(x)&#10;&#10;Return the inverse hyperbolic cosine of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.addshape" func="yes">
			<Overload retVal="" descr="Adds a turtle shape to TurtleScreen's shapelist.&#10;&#10;Arguments:&#10;(1) name is the name of a gif-file and shape is None.&#10;    Installs the corresponding image shape.&#10;    !! Image-shapes DO NOT rotate when turning the turtle,&#10;    !! so they do not display the heading of the turtle!&#10;(2) name is an arbitrary string and shape is a tuple&#10;    of pairs of coordinates. Installs the corresponding&#10;    polygon shape&#10;(3) name is an arbitrary string and shape is a&#10;    (compound) Shape object. Installs the corresponding&#10;    compound shape.&#10;To use a shape, you have to issue the command shape(shapename).&#10;&#10;call: register_shape(&quot;turtle.gif&quot;)&#10;--or: register_shape(&quot;tri&quot;, ((0,0), (10,10), (-10,10)))&#10;&#10;Example:&#10;&gt;&gt;&gt; register_shape(&quot;triangle&quot;, ((5,-3),(0,5),(-5,-3)))">
				<Param name="name" />
				<Param name="[shape=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.asin" func="yes">
			<Overload retVal="" descr="asin(x)&#10;&#10;Return the arc sine (measured in radians) of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.asinh" func="yes">
			<Overload retVal="" descr="asinh(x)&#10;&#10;Return the inverse hyperbolic sine of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.atan" func="yes">
			<Overload retVal="" descr="atan(x)&#10;&#10;Return the arc tangent (measured in radians) of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.atan2" func="yes">
			<Overload retVal="" descr="atan2(y, x)&#10;&#10;Return the arc tangent (measured in radians) of y/x.&#10;Unlike atan(y/x), the signs of both x and y are considered.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.atanh" func="yes">
			<Overload retVal="" descr="atanh(x)&#10;&#10;Return the inverse hyperbolic tangent of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.back" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; backward(30)&#10;&gt;&gt;&gt; position()&#10;(-30.00, 0.00)">
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.backward" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; backward(30)&#10;&gt;&gt;&gt; position()&#10;(-30.00, 0.00)">
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.begin_fill" func="yes">
			<Overload retVal="" descr="Called just before drawing a shape to be filled.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; begin_fill()&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; end_fill()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.begin_poly" func="yes">
			<Overload retVal="" descr="Start recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Start recording the vertices of a polygon. Current turtle position&#10;is first point of polygon.&#10;&#10;Example:&#10;&gt;&gt;&gt; begin_poly()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.bgcolor" func="yes">
			<Overload retVal="" descr="Set or return backgroundcolor of the TurtleScreen.&#10;&#10;Arguments (if given): a color string or three numbers&#10;in the range 0..colormode or a 3-tuple of such numbers.&#10;&#10;Example:&#10;&gt;&gt;&gt; bgcolor(&quot;orange&quot;)&#10;&gt;&gt;&gt; bgcolor()&#10;'orange'&#10;&gt;&gt;&gt; bgcolor(0.5,0,0.5)&#10;&gt;&gt;&gt; bgcolor()&#10;'#800080'">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.bgpic" func="yes">
			<Overload retVal="" descr="Set background image or return name of current backgroundimage.&#10;&#10;Optional argument:&#10;picname -- a string, name of a gif-file or &quot;nopic&quot;.&#10;&#10;If picname is a filename, set the corresponding image as background.&#10;If picname is &quot;nopic&quot;, delete backgroundimage, if present.&#10;If picname is None, return the filename of the current backgroundimage.&#10;&#10;Example:&#10;&gt;&gt;&gt; bgpic()&#10;'nopic'&#10;&gt;&gt;&gt; bgpic(&quot;landscape.gif&quot;)&#10;&gt;&gt;&gt; bgpic()&#10;'landscape.gif'">
				<Param name="[picname=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.bk" func="yes">
			<Overload retVal="" descr="Move the turtle backward by distance.&#10;&#10;Aliases: back | backward | bk&#10;&#10;Argument:&#10;distance -- a number&#10;&#10;Move the turtle backward by distance ,opposite to the direction the&#10;turtle is headed. Do not change the turtle's heading.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; backward(30)&#10;&gt;&gt;&gt; position()&#10;(-30.00, 0.00)">
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.bye" func="yes">
			<Overload retVal="" descr="Shut the turtlegraphics window.&#10;&#10;Example:&#10;&gt;&gt;&gt; bye()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ceil" func="yes">
			<Overload retVal="" descr="ceil(x)&#10;&#10;Return the ceiling of x as a float.&#10;This is the smallest integral value &gt;= x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.circle" func="yes">
			<Overload retVal="" descr="Draw a circle with given radius.&#10;&#10;Arguments:&#10;radius -- a number&#10;extent (optional) -- a number&#10;steps (optional) -- an integer&#10;&#10;Draw a circle with given radius. The center is radius units left&#10;of the turtle; extent - an angle - determines which part of the&#10;circle is drawn. If extent is not given, draw the entire circle.&#10;If extent is not a full circle, one endpoint of the arc is the&#10;current pen position. Draw the arc in counterclockwise direction&#10;if radius is positive, otherwise in clockwise direction. Finally&#10;the direction of the turtle is changed by the amount of extent.&#10;&#10;As the circle is approximated by an inscribed regular polygon,&#10;steps determines the number of steps to use. If not given,&#10;it will be calculated automatically. Maybe used to draw regular&#10;polygons.&#10;&#10;call: circle(radius)                  # full circle&#10;--or: circle(radius, extent)          # arc&#10;--or: circle(radius, extent, steps)&#10;--or: circle(radius, steps=6)         # 6-sided polygon&#10;&#10;Example:&#10;&gt;&gt;&gt; circle(50)&#10;&gt;&gt;&gt; circle(120, 180)  # semicircle">
				<Param name="radius" />
				<Param name="[extent=None" />
				<Param name="[steps=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.clear" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings from the screen. Do not move &#10;&#10;No arguments.&#10;&#10;Delete the turtle's drawings from the screen. Do not move &#10;State and position of the turtle as well as drawings of other&#10;turtles are not affected.&#10;&#10;Examples:&#10;&gt;&gt;&gt; clear()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.clearscreen" func="yes">
			<Overload retVal="" descr="Delete all drawings and all turtles from the TurtleScreen.&#10;&#10;Reset empty TurtleScreen to its initial state: white background,&#10;no backgroundimage, no eventbindings and tracing on.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; clear()&#10;&#10;Note: this method is not available as function.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.clearstamp" func="yes">
			<Overload retVal="" descr='Delete stamp with given stampid&#10;&#10;Argument:&#10;stampid - an integer, must be return value of previous stamp() call.&#10;&#10;Example:&#10;&gt;&gt;&gt; color("blue")&#10;&gt;&gt;&gt; astamp = stamp()&#10;&gt;&gt;&gt; fd(50)&#10;&gt;&gt;&gt; clearstamp(astamp)'>
				<Param name="stampid" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.clearstamps" func="yes">
			<Overload retVal="" descr="Delete all or first/last n of turtle's stamps.&#10;&#10;Optional argument:&#10;n -- an integer&#10;&#10;If n is None, delete all of pen's stamps,&#10;else if n &gt; 0 delete first n stamps&#10;else if n &lt; 0 delete last n stamps.&#10;&#10;Example:&#10;&gt;&gt;&gt; for i in range(8):&#10;...     stamp(); fd(30)&#10;...&#10;&gt;&gt;&gt; clearstamps(2)&#10;&gt;&gt;&gt; clearstamps(-2)&#10;&gt;&gt;&gt; clearstamps()">
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.clone" func="yes">
			<Overload retVal="" descr="Create and return a clone of the &#10;&#10;No argument.&#10;&#10;Create and return a clone of the turtle with same position, heading&#10;and turtle properties.&#10;&#10;Example (for a Turtle instance named mick):&#10;mick = Turtle()&#10;joe = mick.clone()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.color" func="yes">
			<Overload retVal="" descr="Return or set the pencolor and fillcolor.&#10;&#10;Arguments:&#10;Several input formats are allowed.&#10;They use 0, 1, 2, or 3 arguments as follows:&#10;&#10;color()&#10;    Return the current pencolor and the current fillcolor&#10;    as a pair of color specification strings as are returned&#10;    by pencolor and fillcolor.&#10;color(colorstring), color((r,g,b)), color(r,g,b)&#10;    inputs as in pencolor, set both, fillcolor and pencolor,&#10;    to the given value.&#10;color(colorstring1, colorstring2),&#10;color((r1,g1,b1), (r2,g2,b2))&#10;    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)&#10;    and analogously, if the other input format is used.&#10;&#10;If turtleshape is a polygon, outline and interior of that polygon&#10;is drawn with the newly set colors.&#10;For mor info see: pencolor, fillcolor&#10;&#10;Example:&#10;&gt;&gt;&gt; color('red', 'green')&#10;&gt;&gt;&gt; color()&#10;('red', 'green')&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))&#10;&gt;&gt;&gt; color()&#10;('#285078', '#a0c8f0')">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.colormode" func="yes">
			<Overload retVal="" descr="Return the colormode or set it to 1.0 or 255.&#10;&#10;Optional argument:&#10;cmode -- one of the values 1.0 or 255&#10;&#10;r, g, b values of colortriples have to be in range 0..cmode.&#10;&#10;Example:&#10;&gt;&gt;&gt; colormode()&#10;1.0&#10;&gt;&gt;&gt; colormode(255)&#10;&gt;&gt;&gt; pencolor(240,160,80)">
				<Param name="[cmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.config_dict" func="yes">
			<Overload retVal="" descr="Convert content of config-file into dictionary.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.copysign" func="yes">
			<Overload retVal="" descr="copysign(x, y)&#10;&#10;Return x with the sign of y.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.cos" func="yes">
			<Overload retVal="" descr="cos(x)&#10;&#10;Return the cosine of x (measured in radians).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.cosh" func="yes">
			<Overload retVal="" descr="cosh(x)&#10;&#10;Return the hyperbolic cosine of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.deepcopy" func="yes">
			<Overload retVal="" descr="Deep copy operation on arbitrary Python objects.&#10;&#10;See the module's __doc__ string for more info.">
				<Param name="x" />
				<Param name="[memo=None" />
				<Param name="[_nil=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.degrees" func="yes">
			<Overload retVal="" descr="Set angle measurement units to degrees.&#10;&#10;Optional argument:&#10;fullcircle -  a number&#10;&#10;Set angle measurement units, i. e. set number&#10;of 'degrees' for a full circle. Dafault value is&#10;360 degrees.&#10;&#10;Example:&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; heading()&#10;90&#10;&#10;Change angle measurement unit to grad (also known as gon,&#10;grade, or gradian and equals 1/100-th of the right angle.)&#10;&gt;&gt;&gt; degrees(400.0)&#10;&gt;&gt;&gt; heading()&#10;100">
				<Param name="[fullcircle=360.0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.delay" func="yes">
			<Overload retVal="" descr="Return or set the drawing delay in milliseconds.&#10;&#10;Optional argument:&#10;delay -- positive integer&#10;&#10;Example:&#10;&gt;&gt;&gt; delay(15)&#10;&gt;&gt;&gt; delay()&#10;15">
				<Param name="[delay=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.distance" func="yes">
			<Overload retVal="" descr="Return the distance from the turtle to (x,y) in turtle step units.&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Example:&#10;&gt;&gt;&gt; pos()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; distance(30,40)&#10;50.0&#10;&gt;&gt;&gt; pen = Turtle()&#10;&gt;&gt;&gt; pen.forward(77)&#10;&gt;&gt;&gt; distance(pen)&#10;77.0">
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.done" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.dot" func="yes">
			<Overload retVal="" descr='Draw a dot with diameter size, using color.&#10;&#10;Optional arguments:&#10;size -- an integer &gt;= 1 (if given)&#10;color -- a colorstring or a numeric color tuple&#10;&#10;Draw a circular dot with diameter size, using color.&#10;If size is not given, the maximum of pensize+4 and 2*pensize is used.&#10;&#10;Example:&#10;&gt;&gt;&gt; dot()&#10;&gt;&gt;&gt; fd(50); dot(20, "blue"); fd(50)'>
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.down" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; pendown()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.e" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.end_fill" func="yes">
			<Overload retVal="" descr="Fill the shape drawn after the call begin_fill().&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; begin_fill()&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; end_fill()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.end_poly" func="yes">
			<Overload retVal="" descr="Stop recording the vertices of a polygon.&#10;&#10;No argument.&#10;&#10;Stop recording the vertices of a polygon. Current turtle position is&#10;last point of polygon. This will be connected with the first point.&#10;&#10;Example:&#10;&gt;&gt;&gt; end_poly()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.erf" func="yes">
			<Overload retVal="" descr="erf(x)&#10;&#10;Error function at x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.erfc" func="yes">
			<Overload retVal="" descr="erfc(x)&#10;&#10;Complementary error function at x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.exitonclick" func="yes">
			<Overload retVal="" descr="Go into mainloop until the mouse is clicked.&#10;&#10;No arguments.&#10;&#10;Bind bye() method to mouseclick on TurtleScreen.&#10;If &quot;using_IDLE&quot; - value in configuration dictionary is False&#10;(default value), enter mainloop.&#10;If IDLE with -n switch (no subprocess) is used, this value should be&#10;set to True in turtle.cfg. In this case IDLE's mainloop&#10;is active also for the client script.&#10;&#10;This is a method of the Screen-class and not available for&#10;TurtleScreen instances.&#10;&#10;Example:&#10;&gt;&gt;&gt; exitonclick()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.exp" func="yes">
			<Overload retVal="" descr="exp(x)&#10;&#10;Return e raised to the power of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.expm1" func="yes">
			<Overload retVal="" descr="expm1(x)&#10;&#10;Return exp(x)-1.&#10;This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.fabs" func="yes">
			<Overload retVal="" descr="fabs(x)&#10;&#10;Return the absolute value of the float x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.factorial" func="yes">
			<Overload retVal="" descr="factorial(x) -&gt; Integral&#10;&#10;Find x!. Raise a ValueError if x is negative or non-integral.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.fd" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; forward(25)&#10;&gt;&gt;&gt; position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; forward(-75)&#10;&gt;&gt;&gt; position()&#10;(-50.00,0.00)">
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.fill" func="yes">
			<Overload retVal="" descr="Call fill(True) before drawing a shape to fill, fill(False) when done.&#10;&#10;Optional argument:&#10;flag -- True/False (or 1/0 respectively)&#10;&#10;Call fill(True) before drawing the shape you want to fill,&#10;and  fill(False) when done.&#10;When used without argument: return fillstate (True if filling,&#10;False else)&#10;&#10;Example:&#10;&gt;&gt;&gt; fill(True)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; left(90)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; fill(False)">
				<Param name="[flag=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.fillcolor" func="yes">
			<Overload retVal="" descr="Return or set the fillcolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - fillcolor()&#10;    Return the current fillcolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - fillcolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - fillcolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - fillcolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the interior of that polygon is drawn&#10;with the newly set fillcolor.&#10;&#10;Example:&#10;&gt;&gt;&gt; fillcolor('violet')&#10;&gt;&gt;&gt; col = pencolor()&#10;&gt;&gt;&gt; fillcolor(col)&#10;&gt;&gt;&gt; fillcolor(0, .5, 0)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.floor" func="yes">
			<Overload retVal="" descr="floor(x)&#10;&#10;Return the floor of x as a float.&#10;This is the largest integral value &lt;= x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.fmod" func="yes">
			<Overload retVal="" descr="fmod(x, y)&#10;&#10;Return fmod(x, y), according to platform C.  x % y may differ.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.forward" func="yes">
			<Overload retVal="" descr="Move the turtle forward by the specified distance.&#10;&#10;Aliases: forward | fd&#10;&#10;Argument:&#10;distance -- a number (integer or float)&#10;&#10;Move the turtle forward by the specified distance, in the direction&#10;the turtle is headed.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; forward(25)&#10;&gt;&gt;&gt; position()&#10;(25.00,0.00)&#10;&gt;&gt;&gt; forward(-75)&#10;&gt;&gt;&gt; position()&#10;(-50.00,0.00)">
				<Param name="distance" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.frexp" func="yes">
			<Overload retVal="" descr="frexp(x)&#10;&#10;Return the mantissa and exponent of x, as pair (m, e).&#10;m is a float and e is an int, such that x = m * 2.**e.&#10;If x is 0, m and e are both 0.  Else 0.5 &lt;= abs(m) &lt; 1.0.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.fsum" func="yes">
			<Overload retVal="" descr="fsum(iterable)&#10;&#10;Return an accurate floating point sum of values in the iterable.&#10;Assumes IEEE-754 floating point arithmetic.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.gamma" func="yes">
			<Overload retVal="" descr="gamma(x)&#10;&#10;Gamma function at x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.get_poly" func="yes">
			<Overload retVal="" descr='Return the lastly recorded polygon.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; p = get_poly()&#10;&gt;&gt;&gt; register_shape("myFavouriteShape", p)'>
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.getcanvas" func="yes">
			<Overload retVal="" descr="Return the Canvas of this TurtleScreen.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; cv = getcanvas()&#10;&gt;&gt;&gt; cv&#10;&lt;turtle.ScrolledCanvas instance at 0x010742D8&gt;">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.getmethparlist" func="yes">
			<Overload retVal="" descr="Get strings describing the arguments for the given object">
				<Param name="ob" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.getpen" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;Turtle object at 0x0187D810&gt;]">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.getscreen" func="yes">
			<Overload retVal="" descr='Return the TurtleScreen object, the turtle is drawing  on.&#10;&#10;No argument.&#10;&#10;Return the TurtleScreen object, the turtle is drawing  on.&#10;So TurtleScreen-methods can be called for that object.&#10;&#10;Example:&#10;&gt;&gt;&gt; ts = getscreen()&#10;&gt;&gt;&gt; ts&#10;&lt;TurtleScreen object at 0x0106B770&gt;&#10;&gt;&gt;&gt; ts.bgcolor("pink")'>
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.getshapes" func="yes">
			<Overload retVal="" descr="Return a list of names of all currently available turtle shapes.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; getshapes()&#10;['arrow', 'blank', 'circle', ... , 'turtle']">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.getturtle" func="yes">
			<Overload retVal="" descr="Return the Turtleobject itself.&#10;&#10;No argument.&#10;&#10;Only reasonable use: as a function to return the 'anonymous turtle':&#10;&#10;Example:&#10;&gt;&gt;&gt; pet = getturtle()&#10;&gt;&gt;&gt; pet.fd(50)&#10;&gt;&gt;&gt; pet&#10;&lt;Turtle object at 0x0187D810&gt;&#10;&gt;&gt;&gt; turtles()&#10;[&lt;Turtle object at 0x0187D810&gt;]">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.goto" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example:&#10;&gt;&gt;&gt; tp = pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; setpos(60,30)&#10;&gt;&gt;&gt; pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; setpos((20,80))&#10;&gt;&gt;&gt; pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; setpos(tp)&#10;&gt;&gt;&gt; pos()&#10;(0.00,0.00)">
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.heading" func="yes">
			<Overload retVal="" descr="Return the turtle's current heading.&#10;&#10;No arguments.&#10;&#10;Example:&#10;&gt;&gt;&gt; left(67)&#10;&gt;&gt;&gt; heading()&#10;67.0">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.hideturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example:&#10;&gt;&gt;&gt; hideturtle()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.home" func="yes">
			<Overload retVal="" descr="Move turtle to the origin - coordinates (0,0).&#10;&#10;No arguments.&#10;&#10;Move turtle to the origin - coordinates (0,0) and set its&#10;heading to its start-orientation (which depends on mode).&#10;&#10;Example:&#10;&gt;&gt;&gt; home()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ht" func="yes">
			<Overload retVal="" descr="Makes the turtle invisible.&#10;&#10;Aliases: hideturtle | ht&#10;&#10;No argument.&#10;&#10;It's a good idea to do this while you're in the&#10;middle of a complicated drawing, because hiding&#10;the turtle speeds up the drawing observably.&#10;&#10;Example:&#10;&gt;&gt;&gt; hideturtle()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.hypot" func="yes">
			<Overload retVal="" descr="hypot(x, y)&#10;&#10;Return the Euclidean distance, sqrt(x*x + y*y).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.isdown" func="yes">
			<Overload retVal="" descr="Return True if pen is down, False if it's up.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; penup()&#10;&gt;&gt;&gt; isdown()&#10;False&#10;&gt;&gt;&gt; pendown()&#10;&gt;&gt;&gt; isdown()&#10;True">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.isinf" func="yes">
			<Overload retVal="" descr="isinf(x) -&gt; bool&#10;&#10;Check if float x is infinite (positive or negative).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.isnan" func="yes">
			<Overload retVal="" descr="isnan(x) -&gt; bool&#10;&#10;Check if float x is not a number (NaN).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.isvisible" func="yes">
			<Overload retVal="" descr="Return True if the Turtle is shown, False if it's hidden.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; hideturtle()&#10;&gt;&gt;&gt; print isvisible():&#10;False">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.join" func="yes">
			<Overload retVal="" descr='Join two or more pathname components, inserting "\" as needed.'>
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ldexp" func="yes">
			<Overload retVal="" descr="ldexp(x, i)&#10;&#10;Return x * (2**i).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.left" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example:&#10;&gt;&gt;&gt; heading()&#10;22.0&#10;&gt;&gt;&gt; left(45)&#10;&gt;&gt;&gt; heading()&#10;67.0">
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.lgamma" func="yes">
			<Overload retVal="" descr="lgamma(x)&#10;&#10;Natural logarithm of absolute value of Gamma function at x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.listen" func="yes">
			<Overload retVal="" descr="Set focus on TurtleScreen (in order to collect key-events)&#10;&#10;No arguments.&#10;Dummy arguments are provided in order&#10;to be able to pass listen to the onclick method.&#10;&#10;Example:&#10;&gt;&gt;&gt; listen()">
				<Param name="[xdummy=None" />
				<Param name="[ydummy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.log" func="yes">
			<Overload retVal="" descr="log(x[, base])&#10;&#10;Return the logarithm of x to the given base.&#10;If the base not specified, returns the natural logarithm (base e) of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.log10" func="yes">
			<Overload retVal="" descr="log10(x)&#10;&#10;Return the base 10 logarithm of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.log1p" func="yes">
			<Overload retVal="" descr="log1p(x)&#10;&#10;Return the natural logarithm of 1+x (base e).&#10;The result is computed in a way which is accurate for x near zero.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.lt" func="yes">
			<Overload retVal="" descr="Turn turtle left by angle units.&#10;&#10;Aliases: left | lt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle left by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example:&#10;&gt;&gt;&gt; heading()&#10;22.0&#10;&gt;&gt;&gt; left(45)&#10;&gt;&gt;&gt; heading()&#10;67.0">
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.mainloop" func="yes">
			<Overload retVal="" descr="Run the main loop of Tcl.">
				<Param name="[n=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.mode" func="yes">
			<Overload retVal="" descr="Set turtle-mode ('standard', 'logo' or 'world') and perform reset.&#10;&#10;Optional argument:&#10;mode -- on of the strings 'standard', 'logo' or 'world'&#10;&#10;Mode 'standard' is compatible with turtle.py.&#10;Mode 'logo' is compatible with most Logo-Turtle-Graphics.&#10;Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: in&#10;this mode angles appear distorted if x/y unit-ratio doesn't equal 1.&#10;If mode is not given, return the current mode.&#10;&#10;     Mode      Initial turtle heading     positive angles&#10; ------------|-------------------------|-------------------&#10;  'standard'    to the right (east)       counterclockwise&#10;    'logo'        upward    (north)         clockwise&#10;&#10;Examples:&#10;&gt;&gt;&gt; mode('logo')   # resets turtle heading to north&#10;&gt;&gt;&gt; mode()&#10;'logo'">
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.modf" func="yes">
			<Overload retVal="" descr="modf(x)&#10;&#10;Return the fractional and integer parts of x.  Both results carry the sign&#10;of x and are floats.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.onclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun --  a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;add --  True or False. If True, new binding will be added, otherwise&#10;        it will replace a former binding.&#10;&#10;Example for the anonymous turtle, i. e. the procedural way:&#10;&#10;&gt;&gt;&gt; def turn(x, y):&#10;...     left(360)&#10;...&#10;&gt;&gt;&gt; onclick(turn)  # Now clicking into the turtle will turn it.&#10;&gt;&gt;&gt; onclick(None)  # event-binding will be removed">
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ondrag" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-move event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;       the coordinates of the clicked point on the canvas.&#10;num -- number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Every sequence of mouse-move-events on a turtle is preceded by a&#10;mouse-click event on that &#10;&#10;Example:&#10;&gt;&gt;&gt; ondrag(goto)&#10;&#10;Subsequently clicking and dragging a Turtle will move it&#10;across the screen thereby producing handdrawings (if pen is&#10;down).">
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.onkey" func="yes">
			<Overload retVal="" descr='Bind fun to key-release event of key.&#10;&#10;Arguments:&#10;fun -- a function with no arguments&#10;key -- a string: key (e.g. "a") or key-symbol (e.g. "space")&#10;&#10;In order to be able to register key-events, TurtleScreen&#10;must have focus. (See method listen.)&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; def f():&#10;...     fd(50)&#10;...     lt(60)&#10;...&#10;&gt;&gt;&gt; onkey(f, "Up")&#10;&gt;&gt;&gt; listen()&#10;&#10;Subsequently the turtle can be moved by repeatedly pressing&#10;the up-arrow key, consequently drawing a hexagon'>
				<Param name="fun" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.onrelease" func="yes">
			<Overload retVal="" descr='Bind fun to mouse-button-release event on this turtle on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, to which will be assigned&#10;        the coordinates of the clicked point on the canvas.&#10;num --  number of the mouse-button defaults to 1 (left mouse button).&#10;&#10;Example (for a MyTurtle instance named joe):&#10;&gt;&gt;&gt; class MyTurtle(Turtle):&#10;...     def glow(self,x,y):&#10;...             self.fillcolor("red")&#10;...     def unglow(self,x,y):&#10;...             self.fillcolor("")&#10;...&#10;&gt;&gt;&gt; joe = MyTurtle()&#10;&gt;&gt;&gt; joe.onclick(joe.glow)&#10;&gt;&gt;&gt; joe.onrelease(joe.unglow)&#10;&#10;Clicking on joe turns fillcolor red, unclicking turns it to&#10;transparent.'>
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.onscreenclick" func="yes">
			<Overload retVal="" descr="Bind fun to mouse-click event on canvas.&#10;&#10;Arguments:&#10;fun -- a function with two arguments, the coordinates of the&#10;       clicked point on the canvas.&#10;num -- the number of the mouse-button, defaults to 1&#10;&#10;Example (for a TurtleScreen instance named screen&#10;and a Turtle instance named turtle):&#10;&#10;&gt;&gt;&gt; onclick(goto)&#10;&gt;&gt;&gt; # Subsequently clicking into the TurtleScreen will&#10;&gt;&gt;&gt; # make the turtle move to the clicked point.&#10;&gt;&gt;&gt; onclick(None)">
				<Param name="fun" />
				<Param name="[btn=1" />
				<Param name="[add=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ontimer" func="yes">
			<Overload retVal="" descr="Install a timer, which calls fun after t milliseconds.&#10;&#10;Arguments:&#10;fun -- a function with no arguments.&#10;t -- a number &gt;= 0&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; running = True&#10;&gt;&gt;&gt; def f():&#10;...     if running:&#10;...             fd(50)&#10;...             lt(60)&#10;...             ontimer(f, 250)&#10;...&#10;&gt;&gt;&gt; f()   # makes the turtle marching around&#10;&gt;&gt;&gt; running = False">
				<Param name="fun" />
				<Param name="[t=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pd" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; pendown()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pen" func="yes">
			<Overload retVal="" descr="Return or set the pen's attributes.&#10;&#10;Arguments:&#10;    pen -- a dictionary with some or all of the below listed keys.&#10;    **pendict -- one or more keyword-arguments with the below&#10;                 listed keys as keywords.&#10;&#10;Return or set the pen's attributes in a 'pen-dictionary'&#10;with the following key/value pairs:&#10;   &quot;shown&quot;      :   True/False&#10;   &quot;pendown&quot;    :   True/False&#10;   &quot;pencolor&quot;   :   color-string or color-tuple&#10;   &quot;fillcolor&quot;  :   color-string or color-tuple&#10;   &quot;pensize&quot;    :   positive number&#10;   &quot;speed&quot;      :   number in range 0..10&#10;   &quot;resizemode&quot; :   &quot;auto&quot; or &quot;user&quot; or &quot;noresize&quot;&#10;   &quot;stretchfactor&quot;: (positive number, positive number)&#10;   &quot;outline&quot;    :   positive number&#10;   &quot;tilt&quot;       :   number&#10;&#10;This dictionary can be used as argument for a subsequent&#10;pen()-call to restore the former pen-state. Moreover one&#10;or more of these attributes can be provided as keyword-arguments.&#10;This can be used to set several pen attributes in one statement.&#10;&#10;&#10;Examples:&#10;&gt;&gt;&gt; pen(fillcolor=&quot;black&quot;, pencolor=&quot;red&quot;, pensize=10)&#10;&gt;&gt;&gt; pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; penstate=pen()&#10;&gt;&gt;&gt; color(&quot;yellow&quot;,&quot;&quot;)&#10;&gt;&gt;&gt; penup()&#10;&gt;&gt;&gt; pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',&#10;'stretchfactor': (1,1), 'speed': 3}&#10;&gt;&gt;&gt; p.pen(penstate, fillcolor=&quot;green&quot;)&#10;&gt;&gt;&gt; p.pen()&#10;{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,&#10;'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',&#10;'stretchfactor': (1,1), 'speed': 3}">
				<Param name="[pen=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pencolor" func="yes">
			<Overload retVal="" descr="Return or set the pencolor.&#10;&#10;Arguments:&#10;Four input formats are allowed:&#10;  - pencolor()&#10;    Return the current pencolor as color specification string,&#10;    possibly in hex-number format (see example).&#10;    May be used as input to another color/pencolor/fillcolor call.&#10;  - pencolor(colorstring)&#10;    s is a Tk color specification string, such as &quot;red&quot; or &quot;yellow&quot;&#10;  - pencolor((r, g, b))&#10;    *a tuple* of r, g, and b, which represent, an RGB color,&#10;    and each of r, g, and b are in the range 0..colormode,&#10;    where colormode is either 1.0 or 255&#10;  - pencolor(r, g, b)&#10;    r, g, and b represent an RGB color, and each of r, g, and b&#10;    are in the range 0..colormode&#10;&#10;If turtleshape is a polygon, the outline of that polygon is drawn&#10;with the newly set pencolor.&#10;&#10;Example:&#10;&gt;&gt;&gt; pencolor('brown')&#10;&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)&#10;&gt;&gt;&gt; pencolor(tup)&#10;&gt;&gt;&gt; pencolor()&#10;'#33cc8c'">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pendown" func="yes">
			<Overload retVal="" descr="Pull the pen down -- drawing when moving.&#10;&#10;Aliases: pendown | pd | down&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; pendown()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pensize" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example:&#10;&gt;&gt;&gt; pensize()&#10;1&#10;&gt;&gt;&gt; pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.penup" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example:&#10;&gt;&gt;&gt; penup()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pi" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pos" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example:&#10;&gt;&gt;&gt; pos()&#10;(0.00, 240.00)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.position" func="yes">
			<Overload retVal="" descr="Return the turtle's current location (x,y), as a Vec2D-vector.&#10;&#10;Aliases: pos | position&#10;&#10;No arguments.&#10;&#10;Example:&#10;&gt;&gt;&gt; pos()&#10;(0.00, 240.00)">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pow" func="yes">
			<Overload retVal="" descr="pow(x, y)&#10;&#10;Return x**y (x to the power of y).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.pu" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example:&#10;&gt;&gt;&gt; penup()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.radians" func="yes">
			<Overload retVal="" descr="Set the angle measurement units to radians.&#10;&#10;No arguments.&#10;&#10;Example:&#10;&gt;&gt;&gt; heading()&#10;90&#10;&gt;&gt;&gt; radians()&#10;&gt;&gt;&gt; heading()&#10;1.5707963267948966">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.read_docstrings" func="yes">
			<Overload retVal="" descr="Read in docstrings from lang-specific docstring dictionary.&#10;&#10;Transfer docstrings, translated to lang, from a dictionary-file&#10;to the methods of classes Screen and Turtle and - in revised form -&#10;to the corresponding functions.">
				<Param name="lang" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.readconfig" func="yes">
			<Overload retVal="" descr="Read config-files, change configuration-dict accordingly.&#10;&#10;If there is a turtle.cfg file in the current working directory,&#10;read it from there. If this contains an importconfig-value,&#10;say 'myway', construct filename turtle_mayway.cfg else use&#10;turtle.cfg and read it from the import-directory, where&#10;turtle.py is located.&#10;Update configuration dictionary first according to config-file,&#10;in the import directory, then according to config-file in the&#10;current working directory.&#10;If no config-file is found, the default configuration is used.">
				<Param name="cfgdict" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.register_shape" func="yes">
			<Overload retVal="" descr="Adds a turtle shape to TurtleScreen's shapelist.&#10;&#10;Arguments:&#10;(1) name is the name of a gif-file and shape is None.&#10;    Installs the corresponding image shape.&#10;    !! Image-shapes DO NOT rotate when turning the turtle,&#10;    !! so they do not display the heading of the turtle!&#10;(2) name is an arbitrary string and shape is a tuple&#10;    of pairs of coordinates. Installs the corresponding&#10;    polygon shape&#10;(3) name is an arbitrary string and shape is a&#10;    (compound) Shape object. Installs the corresponding&#10;    compound shape.&#10;To use a shape, you have to issue the command shape(shapename).&#10;&#10;call: register_shape(&quot;turtle.gif&quot;)&#10;--or: register_shape(&quot;tri&quot;, ((0,0), (10,10), (-10,10)))&#10;&#10;Example:&#10;&gt;&gt;&gt; register_shape(&quot;triangle&quot;, ((5,-3),(0,5),(-5,-3)))">
				<Param name="name" />
				<Param name="[shape=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.reset" func="yes">
			<Overload retVal="" descr="Delete the turtle's drawings and restore its default values.&#10;&#10;        No argument.&#10;,&#10;        Delete the turtle's drawings from the screen, re-center the turtle&#10;        and set variables to the default values.&#10;&#10;        Example:&#10;        &gt;&gt;&gt; position()&#10;        (0.00,-22.00)&#10;        &gt;&gt;&gt; heading()&#10;        100.0&#10;        &gt;&gt;&gt; reset()&#10;        &gt;&gt;&gt; position()&#10;        (0.00,0.00)&#10;        &gt;&gt;&gt; heading()&#10;        0.0">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.resetscreen" func="yes">
			<Overload retVal="" descr="Reset all Turtles on the Screen to their initial state.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; reset()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.resizemode" func="yes">
			<Overload retVal="" descr="Set resizemode to one of the values: &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;.&#10;&#10;(Optional) Argument:&#10;rmode -- one of the strings &quot;auto&quot;, &quot;user&quot;, &quot;noresize&quot;&#10;&#10;Different resizemodes have the following effects:&#10;  - &quot;auto&quot; adapts the appearance of the turtle&#10;           corresponding to the value of pensize.&#10;  - &quot;user&quot; adapts the appearance of the turtle according to the&#10;           values of stretchfactor and outlinewidth (outline),&#10;           which are set by shapesize()&#10;  - &quot;noresize&quot; no adaption of the turtle's appearance takes place.&#10;If no argument is given, return current resizemode.&#10;resizemode(&quot;user&quot;) is called by a call of shapesize with arguments.&#10;&#10;&#10;Examples:&#10;&gt;&gt;&gt; resizemode(&quot;noresize&quot;)&#10;&gt;&gt;&gt; resizemode()&#10;'noresize'">
				<Param name="[rmode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.right" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example:&#10;&gt;&gt;&gt; heading()&#10;22.0&#10;&gt;&gt;&gt; right(45)&#10;&gt;&gt;&gt; heading()&#10;337.0">
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.rt" func="yes">
			<Overload retVal="" descr="Turn turtle right by angle units.&#10;&#10;Aliases: right | rt&#10;&#10;Argument:&#10;angle -- a number (integer or float)&#10;&#10;Turn turtle right by angle units. (Units are by default degrees,&#10;but can be set via the degrees() and radians() functions.)&#10;Angle orientation depends on mode. (See this.)&#10;&#10;Example:&#10;&gt;&gt;&gt; heading()&#10;22.0&#10;&gt;&gt;&gt; right(45)&#10;&gt;&gt;&gt; heading()&#10;337.0">
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.screensize" func="yes">
			<Overload retVal="" descr="Resize the canvas the turtles are drawing on.&#10;&#10;Optional arguments:&#10;canvwidth -- positive integer, new width of canvas in pixels&#10;canvheight --  positive integer, new height of canvas in pixels&#10;bg -- colorstring or color-tuple, new backgroundcolor&#10;If no arguments are given, return current (canvaswidth, canvasheight)&#10;&#10;Do not alter the drawing window. To observe hidden parts of&#10;the canvas use the scrollbars. (Can make visible those parts&#10;of a drawing, which were outside the canvas before!)&#10;&#10;Example (for a Turtle instance named turtle):&#10;&gt;&gt;&gt; turtle.screensize(2000,1500)&#10;&gt;&gt;&gt; # e. g. to search for an erroneously escaped turtle ;-)">
				<Param name="[canvwidth=None" />
				<Param name="[canvheight=None" />
				<Param name="[bg=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.seth" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example:&#10;&gt;&gt;&gt; setheading(90)&#10;&gt;&gt;&gt; heading()&#10;90">
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setheading" func="yes">
			<Overload retVal="" descr="Set the orientation of the turtle to to_angle.&#10;&#10;Aliases:  setheading | seth&#10;&#10;Argument:&#10;to_angle -- a number (integer or float)&#10;&#10;Set the orientation of the turtle to to_angle.&#10;Here are some common directions in degrees:&#10;&#10; standard - mode:          logo-mode:&#10;-------------------|--------------------&#10;   0 - east                0 - north&#10;  90 - north              90 - east&#10; 180 - west              180 - south&#10; 270 - south             270 - west&#10;&#10;Example:&#10;&gt;&gt;&gt; setheading(90)&#10;&gt;&gt;&gt; heading()&#10;90">
				<Param name="to_angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setpos" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example:&#10;&gt;&gt;&gt; tp = pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; setpos(60,30)&#10;&gt;&gt;&gt; pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; setpos((20,80))&#10;&gt;&gt;&gt; pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; setpos(tp)&#10;&gt;&gt;&gt; pos()&#10;(0.00,0.00)">
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setposition" func="yes">
			<Overload retVal="" descr="Move turtle to an absolute position.&#10;&#10;Aliases: setpos | setposition | goto:&#10;&#10;Arguments:&#10;x -- a number      or     a pair/vector of numbers&#10;y -- a number             None&#10;&#10;call: goto(x, y)         # two coordinates&#10;--or: goto((x, y))       # a pair (tuple) of coordinates&#10;--or: goto(vec)          # e.g. as returned by pos()&#10;&#10;Move turtle to an absolute position. If the pen is down,&#10;a line will be drawn. The turtle's orientation does not change.&#10;&#10;Example:&#10;&gt;&gt;&gt; tp = pos()&#10;&gt;&gt;&gt; tp&#10;(0.00, 0.00)&#10;&gt;&gt;&gt; setpos(60,30)&#10;&gt;&gt;&gt; pos()&#10;(60.00,30.00)&#10;&gt;&gt;&gt; setpos((20,80))&#10;&gt;&gt;&gt; pos()&#10;(20.00,80.00)&#10;&gt;&gt;&gt; setpos(tp)&#10;&gt;&gt;&gt; pos()&#10;(0.00,0.00)">
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.settiltangle" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape to point in the specified direction&#10;&#10;Optional argument:&#10;angle -- number&#10;&#10;Rotate the turtleshape to point in the direction specified by angle,&#10;regardless of its current tilt-angle. DO NOT change the turtle's&#10;heading (direction of movement).&#10;&#10;&#10;Examples:&#10;&gt;&gt;&gt; shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; shapesize(5,2)&#10;&gt;&gt;&gt; settiltangle(45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; fd(50)&#10;&gt;&gt;&gt; settiltangle(-45)&#10;&gt;&gt;&gt; stamp()&#10;&gt;&gt;&gt; fd(50)">
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setundobuffer" func="yes">
			<Overload retVal="" descr="Set or disable undobuffer.&#10;&#10;Argument:&#10;size -- an integer or None&#10;&#10;If size is an integer an empty undobuffer of given size is installed.&#10;Size gives the maximum number of turtle-actions that can be undone&#10;by the undo() function.&#10;If size is None, no undobuffer is present.&#10;&#10;Example:&#10;&gt;&gt;&gt; setundobuffer(42)">
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setup" func="yes">
			<Overload retVal="" descr="Set the size and position of the main window.&#10;&#10;Arguments:&#10;width: as integer a size in pixels, as float a fraction of the &#10;  Default is 50% of &#10;height: as integer the height in pixels, as float a fraction of the&#10;   Default is 75% of &#10;startx: if positive, starting position in pixels from the left&#10;  edge of the screen, if negative from the right edge&#10;  Default, startx=None is to center window horizontally.&#10;starty: if positive, starting position in pixels from the top&#10;  edge of the screen, if negative from the bottom edge&#10;  Default, starty=None is to center window vertically.&#10;&#10;Examples:&#10;&gt;&gt;&gt; setup (width=200, height=200, startx=0, starty=0)&#10;&#10;sets window to 200x200 pixels, in upper left of screen&#10;&#10;&gt;&gt;&gt; setup(width=.75, height=0.5, startx=None, starty=None)&#10;&#10;sets window to 75% of screen by 50% of screen and centers">
				<Param name="[width=0.5" />
				<Param name="[height=0.75" />
				<Param name="[startx=None" />
				<Param name="[starty=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setworldcoordinates" func="yes">
			<Overload retVal="" descr="Set up a user defined coordinate-system.&#10;&#10;Arguments:&#10;llx -- a number, x-coordinate of lower left corner of canvas&#10;lly -- a number, y-coordinate of lower left corner of canvas&#10;urx -- a number, x-coordinate of upper right corner of canvas&#10;ury -- a number, y-coordinate of upper right corner of canvas&#10;&#10;Set up user coodinat-system and switch to mode 'world' if necessary.&#10;This performs a reset. If mode 'world' is already active,&#10;all drawings are redrawn according to the new coordinates.&#10;&#10;But ATTENTION: in user-defined coordinatesystems angles may appear&#10;distorted. (see Screen.mode())&#10;&#10;Example:&#10;&gt;&gt;&gt; setworldcoordinates(-10,-0.5,50,1.5)&#10;&gt;&gt;&gt; for _ in range(36):&#10;...     left(10)&#10;...     forward(0.5)">
				<Param name="llx" />
				<Param name="lly" />
				<Param name="urx" />
				<Param name="ury" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.setx" func="yes">
			<Overload retVal="" descr="Set the turtle's first coordinate to x&#10;&#10;Argument:&#10;x -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, leave second coordinate&#10;unchanged.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 240.00)&#10;&gt;&gt;&gt; setx(10)&#10;&gt;&gt;&gt; position()&#10;(10.00, 240.00)">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.sety" func="yes">
			<Overload retVal="" descr="Set the turtle's second coordinate to y&#10;&#10;Argument:&#10;y -- a number (integer or float)&#10;&#10;Set the turtle's first coordinate to x, second coordinate remains&#10;unchanged.&#10;&#10;Example:&#10;&gt;&gt;&gt; position()&#10;(0.00, 40.00)&#10;&gt;&gt;&gt; sety(-10)&#10;&gt;&gt;&gt; position()&#10;(0.00, -10.00)">
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.shape" func="yes">
			<Overload retVal="" descr="Set turtle shape to shape with given name / return current shapename.&#10;&#10;Optional argument:&#10;name -- a string, which is a valid shapename&#10;&#10;Set turtle shape to shape with given name or, if name is not given,&#10;return name of current shape.&#10;Shape with name must exist in the TurtleScreen's shape dictionary.&#10;Initially there are the following polygon shapes:&#10;'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.&#10;To learn about how to deal with shapes see Screen-method register_shape.&#10;&#10;Example:&#10;&gt;&gt;&gt; shape()&#10;'arrow'&#10;&gt;&gt;&gt; shape(&quot;turtle&quot;)&#10;&gt;&gt;&gt; shape()&#10;'turtle'">
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.shapesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples:&#10;&gt;&gt;&gt; resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; shapesize(5, 5, 12)&#10;&gt;&gt;&gt; shapesize(outline=8)">
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.showturtle" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; hideturtle()&#10;&gt;&gt;&gt; showturtle()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.sin" func="yes">
			<Overload retVal="" descr="sin(x)&#10;&#10;Return the sine of x (measured in radians).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.sinh" func="yes">
			<Overload retVal="" descr="sinh(x)&#10;&#10;Return the hyperbolic sine of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.speed" func="yes">
			<Overload retVal="" descr="Return or set the turtle's speed.&#10;&#10;Optional argument:&#10;speed -- an integer in the range 0..10 or a speedstring (see below)&#10;&#10;Set the turtle's speed to an integer value in the range 0 .. 10.&#10;If no argument is given: return current speed.&#10;&#10;If input is a number greater than 10 or smaller than 0.5,&#10;speed is set to 0.&#10;Speedstrings  are mapped to speedvalues in the following way:&#10;    'fastest' :  0&#10;    'fast'    :  10&#10;    'normal'  :  6&#10;    'slow'    :  3&#10;    'slowest' :  1&#10;speeds from 1 to 10 enforce increasingly faster animation of&#10;line drawing and turtle turning.&#10;&#10;Attention:&#10;speed = 0 : *no* animation takes place. forward/back makes turtle jump&#10;and likewise left/right make the turtle turn instantly.&#10;&#10;Example:&#10;&gt;&gt;&gt; speed(3)">
				<Param name="[speed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.split" func="yes">
			<Overload retVal="" descr="Split a pathname.&#10;&#10;Return tuple (head, tail) where tail is everything after the final slash.&#10;Either part may be empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.sqrt" func="yes">
			<Overload retVal="" descr="sqrt(x)&#10;&#10;Return the square root of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.st" func="yes">
			<Overload retVal="" descr="Makes the turtle visible.&#10;&#10;Aliases: showturtle | st&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; hideturtle()&#10;&gt;&gt;&gt; showturtle()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.stamp" func="yes">
			<Overload retVal="" descr='Stamp a copy of the turtleshape onto the canvas and return its id.&#10;&#10;No argument.&#10;&#10;Stamp a copy of the turtle shape onto the canvas at the current&#10;turtle position. Return a stamp_id for that stamp, which can be&#10;used to delete it by calling clearstamp(stamp_id).&#10;&#10;Example:&#10;&gt;&gt;&gt; color("blue")&#10;&gt;&gt;&gt; stamp()&#10;13&#10;&gt;&gt;&gt; fd(50)'>
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.tan" func="yes">
			<Overload retVal="" descr="tan(x)&#10;&#10;Return the tangent of x (measured in radians).">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.tanh" func="yes">
			<Overload retVal="" descr="tanh(x)&#10;&#10;Return the hyperbolic tangent of x.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.tilt" func="yes">
			<Overload retVal="" descr="Rotate the turtleshape by angle.&#10;&#10;Argument:&#10;angle - a number&#10;&#10;Rotate the turtleshape by angle from its current tilt-angle,&#10;but do NOT change the turtle's heading (direction of movement).&#10;&#10;Examples:&#10;&gt;&gt;&gt; shape(&quot;circle&quot;)&#10;&gt;&gt;&gt; shapesize(5,2)&#10;&gt;&gt;&gt; tilt(30)&#10;&gt;&gt;&gt; fd(50)&#10;&gt;&gt;&gt; tilt(30)&#10;&gt;&gt;&gt; fd(50)">
				<Param name="angle" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.tiltangle" func="yes">
			<Overload retVal="" descr='Return the current tilt-angle.&#10;&#10;No argument.&#10;&#10;Return the current tilt-angle, i. e. the angle between the&#10;orientation of the turtleshape and the heading of the turtle&#10;(its direction of movement).&#10;&#10;Examples:&#10;&gt;&gt;&gt; shape("circle")&#10;&gt;&gt;&gt; shapesize(5,2)&#10;&gt;&gt;&gt; tilt(45)&#10;&gt;&gt;&gt; tiltangle()'>
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.title" func="yes">
			<Overload retVal="" descr='Set title of turtle-window&#10;&#10;Argument:&#10;titlestring -- a string, to appear in the titlebar of the&#10;               turtle graphics window.&#10;&#10;This is a method of Screen-class. Not available for TurtleScreen-&#10;objects.&#10;&#10;Example:&#10;&gt;&gt;&gt; title("Welcome to the turtle-zoo!")'>
				<Param name="titlestring" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.towards" func="yes">
			<Overload retVal="" descr="Return the angle of the line from the turtle's position to (x, y).&#10;&#10;Arguments:&#10;x -- a number   or  a pair/vector of numbers   or   a turtle instance&#10;y -- a number       None                            None&#10;&#10;call: distance(x, y)         # two coordinates&#10;--or: distance((x, y))       # a pair (tuple) of coordinates&#10;--or: distance(vec)          # e.g. as returned by pos()&#10;--or: distance(mypen)        # where mypen is another turtle&#10;&#10;Return the angle, between the line from turtle-position to position&#10;specified by x, y and the turtle's start orientation. (Depends on&#10;modes - &quot;standard&quot; or &quot;logo&quot;)&#10;&#10;Example:&#10;&gt;&gt;&gt; pos()&#10;(10.00, 10.00)&#10;&gt;&gt;&gt; towards(0,0)&#10;225.0">
				<Param name="x" />
				<Param name="[y=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.tracer" func="yes">
			<Overload retVal="" descr="Turns turtle animation on/off and set delay for update drawings.&#10;&#10;Optional arguments:&#10;n -- nonnegative  integer&#10;delay -- nonnegative  integer&#10;&#10;If n is given, only each n-th regular screen update is really performed.&#10;(Can be used to accelerate the drawing of complex graphics.)&#10;Second arguments sets delay value (see RawTurtle.delay())&#10;&#10;Example:&#10;&gt;&gt;&gt; tracer(8, 25)&#10;&gt;&gt;&gt; dist = 2&#10;&gt;&gt;&gt; for i in range(200):&#10;...     fd(dist)&#10;...     rt(90)&#10;...     dist += 2">
				<Param name="[flag=None" />
				<Param name="[delay=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.trunc" func="yes">
			<Overload retVal="" descr="trunc(x:Real) -&gt; Integral&#10;&#10;Truncates x to the nearest Integral toward 0. Uses the __trunc__ magic method.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.turtles" func="yes">
			<Overload retVal="" descr="Return the list of turtles on the &#10;&#10;Example:&#10;&gt;&gt;&gt; turtles()&#10;[&lt;turtle.Turtle object at 0x00E11FB0&gt;]">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.turtlesize" func="yes">
			<Overload retVal="" descr="Set/return turtle's stretchfactors/outline. Set resizemode to &quot;user&quot;.&#10;&#10;Optional arguments:&#10;   stretch_wid : positive number&#10;   stretch_len : positive number&#10;   outline  : positive number&#10;&#10;Return or set the pen's attributes x/y-stretchfactors and/or outline.&#10;Set resizemode to &quot;user&quot;.&#10;If and only if resizemode is set to &quot;user&quot;, the turtle will be displayed&#10;stretched according to its stretchfactors:&#10;stretch_wid is stretchfactor perpendicular to orientation&#10;stretch_len is stretchfactor in direction of turtles orientation.&#10;outline determines the width of the shapes's outline.&#10;&#10;Examples:&#10;&gt;&gt;&gt; resizemode(&quot;user&quot;)&#10;&gt;&gt;&gt; shapesize(5, 5, 12)&#10;&gt;&gt;&gt; shapesize(outline=8)">
				<Param name="[stretch_wid=None" />
				<Param name="[stretch_len=None" />
				<Param name="[outline=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.undo" func="yes">
			<Overload retVal="" descr="undo (repeatedly) the last turtle action.&#10;&#10;No argument.&#10;&#10;undo (repeatedly) the last turtle action.&#10;Number of available undo actions is determined by the size of&#10;the undobuffer.&#10;&#10;Example:&#10;&gt;&gt;&gt; for i in range(4):&#10;...     fd(50); lt(80)&#10;...&#10;&gt;&gt;&gt; for i in range(8):&#10;...     undo()&#10;...">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.undobufferentries" func="yes">
			<Overload retVal="" descr="Return count of entries in the undobuffer.&#10;&#10;No argument.&#10;&#10;Example:&#10;&gt;&gt;&gt; while undobufferentries():&#10;...     undo()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.up" func="yes">
			<Overload retVal="" descr="Pull the pen up -- no drawing when moving.&#10;&#10;Aliases: penup | pu | up&#10;&#10;No argument&#10;&#10;Example:&#10;&gt;&gt;&gt; penup()">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.update" func="yes">
			<Overload retVal="" descr="Perform a TurtleScreen update.">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.width" func="yes">
			<Overload retVal="" descr='Set or return the line thickness.&#10;&#10;Aliases:  pensize | width&#10;&#10;Argument:&#10;width -- positive number&#10;&#10;Set the line thickness to width or return it. If resizemode is set&#10;to "auto" and turtleshape is a polygon, that polygon is drawn with&#10;the same line thickness. If no argument is given, current pensize&#10;is returned.&#10;&#10;Example:&#10;&gt;&gt;&gt; pensize()&#10;1&#10;&gt;&gt;&gt; pensize(10)   # from here on lines of width 10 are drawn'>
				<Param name="[width=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.window_height" func="yes">
			<Overload retVal="" descr="Return the height of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_height()&#10;480">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.window_width" func="yes">
			<Overload retVal="" descr="Returns the width of the turtle window.&#10;&#10;No argument.&#10;&#10;Example (for a TurtleScreen instance named screen):&#10;&gt;&gt;&gt; screen.window_width()&#10;640">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.write" func="yes">
			<Overload retVal="" descr="Write text at the current turtle position.&#10;&#10;Arguments:&#10;arg -- info, which is to be written to the TurtleScreen&#10;move (optional) -- True/False&#10;align (optional) -- one of the strings &quot;left&quot;, &quot;center&quot; or right&quot;&#10;font (optional) -- a triple (fontname, fontsize, fonttype)&#10;&#10;Write text - the string representation of arg - at the current&#10;turtle position according to align (&quot;left&quot;, &quot;center&quot; or right&quot;)&#10;and with the given font.&#10;If move is True, the pen is moved to the bottom-right corner&#10;of the text. By default, move is False.&#10;&#10;Example:&#10;&gt;&gt;&gt; write('Home = ', True, align=&quot;center&quot;)&#10;&gt;&gt;&gt; write((0,0), True)">
				<Param name="arg" />
				<Param name="[move=False" />
				<Param name="[align=left" />
				<Param name="[font=('Arial', 8, 'normal')]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.write_docstringdict" func="yes">
			<Overload retVal="" descr="Create and write docstring-dictionary to file.&#10;&#10;Optional argument:&#10;filename -- a string, used as filename&#10;            default value is turtle_docstringdict&#10;&#10;Has to be called explicitly, (not used by the turtle-graphics classes)&#10;The docstring dictionary will be written to the Python script &lt;filname&gt;.py&#10;It is intended to serve as a template for translation of the docstrings&#10;into different languages.">
				<Param name="[filename=turtle_docstringdict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.xcor" func="yes">
			<Overload retVal="" descr="Return the turtle's x coordinate.&#10;&#10;No arguments.&#10;&#10;Example:&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; left(60)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; print xcor()&#10;50.0">
			</Overload>
		</KeyWord>
		<KeyWord name="turtle.ycor" func="yes">
			<Overload retVal="" descr="Return the turtle's y coordinate&#10;---&#10;No arguments.&#10;&#10;Example:&#10;&gt;&gt;&gt; reset()&#10;&gt;&gt;&gt; left(60)&#10;&gt;&gt;&gt; forward(100)&#10;&gt;&gt;&gt; print ycor()&#10;86.6025403784">
			</Overload>
		</KeyWord>
		<KeyWord name="turtles" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="turtlesize" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="type" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="types" func="yes">
			<Overload retVal="" descr="Define names for all type symbols known in the standard interpreter.&#10;&#10;Types that are part of optional modules (e.g. array) are not listed.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BuiltinFunctionType" />
		<KeyWord name="types.BuiltinMethodType" />
		<KeyWord name="types.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType" />
		<KeyWord name="types.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="types.EllipsisType" />
		<KeyWord name="types.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType" />
		<KeyWord name="types.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType" />
		<KeyWord name="types.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GetSetDescriptorType" />
		<KeyWord name="types.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MemberDescriptorType" />
		<KeyWord name="types.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.NoneType" />
		<KeyWord name="types.NotImplementedType" />
		<KeyWord name="types.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="types.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType" />
		<KeyWord name="types.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="tzname" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="umask" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="uname" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="unbind" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="unbind_all" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="unbind_class" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="undo" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="undobufferentries" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="unexpo" func="yes">
			<Overload retVal="" descr="Function of fpformat">
			</Overload>
		</KeyWord>
		<KeyWord name="unhex" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="unichr" func="yes">
			<Overload retVal="" descr="unichr(i) -&gt; Unicode character&#10;&#10;Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_escape_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_escape_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_internal_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_internal_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata" func="yes">
			<Overload retVal="" descr="This module provides access to the Unicode Character Database which&#10;defines character properties for all Unicode characters. The data in&#10;this database is based on the UnicodeData.txt file version&#10;5.2.0 which is publically available from ftp://ftp.unicode.org/.&#10;&#10;The module uses the same names and symbols as defined by the&#10;UnicodeData File Format 5.2.0 (see&#10;http://www.unicode.org/reports/tr44/tr44-4.html).">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD" />
		<KeyWord name="unicodedata.UCD.bidirectional" func="yes">
			<Overload retVal="" descr="bidirectional(unichr)&#10;&#10;Returns the bidirectional class assigned to the Unicode character&#10;unichr as string. If no such value is defined, an empty string is&#10;returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.category" func="yes">
			<Overload retVal="" descr="category(unichr)&#10;&#10;Returns the general category assigned to the Unicode character&#10;unichr as string.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.combining" func="yes">
			<Overload retVal="" descr="combining(unichr)&#10;&#10;Returns the canonical combining class assigned to the Unicode&#10;character unichr as integer. Returns 0 if no combining class is&#10;defined.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.decimal" func="yes">
			<Overload retVal="" descr="decimal(unichr[, default])&#10;&#10;Returns the decimal value assigned to the Unicode character unichr&#10;as integer. If no such value is defined, default is returned, or, if&#10;not given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.decomposition" func="yes">
			<Overload retVal="" descr="decomposition(unichr)&#10;&#10;Returns the character decomposition mapping assigned to the Unicode&#10;character unichr as string. An empty string is returned in case no&#10;such mapping is defined.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.digit" func="yes">
			<Overload retVal="" descr="digit(unichr[, default])&#10;&#10;Returns the digit value assigned to the Unicode character unichr as&#10;integer. If no such value is defined, default is returned, or, if&#10;not given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.east_asian_width" func="yes">
			<Overload retVal="" descr="east_asian_width(unichr)&#10;&#10;Returns the east asian width assigned to the Unicode character&#10;unichr as string.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.lookup" func="yes">
			<Overload retVal="" descr="lookup(name)&#10;&#10;Look up character by name.  If a character with the&#10;given name is found, return the corresponding Unicode&#10;character.  If not found, KeyError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.mirrored" func="yes">
			<Overload retVal="" descr='mirrored(unichr)&#10;&#10;Returns the mirrored property assigned to the Unicode character&#10;unichr as integer. Returns 1 if the character has been identified as&#10;a "mirrored" character in bidirectional text, 0 otherwise.'>
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.name" func="yes">
			<Overload retVal="" descr="name(unichr[, default])&#10;Returns the name assigned to the Unicode character unichr as a&#10;string. If no name is defined, default is returned, or, if not&#10;given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.normalize" func="yes">
			<Overload retVal="" descr="normalize(form, unistr)&#10;&#10;Return the normal form 'form' for the Unicode string unistr.  Valid&#10;values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.numeric" func="yes">
			<Overload retVal="" descr="numeric(unichr[, default])&#10;&#10;Returns the numeric value assigned to the Unicode character unichr&#10;as float. If no such value is defined, default is returned, or, if&#10;not given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.unidata_version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.bidirectional" func="yes">
			<Overload retVal="" descr="bidirectional(unichr)&#10;&#10;Returns the bidirectional class assigned to the Unicode character&#10;unichr as string. If no such value is defined, an empty string is&#10;returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.category" func="yes">
			<Overload retVal="" descr="category(unichr)&#10;&#10;Returns the general category assigned to the Unicode character&#10;unichr as string.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.combining" func="yes">
			<Overload retVal="" descr="combining(unichr)&#10;&#10;Returns the canonical combining class assigned to the Unicode&#10;character unichr as integer. Returns 0 if no combining class is&#10;defined.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.decimal" func="yes">
			<Overload retVal="" descr="decimal(unichr[, default])&#10;&#10;Returns the decimal value assigned to the Unicode character unichr&#10;as integer. If no such value is defined, default is returned, or, if&#10;not given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.decomposition" func="yes">
			<Overload retVal="" descr="decomposition(unichr)&#10;&#10;Returns the character decomposition mapping assigned to the Unicode&#10;character unichr as string. An empty string is returned in case no&#10;such mapping is defined.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.digit" func="yes">
			<Overload retVal="" descr="digit(unichr[, default])&#10;&#10;Returns the digit value assigned to the Unicode character unichr as&#10;integer. If no such value is defined, default is returned, or, if&#10;not given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.east_asian_width" func="yes">
			<Overload retVal="" descr="east_asian_width(unichr)&#10;&#10;Returns the east asian width assigned to the Unicode character&#10;unichr as string.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.lookup" func="yes">
			<Overload retVal="" descr="lookup(name)&#10;&#10;Look up character by name.  If a character with the&#10;given name is found, return the corresponding Unicode&#10;character.  If not found, KeyError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.mirrored" func="yes">
			<Overload retVal="" descr='mirrored(unichr)&#10;&#10;Returns the mirrored property assigned to the Unicode character&#10;unichr as integer. Returns 1 if the character has been identified as&#10;a "mirrored" character in bidirectional text, 0 otherwise.'>
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.name" func="yes">
			<Overload retVal="" descr="name(unichr[, default])&#10;Returns the name assigned to the Unicode character unichr as a&#10;string. If no name is defined, default is returned, or, if not&#10;given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.normalize" func="yes">
			<Overload retVal="" descr="normalize(form, unistr)&#10;&#10;Return the normal form 'form' for the Unicode string unistr.  Valid&#10;values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.numeric" func="yes">
			<Overload retVal="" descr="numeric(unichr[, default])&#10;&#10;Returns the numeric value assigned to the Unicode character unichr&#10;as float. If no such value is defined, default is returned, or, if&#10;not given, ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.ucd_3_2_0" func="yes">
			<Overload retVal="" descr="(UCD)">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.ucnhash_CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.unidata_version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unified_diff" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="uniform" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="uninstall" func="yes">
			<Overload retVal="" descr="Function of ihooks">
			</Overload>
		</KeyWord>
		<KeyWord name="union" func="yes">
			<Overload retVal="" descr="Return the union of sets as a new set.&#10;&#10;(i.e. all elements that are in either set.)">
			</Overload>
		</KeyWord>
		<KeyWord name="union_update" func="yes">
			<Overload retVal="" descr="Function of sets.Set">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest" func="yes">
			<Overload retVal="" descr="Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's&#10;Smalltalk testing framework.&#10;&#10;This module contains the core framework classes that form the basis of&#10;specific test cases and suites (TestCase, TestSuite etc.), and also a&#10;text-based utility class for running the tests and reporting the results&#10; (TextTestRunner).&#10;&#10;Simple usage:&#10;&#10;    import unittest&#10;&#10;    class IntegerArithmeticTestCase(unittest.TestCase):&#10;        def testAdd(self):  ## test method names begin 'test*'&#10;            self.assertEqual((1 + 2), 3)&#10;            self.assertEqual(0 + 1, 1)&#10;        def testMultiply(self):&#10;            self.assertEqual((0 * 10), 0)&#10;            self.assertEqual((5 * 8), 40)&#10;&#10;    if __name__ == '__main__':&#10;        unittest.main()&#10;&#10;Further information is available in the bundled documentation, and from&#10;&#10;  http://docs.python.org/library/unittest.html&#10;&#10;Copyright (c) 1999-2003 Steve Purcell&#10;Copyright (c) 2003-2010 Python Software Foundation&#10;This module is free software, and you may redistribute it and/or modify&#10;it under the same terms as Python itself, so long as this copyright message&#10;and disclaimer are retained in their original form.&#10;&#10;IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,&#10;SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF&#10;THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH&#10;DAMAGE.&#10;&#10;THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT&#10;LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A&#10;PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS,&#10;AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,&#10;SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.BaseTestSuite" func="yes">
			<Overload retVal="" descr="A simple test suite that doesn't provide class or module shared fixtures.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.BaseTestSuite.addTest" />
		<KeyWord name="unittest.BaseTestSuite.addTests" />
		<KeyWord name="unittest.BaseTestSuite.countTestCases" />
		<KeyWord name="unittest.BaseTestSuite.debug" func="yes">
			<Overload retVal="" descr="Run the tests without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.BaseTestSuite.run" />
		<KeyWord name="unittest.FunctionTestCase" func="yes">
			<Overload retVal="" descr="A test case that wraps a test function.&#10;&#10;This is useful for slipping pre-existing test functions into the&#10;unittest framework. Optionally, set-up and tidy-up functions can be&#10;supplied. As with TestCase, the tidy-up ('tearDown') function will&#10;always be called if the set-up ('setUp') function ran successfully.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether actual is a superset of expected.">
				<Param name="self" />
				<Param name="expected" />
				<Param name="actual" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertItemsEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence specific comparison. It asserts that&#10;actual_seq and expected_seq have the same element counts.&#10;Equivalent to::&#10;&#10;    self.assertEqual(Counter(iter(actual_seq)),&#10;                     Counter(iter(expected_seq)))&#10;&#10;Asserts that each element has the same count in both sequences.&#10;Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="expected_seq" />
				<Param name="actual_seq" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class excClass is raised&#10;by callableObj when invoked with arguments args and keyword&#10;arguments kwargs. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with callableObj omitted or None, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="excClass" />
				<Param name="[callableObj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regexp.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regexp: Regexp (re pattern object or string) expected&#10;            to be found in error message.&#10;    callable_obj: Function to be called.&#10;    args: Extra args.&#10;    kwargs: Extra kwargs.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regexp" />
				<Param name="[callable_obj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.countTestCases" />
		<KeyWord name="unittest.FunctionTestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.defaultTestResult" />
		<KeyWord name="unittest.FunctionTestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.id" />
		<KeyWord name="unittest.FunctionTestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.runTest" />
		<KeyWord name="unittest.FunctionTestCase.setUp" />
		<KeyWord name="unittest.FunctionTestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.shortDescription" />
		<KeyWord name="unittest.FunctionTestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.tearDown" />
		<KeyWord name="unittest.FunctionTestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.SkipTest" func="yes">
			<Overload retVal="" descr="Raise this exception in a test to skip it.&#10;&#10;Usually you can use TestCase.skipTest() or one of the skipping decorators&#10;instead of raising this directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.SkipTest.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.SkipTest.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase" func="yes">
			<Overload retVal="" descr="A class whose instances are single test cases.&#10;&#10;By default, the test code itself should be placed in a method named&#10;'runTest'.&#10;&#10;If the fixture may be used for many test cases, create as&#10;many test methods as are needed. When instantiating such a TestCase&#10;subclass, specify in the constructor arguments the name of the test method&#10;that the instance is to execute.&#10;&#10;Test authors should subclass TestCase for their own tests. Construction&#10;and deconstruction of the test's environment ('fixture') can be&#10;implemented by overriding the 'setUp' and 'tearDown' methods respectively.&#10;&#10;If it is necessary to override the __init__ method, the base class&#10;__init__ method must always be called. It is important that subclasses&#10;should not change the signature of their __init__ method, since instances&#10;of the classes are instantiated automatically by parts of the framework&#10;in order to be run.&#10;&#10;When subclassing TestCase, you can set these attributes:&#10;* failureException: determines which exception will be raised when&#10;    the instance's assertion methods fail; test methods raising this&#10;    exception will be deemed to have 'failed' rather than 'errored'.&#10;* longMessage: determines whether long messages (including repr of&#10;    objects used in assert methods) will be printed on failure in *addition*&#10;    to any explicit message passed.&#10;* maxDiff: sets the maximum length of a diff in failure messages&#10;    by assert methods using difflib. It is looked up as an instance&#10;    attribute so can be configured by individual tests if required.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is more than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether actual is a superset of expected.">
				<Param name="self" />
				<Param name="expected" />
				<Param name="actual" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertItemsEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence specific comparison. It asserts that&#10;actual_seq and expected_seq have the same element counts.&#10;Equivalent to::&#10;&#10;    self.assertEqual(Counter(iter(actual_seq)),&#10;                     Counter(iter(expected_seq)))&#10;&#10;Asserts that each element has the same count in both sequences.&#10;Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="expected_seq" />
				<Param name="actual_seq" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most signficant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class excClass is raised&#10;by callableObj when invoked with arguments args and keyword&#10;arguments kwargs. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with callableObj omitted or None, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="excClass" />
				<Param name="[callableObj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regexp.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regexp: Regexp (re pattern object or string) expected&#10;            to be found in error message.&#10;    callable_obj: Function to be called.&#10;    args: Extra args.&#10;    kwargs: Extra kwargs.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regexp" />
				<Param name="[callable_obj=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regexp" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.countTestCases" />
		<KeyWord name="unittest.TestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.defaultTestResult" />
		<KeyWord name="unittest.TestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.id" />
		<KeyWord name="unittest.TestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.setUp" func="yes">
			<Overload retVal="" descr="Hook method for setting up the test fixture before exercising it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.shortDescription" func="yes">
			<Overload retVal="" descr="Returns a one-line description of the test, or None if no&#10;description has been provided.&#10;&#10;The default implementation of this method returns the first line of&#10;the specified test method's docstring.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.tearDown" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the test fixture after testing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader" func="yes">
			<Overload retVal="" descr="This class is responsible for loading tests according to various criteria&#10;and returning them wrapped in a TestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.discover" func="yes">
			<Overload retVal="" descr="Find and return all test modules from the specified start&#10;directory, recursing into subdirectories to find them. Only test files&#10;that match the pattern will be loaded. (Using shell style pattern&#10;matching.)&#10;&#10;All test modules must be importable from the top level of the project.&#10;If the start directory is not the top level directory then the top&#10;level directory must be specified separately.&#10;&#10;If a test package name (directory with '__init__.py') matches the&#10;pattern then the package will be checked for a 'load_tests' function. If&#10;this exists then it will be called with loader, tests, pattern.&#10;&#10;If load_tests exists then discovery does  *not* recurse into the package,&#10;load_tests is responsible for loading all tests in the package.&#10;&#10;The pattern is deliberately not stored as a loader attribute so that&#10;packages can continue discovery themselves. top_level_dir is stored so&#10;load_tests does not need to pass this argument in to loader.discover().">
				<Param name="self" />
				<Param name="start_dir" />
				<Param name="[pattern=test*.py" />
				<Param name="[top_level_dir=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.getTestCaseNames" func="yes">
			<Overload retVal="" descr="Return a sorted sequence of method names found within testCaseClass">
				<Param name="self" />
				<Param name="testCaseClass" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromModule" func="yes">
			<Overload retVal="" descr="Return a suite of all tests cases contained in the given module">
				<Param name="self" />
				<Param name="module" />
				<Param name="[use_load_tests=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromName" func="yes">
			<Overload retVal="" descr="Return a suite of all tests cases given a string specifier.&#10;&#10;The name may resolve either to a module, a test case class, a&#10;test method within a test case class, or a callable object which&#10;returns a TestCase or TestSuite instance.&#10;&#10;The method optionally resolves the names relative to a given module.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[module=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromNames" func="yes">
			<Overload retVal="" descr="Return a suite of all tests cases found using the given sequence&#10;of string specifiers. See 'loadTestsFromName()'.">
				<Param name="self" />
				<Param name="names" />
				<Param name="[module=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromTestCase" func="yes">
			<Overload retVal="" descr="Return a suite of all tests cases contained in testCaseClass">
				<Param name="self" />
				<Param name="testCaseClass" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.sortTestMethodsUsing" func="yes">
			<Overload retVal="" descr="cmp(x, y) -&gt; integer&#10;&#10;Return negative if x&lt;y, zero if x==y, positive if x&gt;y.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.suiteClass" func="yes">
			<Overload retVal="" descr="A test suite is a composite test consisting of a number of TestCases.&#10;&#10;For use, create an instance of TestSuite, then add test case instances.&#10;When all tests have been added, the suite can be passed to a test&#10;runner, such as TextTestRunner. It will run the individual test cases&#10;in the order in which they were added, aggregating the results. When&#10;subclassing, do not forget to call the base class constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.testMethodPrefix" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestProgram" func="yes">
			<Overload retVal="" descr="A command-line program that runs a set of tests; this is primarily&#10;for making test modules conveniently executable.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestProgram.USAGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestProgram.createTests" />
		<KeyWord name="unittest.TestProgram.parseArgs" />
		<KeyWord name="unittest.TestProgram.runTests" />
		<KeyWord name="unittest.TestProgram.usageExit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult" func="yes">
			<Overload retVal="" descr="Holder for test result information.&#10;&#10;Test results are automatically managed by the TestCase and TestSuite&#10;classes, and do not need to be explicitly manipulated by writers of tests.&#10;&#10;Each instance holds the total number of tests run, and collections of&#10;failures and errors that occurred among those test runs. The collections&#10;contain tuples of (testcase, exceptioninfo), where exceptioninfo is the&#10;formatted traceback of the error that occurred.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addError" func="yes">
			<Overload retVal="" descr="Called when an error has occurred. 'err' is a tuple of values as&#10;returned by sys.exc_info().">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addExpectedFailure" func="yes">
			<Overload retVal="" descr="Called when an expected failure/error occured.">
				<Param name="self" />
				<Param name="test" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addFailure" func="yes">
			<Overload retVal="" descr="Called when an error has occurred. 'err' is a tuple of values as&#10;returned by sys.exc_info().">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addSkip" func="yes">
			<Overload retVal="" descr="Called when a test is skipped.">
				<Param name="self" />
				<Param name="test" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addSuccess" func="yes">
			<Overload retVal="" descr="Called when a test has completed successfully">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addUnexpectedSuccess" func="yes">
			<Overload retVal="" descr="Called when a test was expected to fail, but succeed.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.printErrors" func="yes">
			<Overload retVal="" descr="Called by TestRunner after test run">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.startTest" func="yes">
			<Overload retVal="" descr="Called when the given test is about to be run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.startTestRun" func="yes">
			<Overload retVal="" descr="Called once before any tests are executed.&#10;&#10;See startTest for a method called before each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.stop" func="yes">
			<Overload retVal="" descr="Indicates that the tests should be aborted">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.stopTest" func="yes">
			<Overload retVal="" descr="Called when the given test has been run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.stopTestRun" func="yes">
			<Overload retVal="" descr="Called once after all tests are executed.&#10;&#10;See stopTest for a method called after each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.wasSuccessful" func="yes">
			<Overload retVal="" descr="Tells whether or not this result was a success">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestSuite" func="yes">
			<Overload retVal="" descr="A test suite is a composite test consisting of a number of TestCases.&#10;&#10;For use, create an instance of TestSuite, then add test case instances.&#10;When all tests have been added, the suite can be passed to a test&#10;runner, such as TextTestRunner. It will run the individual test cases&#10;in the order in which they were added, aggregating the results. When&#10;subclassing, do not forget to call the base class constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestSuite.addTest" />
		<KeyWord name="unittest.TestSuite.addTests" />
		<KeyWord name="unittest.TestSuite.countTestCases" />
		<KeyWord name="unittest.TestSuite.debug" func="yes">
			<Overload retVal="" descr="Run the tests without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestSuite.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="result" />
				<Param name="[debug=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult" func="yes">
			<Overload retVal="" descr="A test result class that can print formatted text results to a stream.&#10;&#10;Used by TextTestRunner.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addError" />
		<KeyWord name="unittest.TextTestResult.addExpectedFailure" />
		<KeyWord name="unittest.TextTestResult.addFailure" />
		<KeyWord name="unittest.TextTestResult.addSkip" />
		<KeyWord name="unittest.TextTestResult.addSuccess" />
		<KeyWord name="unittest.TextTestResult.addUnexpectedSuccess" />
		<KeyWord name="unittest.TextTestResult.getDescription" />
		<KeyWord name="unittest.TextTestResult.printErrorList" />
		<KeyWord name="unittest.TextTestResult.printErrors" />
		<KeyWord name="unittest.TextTestResult.separator1" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.separator2" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.startTest" />
		<KeyWord name="unittest.TextTestResult.startTestRun" func="yes">
			<Overload retVal="" descr="Called once before any tests are executed.&#10;&#10;See startTest for a method called before each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.stop" func="yes">
			<Overload retVal="" descr="Indicates that the tests should be aborted">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.stopTest" func="yes">
			<Overload retVal="" descr="Called when the given test has been run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.stopTestRun" func="yes">
			<Overload retVal="" descr="Called once after all tests are executed.&#10;&#10;See stopTest for a method called after each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.wasSuccessful" func="yes">
			<Overload retVal="" descr="Tells whether or not this result was a success">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestRunner" func="yes">
			<Overload retVal="" descr="A test runner class that displays results in textual form.&#10;&#10;It prints out the names of tests as they are run, errors as they&#10;occur, and a summary of the results at the end of the test run.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestRunner.resultclass" func="yes">
			<Overload retVal="" descr="A test result class that can print formatted text results to a stream.&#10;&#10;Used by TextTestRunner.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestRunner.run" func="yes">
			<Overload retVal="" descr="Run the given test case or test suite.">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.defaultTestLoader" func="yes">
			<Overload retVal="" descr="(TestLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.expectedFailure" />
		<KeyWord name="unittest.findTestCases" func="yes">
			<Overload retVal="" descr=>
				<Param name="module" />
				<Param name="[prefix=test" />
				<Param name="[sortUsing=<built-in function cmp>" />
				<Param name="[suiteClass=<class 'unittest.suite.TestSuite'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.getTestCaseNames" func="yes">
			<Overload retVal="" descr=>
				<Param name="testCaseClass" />
				<Param name="prefix" />
				<Param name="[sortUsing=<built-in function cmp>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.installHandler" />
		<KeyWord name="unittest.main" func="yes">
			<Overload retVal="" descr="A command-line program that runs a set of tests; this is primarily&#10;for making test modules conveniently executable.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.main.USAGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.main.createTests" />
		<KeyWord name="unittest.main.parseArgs" />
		<KeyWord name="unittest.main.runTests" />
		<KeyWord name="unittest.main.usageExit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.makeSuite" func="yes">
			<Overload retVal="" descr=>
				<Param name="testCaseClass" />
				<Param name="[prefix=test" />
				<Param name="[sortUsing=<built-in function cmp>" />
				<Param name="[suiteClass=<class 'unittest.suite.TestSuite'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.registerResult" />
		<KeyWord name="unittest.removeHandler" func="yes">
			<Overload retVal="" descr=>
				<Param name="[method=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.removeResult" />
		<KeyWord name="unittest.skip" func="yes">
			<Overload retVal="" descr="Unconditionally skip a test.">
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.skipIf" func="yes">
			<Overload retVal="" descr="Skip a test if the condition is true.">
				<Param name="condition" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.skipUnless" func="yes">
			<Overload retVal="" descr="Skip a test unless the condition is true.">
				<Param name="condition" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unix_getpass" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="unlink" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="unmatched" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="unmimify" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="unmimify_part" func="yes">
			<Overload retVal="" descr="Function of mimify">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_from" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="unquote" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="unquote_plus" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="unregister_archive_format" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="unregister_dialect" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="unsetenv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="untokenize" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="unwrap" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="up" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="update_idletasks" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="update_wrapper" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="updatecache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="updateline" func="yes">
			<Overload retVal="" descr="Function of mhlib">
			</Overload>
		</KeyWord>
		<KeyWord name="upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="uppercase_escaped_char" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="urandom" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="url2pathname" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="urlcleanup" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="urldefrag" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="urlencode" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="urljoin" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib" func="yes">
			<Overload retVal="" descr='Open an arbitrary URL.&#10;&#10;See the following document for more info on URLs:&#10;"Names and Addresses, URIs, URLs, URNs, URCs", at&#10;http://www.w3.org/pub/WWW/Addressing/Overview.html&#10;&#10;See also the HTTP spec (from which the error codes are derived):&#10;"HTTP - Hypertext Transfer Protocol", at&#10;http://www.w3.org/pub/WWW/Protocols/&#10;&#10;Related standards and specs:&#10;- RFC1808: the "relative URL" spec. (authoritative status)&#10;- RFC1738 - the "URL standard". (authoritative status)&#10;- RFC1630 - the "URI spec". (informational status)&#10;&#10;The object returned by URLopener().open(file) will differ per&#10;protocol.  All you know is that is has methods read(), readline(),&#10;readlines(), fileno(), close() and info().  The read*(), fileno()&#10;and close() methods work like those of open files.&#10;The info() method returns a mimetools.Message object which can be&#10;used to query various info about the object, if available.&#10;(mimetools.Message objects are queried with the getheader() method.)'>
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ContentTooShortError" />
		<KeyWord name="urllib.ContentTooShortError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ContentTooShortError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ContentTooShortError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ContentTooShortError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ContentTooShortError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.FancyURLopener" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.MAXFTPCACHE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.URLopener" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.addbase" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.addclosehook" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.addinfo" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.addinfourl" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.always_safe" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.basejoin" func="yes">
			<Overload retVal="" descr="Join a base URL and a possibly relative URL to form an absolute&#10;interpretation of the latter.">
				<Param name="base" />
				<Param name="url" />
				<Param name="[allow_fragments=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.c" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ftperrors" func="yes">
			<Overload retVal="" descr="Return the set of errors raised by the FTP class.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.ftpwrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.getproxies" func="yes">
			<Overload retVal="" descr="Return a dictionary of scheme -&gt; proxy server URL mappings.&#10;&#10;Returns settings gathered from the environment, if specified,&#10;or the registry.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.getproxies_environment" func="yes">
			<Overload retVal="" descr="Return a dictionary of scheme -&gt; proxy server URL mappings.&#10;&#10;Scan the environment for variables named &lt;scheme&gt;_proxy;&#10;this seems to be the standard convention.  If you need a&#10;different way, you can pass a proxies dictionary to the&#10;[Fancy]URLopener constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.getproxies_registry" func="yes">
			<Overload retVal="" descr="Return a dictionary of scheme -&gt; proxy server URL mappings.&#10;&#10;Win32 uses the registry to store proxies.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.i" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.localhost" func="yes">
			<Overload retVal="" descr="Return the IP address of the magic hostname 'localhost'.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.noheaders" func="yes">
			<Overload retVal="" descr="Return an empty mimetools.Message object.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.pathname2url" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a file system path to a relative URL&#10;of the 'file' scheme; not recommended for general use.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.proxy_bypass" func="yes">
			<Overload retVal="" descr="Return a dictionary of scheme -&gt; proxy server URL mappings.&#10;&#10;Returns settings gathered from the environment, if specified,&#10;or the registry.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.proxy_bypass_environment" func="yes">
			<Overload retVal="" descr="Test if proxies should not be used for a particular host.&#10;&#10;Checks the environment for a variable named no_proxy, which should&#10;be a list of DNS suffixes separated by commas, or '*' for all hosts.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.proxy_bypass_registry" />
		<KeyWord name="urllib.quote" func="yes">
			<Overload retVal="" descr="quote('abc def') -&gt; 'abc%20def'&#10;&#10;Each part of a URL, e.g. the path info, the query, etc., has a&#10;different set of reserved characters that must be quoted.&#10;&#10;RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists&#10;the following reserved characters.&#10;&#10;reserved    = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |&#10;              &quot;$&quot; | &quot;,&quot;&#10;&#10;Each of these characters is reserved in some component of a URL,&#10;but not necessarily in all of them.&#10;&#10;By default, the quote function is intended for quoting the path&#10;section of a URL.  Thus, it will not encode '/'.  This character&#10;is reserved, but in typical usage the quote function is being&#10;called on a path where the existing slash characters are used as&#10;reserved characters.">
				<Param name="s" />
				<Param name="[safe=/]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.quote_plus" func="yes">
			<Overload retVal="" descr="Quote the query fragment of a URL; replacing ' ' with '+'">
				<Param name="s" />
				<Param name="[safe]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.reporthook" />
		<KeyWord name="urllib.splitattr" func="yes">
			<Overload retVal="" descr="splitattr('/path;attr1=value1;attr2=value2;...') -&gt;&#10;'/path', ['attr1=value1', 'attr2=value2', ...].">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splithost" func="yes">
			<Overload retVal="" descr="splithost('//host[:port]/path') --&gt; 'host[:port]', '/path'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splitnport" func="yes">
			<Overload retVal="" descr="Split host and port, returning numeric port.&#10;Return given default port if no ':' found; defaults to -1.&#10;Return numerical port if a valid number are found after ':'.&#10;Return None if ':' but not a valid number.">
				<Param name="host" />
				<Param name="[defport=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splitpasswd" func="yes">
			<Overload retVal="" descr="splitpasswd('user:passwd') -&gt; 'user', 'passwd'.">
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splitport" func="yes">
			<Overload retVal="" descr="splitport('host:port') --&gt; 'host', 'port'.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splitquery" func="yes">
			<Overload retVal="" descr="splitquery('/path?query') --&gt; '/path', 'query'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splittag" func="yes">
			<Overload retVal="" descr="splittag('/path#tag') --&gt; '/path', 'tag'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splittype" func="yes">
			<Overload retVal="" descr="splittype('type:opaquestring') --&gt; 'type', 'opaquestring'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splituser" func="yes">
			<Overload retVal="" descr="splituser('user[:passwd]@host[:port]') --&gt; 'user[:passwd]', 'host[:port]'.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.splitvalue" func="yes">
			<Overload retVal="" descr="splitvalue('attr=value') --&gt; 'attr', 'value'.">
				<Param name="attr" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.test1" />
		<KeyWord name="urllib.thishost" func="yes">
			<Overload retVal="" descr="Return the IP address of the current host.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.toBytes" func="yes">
			<Overload retVal="" descr="toBytes(u&quot;URL&quot;) --&gt; 'URL'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.unquote" func="yes">
			<Overload retVal="" descr="unquote('abc%20def') -&gt; 'abc def'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.unquote_plus" func="yes">
			<Overload retVal="" descr="unquote('%7e/abc+def') -&gt; '~/abc def'">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.unwrap" func="yes">
			<Overload retVal="" descr="unwrap('&lt;URL:type://host/path&gt;') --&gt; 'type://host/path'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.url2pathname" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a relative URL of the 'file' scheme&#10;to a file system path; not recommended for general use.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.urlcleanup" />
		<KeyWord name="urllib.urlencode" func="yes">
			<Overload retVal="" descr="Encode a sequence of two-element tuples or dictionary into a URL query string.&#10;&#10;If any values in the query arg are sequences and doseq is true, each&#10;sequence element is converted to a separate parameter.&#10;&#10;If the query arg is a sequence of two-element tuples, the order of the&#10;parameters in the output will match the order of parameters in the&#10;input.">
				<Param name="query" />
				<Param name="[doseq=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.urlopen" func="yes">
			<Overload retVal="" descr="Create a file-like object for the specified URL to read from.">
				<Param name="url" />
				<Param name="[data=None" />
				<Param name="[proxies=None" />
				<Param name="[context=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib.urlretrieve" func="yes">
			<Overload retVal="" descr=>
				<Param name="url" />
				<Param name="[filename=None" />
				<Param name="[reporthook=None" />
				<Param name="[data=None" />
				<Param name="[context=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2" func="yes">
			<Overload retVal="" descr="An extensible library for opening URLs using a variety of protocols&#10;&#10;The simplest way to use this module is to call the urlopen function,&#10;which accepts a string containing a URL or a Request object (described&#10;below).  It opens the URL and returns the results as file-like&#10;object; the returned object has some extra methods described below.&#10;&#10;The OpenerDirector manages a collection of Handler objects that do&#10;all the actual work.  Each Handler implements a particular protocol or&#10;option.  The OpenerDirector is a composite object that invokes the&#10;Handlers needed to open the requested URL.  For example, the&#10;HTTPHandler performs HTTP GET and POST requests and deals with&#10;non-error returns.  The HTTPRedirectHandler automatically deals with&#10;HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler&#10;deals with digest authentication.&#10;&#10;urlopen(url, data=None) -- Basic usage is the same as original&#10;urllib.  pass the url and optionally data to post to an HTTP URL, and&#10;get a file-like object back.  One difference is that you can also pass&#10;a Request instance instead of URL.  Raises a URLError (subclass of&#10;IOError); for HTTP errors, raises an HTTPError, which can also be&#10;treated as a valid response.&#10;&#10;build_opener -- Function that creates a new OpenerDirector instance.&#10;Will install the default handlers.  Accepts one or more Handlers as&#10;arguments, either instances or Handler classes that it will&#10;instantiate.  If one of the argument is a subclass of the default&#10;handler, the argument will be installed instead of the default.&#10;&#10;install_opener -- Installs a new opener as the default opener.&#10;&#10;objects of interest:&#10;&#10;OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages&#10;the Handler classes, while dealing with requests and responses.&#10;&#10;Request -- An object that encapsulates the state of a request.  The&#10;state can be as simple as the URL.  It can also include extra HTTP&#10;headers, e.g. a User-Agent.&#10;&#10;BaseHandler --&#10;&#10;exceptions:&#10;URLError -- A subclass of IOError, individual protocols have their own&#10;specific subclass.&#10;&#10;HTTPError -- Also a valid HTTP response, so you can treat an HTTP error&#10;as an exceptional event or valid response.&#10;&#10;internals:&#10;BaseHandler and parent&#10;_call_chain conventions&#10;&#10;Example usage:&#10;&#10;import urllib2&#10;&#10;# set up authentication info&#10;authinfo = urllib2.HTTPBasicAuthHandler()&#10;authinfo.add_password(realm='PDQ Application',&#10;                      uri='https://mahler:8092/site-updates.py',&#10;                      user='klem',&#10;                      passwd='geheim$parole')&#10;&#10;proxy_support = urllib2.ProxyHandler({&quot;http&quot; : &quot;http://ahad-haam:3128&quot;})&#10;&#10;# build a new opener that adds authentication and caching FTP handlers&#10;opener = urllib2.build_opener(proxy_support, authinfo, urllib2.CacheFTPHandler)&#10;&#10;# install it&#10;urllib2.install_opener(opener)&#10;&#10;f = urllib2.urlopen('http://www.python.org/')">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.AbstractBasicAuthHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.AbstractDigestAuthHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.AbstractHTTPHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.BaseHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.CacheFTPHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.FTPHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.FileHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPBasicAuthHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPCookieProcessor" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPDefaultErrorHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPDigestAuthHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError" func="yes">
			<Overload retVal="" descr="Raised when HTTP error occurs, but also acts like non-error return">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError.close" />
		<KeyWord name="urllib2.HTTPError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError.getcode" />
		<KeyWord name="urllib2.HTTPError.geturl" />
		<KeyWord name="urllib2.HTTPError.info" />
		<KeyWord name="urllib2.HTTPError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError.reason" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPErrorProcessor" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPPasswordMgr" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPPasswordMgrWithDefaultRealm" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPRedirectHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.HTTPSHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.OpenerDirector" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.ProxyBasicAuthHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.ProxyDigestAuthHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.ProxyHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.Request" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.StringIO" func="yes">
			<Overload retVal="" descr="StringIO([s]) -- Return a StringIO-like stream for reading or writing">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.URLError" />
		<KeyWord name="urllib2.URLError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.URLError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.URLError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.URLError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.URLError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.UnknownHandler" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.addinfourl" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.build_opener" func="yes">
			<Overload retVal="" descr="Create an opener object from a list of handlers.&#10;&#10;The opener will use several default handlers, including support&#10;for HTTP, FTP and when applicable, HTTPS.&#10;&#10;If any of the handlers passed as arguments are subclasses of the&#10;default handlers, the default handlers will not be used.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.ftpwrapper" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.getproxies" func="yes">
			<Overload retVal="" descr="Return a dictionary of scheme -&gt; proxy server URL mappings.&#10;&#10;Returns settings gathered from the environment, if specified,&#10;or the registry.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.install_opener" />
		<KeyWord name="urllib2.localhost" func="yes">
			<Overload retVal="" descr="Return the IP address of the magic hostname 'localhost'.">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.parse_http_list" func="yes">
			<Overload retVal="" descr="Parse lists as described by RFC 2068 Section 2.&#10;&#10;In particular, parse comma-separated lists where the elements of&#10;the list may include quoted-strings.  A quoted-string could&#10;contain a comma.  A non-quoted string could have quotes in the&#10;middle.  Neither commas nor quotes count if they are escaped.&#10;Only double-quotes count, not single-quotes.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.parse_keqv_list" func="yes">
			<Overload retVal="" descr="Parse list of key=value strings where keys are not duplicated.">
				<Param name="l" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.proxy_bypass" func="yes">
			<Overload retVal="" descr="Return a dictionary of scheme -&gt; proxy server URL mappings.&#10;&#10;Returns settings gathered from the environment, if specified,&#10;or the registry.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.quote" func="yes">
			<Overload retVal="" descr="quote('abc def') -&gt; 'abc%20def'&#10;&#10;Each part of a URL, e.g. the path info, the query, etc., has a&#10;different set of reserved characters that must be quoted.&#10;&#10;RFC 2396 Uniform Resource Identifiers (URI): Generic Syntax lists&#10;the following reserved characters.&#10;&#10;reserved    = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |&#10;              &quot;$&quot; | &quot;,&quot;&#10;&#10;Each of these characters is reserved in some component of a URL,&#10;but not necessarily in all of them.&#10;&#10;By default, the quote function is intended for quoting the path&#10;section of a URL.  Thus, it will not encode '/'.  This character&#10;is reserved, but in typical usage the quote function is being&#10;called on a path where the existing slash characters are used as&#10;reserved characters.">
				<Param name="s" />
				<Param name="[safe=/]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.randombytes" func="yes">
			<Overload retVal="" descr="Return n random bytes.">
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.request_host" func="yes">
			<Overload retVal="" descr="Return request-host, as defined by RFC 2965.&#10;&#10;Variation from RFC: returned value is lowercased, for convenient&#10;comparison.">
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splitattr" func="yes">
			<Overload retVal="" descr="splitattr('/path;attr1=value1;attr2=value2;...') -&gt;&#10;'/path', ['attr1=value1', 'attr2=value2', ...].">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splithost" func="yes">
			<Overload retVal="" descr="splithost('//host[:port]/path') --&gt; 'host[:port]', '/path'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splitpasswd" func="yes">
			<Overload retVal="" descr="splitpasswd('user:passwd') -&gt; 'user', 'passwd'.">
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splitport" func="yes">
			<Overload retVal="" descr="splitport('host:port') --&gt; 'host', 'port'.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splittag" func="yes">
			<Overload retVal="" descr="splittag('/path#tag') --&gt; '/path', 'tag'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splittype" func="yes">
			<Overload retVal="" descr="splittype('type:opaquestring') --&gt; 'type', 'opaquestring'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splituser" func="yes">
			<Overload retVal="" descr="splituser('user[:passwd]@host[:port]') --&gt; 'user[:passwd]', 'host[:port]'.">
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.splitvalue" func="yes">
			<Overload retVal="" descr="splitvalue('attr=value') --&gt; 'attr', 'value'.">
				<Param name="attr" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.toBytes" func="yes">
			<Overload retVal="" descr="toBytes(u&quot;URL&quot;) --&gt; 'URL'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.unquote" func="yes">
			<Overload retVal="" descr="unquote('abc%20def') -&gt; 'abc def'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.unwrap" func="yes">
			<Overload retVal="" descr="unwrap('&lt;URL:type://host/path&gt;') --&gt; 'type://host/path'.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.url2pathname" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a relative URL of the 'file' scheme&#10;to a file system path; not recommended for general use.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urllib2.urlopen" func="yes">
			<Overload retVal="" descr=>
				<Param name="url" />
				<Param name="[data=None" />
				<Param name="[timeout=<object object at 0x00000000024AA130>" />
				<Param name="[cafile=None" />
				<Param name="[capath=None" />
				<Param name="[cadefault=False" />
				<Param name="[context=None]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlopen" func="yes">
			<Overload retVal="" descr="Function of urllib2">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse" func="yes">
			<Overload retVal="" descr="Parse (absolute and relative) URLs.&#10;&#10;urlparse module is based upon the following RFC specifications.&#10;&#10;RFC 3986 (STD66): &quot;Uniform Resource Identifiers&quot; by T. Berners-Lee, R. Fielding&#10;and L.  Masinter, January 2005.&#10;&#10;RFC 2732 : &quot;Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter&#10;and L.Masinter, December 1999.&#10;&#10;RFC 2396:  &quot;Uniform Resource Identifiers (URI)&quot;: Generic Syntax by T.&#10;Berners-Lee, R. Fielding, and L. Masinter, August 1998.&#10;&#10;RFC 2368: &quot;The mailto URL scheme&quot;, by P.Hoffman , L Masinter, J. Zwinski, July 1998.&#10;&#10;RFC 1808: &quot;Relative Uniform Resource Locators&quot;, by R. Fielding, UC Irvine, June&#10;1995.&#10;&#10;RFC 1738: &quot;Uniform Resource Locators (URL)&quot; by T. Berners-Lee, L. Masinter, M.&#10;McCahill, December 1994&#10;&#10;RFC 3986 is considered the current standard and any future changes to&#10;urlparse module should conform with it.  The urlparse module is&#10;currently not entirely compliant with this RFC due to defacto&#10;scenarios for parsing, and for backward compatibility purposes, some&#10;parsing quirks from older RFCs are retained. The testcases in&#10;test_urlparse.py provides a good indicator of parsing behavior.">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.MAX_CACHE_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult" />
		<KeyWord name="urlparse.ParseResult.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.fragment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.geturl" />
		<KeyWord name="urlparse.ParseResult.hostname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.netloc" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.params" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.password" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.path" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.port" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.query" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.scheme" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ParseResult.username" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ResultMixin" func="yes">
			<Overload retVal="" descr="Shared methods for the parsed result objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ResultMixin.hostname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ResultMixin.password" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ResultMixin.port" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.ResultMixin.username" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult" />
		<KeyWord name="urlparse.SplitResult.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.fragment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.geturl" />
		<KeyWord name="urlparse.SplitResult.hostname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.netloc" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.password" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.path" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.port" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.query" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.scheme" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.SplitResult.username" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.clear_cache" func="yes">
			<Overload retVal="" descr="Clear the parse cache.">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessable by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
				<Param name="typename" />
				<Param name="field_names" />
				<Param name="[verbose=False" />
				<Param name="[rename=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.non_hierarchical" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.parse_qs" func="yes">
			<Overload retVal="" descr="Parse a query given as a string argument.&#10;&#10;Arguments:&#10;&#10;qs: percent-encoded query string to be parsed&#10;&#10;keep_blank_values: flag indicating whether blank values in&#10;    percent-encoded queries should be treated as blank strings.&#10;    A true value indicates that blanks should be retained as&#10;    blank strings.  The default false value indicates that&#10;    blank values are to be ignored and treated as if they were&#10;    not included.&#10;&#10;strict_parsing: flag indicating what to do with parsing errors.&#10;    If false (the default), errors are silently ignored.&#10;    If true, errors raise a ValueError exception.">
				<Param name="qs" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.parse_qsl" func="yes">
			<Overload retVal="" descr="Parse a query given as a string argument.&#10;&#10;Arguments:&#10;&#10;qs: percent-encoded query string to be parsed&#10;&#10;keep_blank_values: flag indicating whether blank values in&#10;    percent-encoded queries should be treated as blank strings.  A&#10;    true value indicates that blanks should be retained as blank&#10;    strings.  The default false value indicates that blank values&#10;    are to be ignored and treated as if they were  not included.&#10;&#10;strict_parsing: flag indicating what to do with parsing errors. If&#10;    false (the default), errors are silently ignored. If true,&#10;    errors raise a ValueError exception.&#10;&#10;Returns a list, as G-d intended.">
				<Param name="qs" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.scheme_chars" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.unquote" func="yes">
			<Overload retVal="" descr="unquote('abc%20def') -&gt; 'abc def'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.urldefrag" func="yes">
			<Overload retVal="" descr="Removes any existing fragment from URL.&#10;&#10;Returns a tuple of the defragmented URL and the fragment.  If&#10;the URL contained no fragments, the second element is the&#10;empty string.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.urljoin" func="yes">
			<Overload retVal="" descr="Join a base URL and a possibly relative URL to form an absolute&#10;interpretation of the latter.">
				<Param name="base" />
				<Param name="url" />
				<Param name="[allow_fragments=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.urlparse" func="yes">
			<Overload retVal="" descr="Parse a URL into 6 components:&#10;&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;fragment&gt;&#10;Return a 6-tuple: (scheme, netloc, path, params, query, fragment).&#10;Note that we don't break the components up in smaller bits&#10;(e.g. netloc is a single string) and we don't expand % escapes.">
				<Param name="url" />
				<Param name="[scheme" />
				<Param name="[allow_fragments=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.urlsplit" func="yes">
			<Overload retVal="" descr="Parse a URL into 5 components:&#10;&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;&#10;Return a 5-tuple: (scheme, netloc, path, query, fragment).&#10;Note that we don't break the components up in smaller bits&#10;(e.g. netloc is a single string) and we don't expand % escapes.">
				<Param name="url" />
				<Param name="[scheme" />
				<Param name="[allow_fragments=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.urlunparse" func="yes">
			<Overload retVal="" descr="Put a parsed URL back together again.  This may result in a&#10;slightly different, but equivalent URL, if the URL that was parsed&#10;originally had redundant delimiters, e.g. a ? with an empty query&#10;(the draft states that these are equivalent).">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.urlunsplit" func="yes">
			<Overload retVal="" descr="Combine the elements of a tuple as returned by urlsplit() into a&#10;complete URL as a string. The data argument can be any five-item iterable.&#10;This may result in a slightly different, but equivalent URL, if the URL that&#10;was parsed originally had unnecessary delimiters (for example, a ? with an&#10;empty query; the RFC states that these are equivalent).">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.uses_fragment" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.uses_netloc" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.uses_params" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.uses_query" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlparse.uses_relative" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="urlretrieve" func="yes">
			<Overload retVal="" descr="Function of urllib">
			</Overload>
		</KeyWord>
		<KeyWord name="urlsafe_b64decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="urlsafe_b64encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="urlsplit" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="urlunparse" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="urlunsplit" func="yes">
			<Overload retVal="" descr="Function of urlparse">
			</Overload>
		</KeyWord>
		<KeyWord name="usage" func="yes">
			<Overload retVal="" descr="Function of smtpd">
			</Overload>
		</KeyWord>
		<KeyWord name="usageExit" func="yes">
			<Overload retVal="" descr="Function of unittest.main">
			</Overload>
		</KeyWord>
		<KeyWord name="user" func="yes">
			<Overload retVal="" descr="Hook to allow user-specified customization code to run.&#10;&#10;As a policy, Python doesn't run user-specified code on startup of&#10;Python programs (interactive sessions execute the script specified in&#10;the PYTHONSTARTUP environment variable if it exists).&#10;&#10;However, some programs or sites may find it convenient to allow users&#10;to have a standard customization file, which gets run when a program&#10;requests it.  This module implements such a mechanism.  A program&#10;that wishes to use the mechanism must execute the statement&#10;&#10;    import user&#10;&#10;The user module looks for a file .pythonrc.py in the user's home&#10;directory and if it can be opened, execfile()s it in its own global&#10;namespace.  Errors during this phase are not caught; that's up to the&#10;program that imports the user module, if it wishes.&#10;&#10;The user's .pythonrc.py could conceivably test for sys.version if it&#10;wishes to do different things depending on the Python version.">
			</Overload>
		</KeyWord>
		<KeyWord name="user.home" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="user.pythonrc" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="user_domain_match" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="usesTime" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="utcfromtimestamp" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="utcnow" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="utcoffset" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="utctimetuple" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_be_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_be_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_ex_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_le_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_le_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_be_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_be_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_ex_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_le_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_le_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_7_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_7_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_8_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_8_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utime" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="uts" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="uu" func="yes">
			<Overload retVal="" descr="Implementation of the UUencode and UUdecode functions.&#10;&#10;encode(in_file, out_file [,name, mode])&#10;decode(in_file [, out_file, mode])">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.Error" />
		<KeyWord name="uu.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.decode" func="yes">
			<Overload retVal="" descr="Decode uuencoded file">
				<Param name="in_file" />
				<Param name="[out_file=None" />
				<Param name="[mode=None" />
				<Param name="[quiet=0]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="uu.encode" func="yes">
			<Overload retVal="" descr="Uuencode file">
				<Param name="in_file" />
				<Param name="out_file" />
				<Param name="[name=None" />
				<Param name="[mode=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="uu.test" func="yes">
			<Overload retVal="" descr="uuencode/uudecode main program">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid" func="yes">
			<Overload retVal="" descr="UUID objects (universally unique identifiers) according to RFC 4122.&#10;&#10;This module provides immutable UUID objects (class UUID) and the functions&#10;uuid1(), uuid3(), uuid4(), uuid5() for generating version 1, 3, 4, and 5&#10;UUIDs as specified in RFC 4122.&#10;&#10;If all you want is a unique ID, you should probably call uuid1() or uuid4().&#10;Note that uuid1() may compromise privacy since it creates a UUID containing&#10;the computer's network address.  uuid4() creates a random UUID.&#10;&#10;Typical usage:&#10;&#10;    &gt;&gt;&gt; import uuid&#10;&#10;    # make a UUID based on the host ID and current time&#10;    &gt;&gt;&gt; uuid.uuid1()&#10;    UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')&#10;&#10;    # make a UUID using an MD5 hash of a namespace UUID and a name&#10;    &gt;&gt;&gt; uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')&#10;    UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')&#10;&#10;    # make a random UUID&#10;    &gt;&gt;&gt; uuid.uuid4()&#10;    UUID('16fd2706-8baf-433b-82eb-8c7fada847da')&#10;&#10;    # make a UUID using a SHA-1 hash of a namespace UUID and a name&#10;    &gt;&gt;&gt; uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')&#10;    UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')&#10;&#10;    # make a UUID from a string of hex digits (braces and hyphens ignored)&#10;    &gt;&gt;&gt; x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')&#10;&#10;    # convert a UUID to a string of hex digits in standard form&#10;    &gt;&gt;&gt; str(x)&#10;    '00010203-0405-0607-0809-0a0b0c0d0e0f'&#10;&#10;    # get the raw 16 bytes of the UUID&#10;    &gt;&gt;&gt; x.bytes&#10;    '\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'&#10;&#10;    # make a UUID from a 16-byte string&#10;    &gt;&gt;&gt; uuid.UUID(bytes=x.bytes)&#10;    UUID('00010203-0405-0607-0809-0a0b0c0d0e0f')">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_DNS" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_OID" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_URL" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_X500" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RESERVED_FUTURE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RESERVED_MICROSOFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RESERVED_NCS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RFC_4122" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID" func="yes">
			<Overload retVal="" descr="Instances of the UUID class represent UUIDs as specified in RFC 4122.&#10;UUID objects are immutable, hashable, and usable as dictionary keys.&#10;Converting a UUID to a string with str() yields something in the form&#10;'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts&#10;five possible forms: a similar string of hexadecimal digits, or a tuple&#10;of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and&#10;48-bit values respectively) as an argument named 'fields', or a string&#10;of 16 bytes (with all the integer fields in big-endian order) as an&#10;argument named 'bytes', or a string of 16 bytes (with the first three&#10;fields in little-endian order) as an argument named 'bytes_le', or a&#10;single 128-bit integer as an argument named 'int'.&#10;&#10;UUIDs have these read-only attributes:&#10;&#10;    bytes       the UUID as a 16-byte string (containing the six&#10;                integer fields in big-endian byte order)&#10;&#10;    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,&#10;                and time_hi_version in little-endian byte order)&#10;&#10;    fields      a tuple of the six integer fields of the UUID,&#10;                which are also available as six individual attributes&#10;                and two derived attributes:&#10;&#10;        time_low                the first 32 bits of the UUID&#10;        time_mid                the next 16 bits of the UUID&#10;        time_hi_version         the next 16 bits of the UUID&#10;        clock_seq_hi_variant    the next 8 bits of the UUID&#10;        clock_seq_low           the next 8 bits of the UUID&#10;        node                    the last 48 bits of the UUID&#10;&#10;        time                    the 60-bit timestamp&#10;        clock_seq               the 14-bit sequence number&#10;&#10;    hex         the UUID as a 32-character hexadecimal string&#10;&#10;    int         the UUID as a 128-bit integer&#10;&#10;    urn         the UUID as a URN as specified in RFC 4122&#10;&#10;    variant     the UUID variant (one of the constants RESERVED_NCS,&#10;                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)&#10;&#10;    version     the UUID version number (1 through 5, meaningful only&#10;                when the variant is RFC_4122)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.bytes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.bytes_le" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.clock_seq" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.clock_seq_hi_variant" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.clock_seq_low" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.fields" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.get_bytes" />
		<KeyWord name="uuid.UUID.get_bytes_le" />
		<KeyWord name="uuid.UUID.get_clock_seq" />
		<KeyWord name="uuid.UUID.get_clock_seq_hi_variant" />
		<KeyWord name="uuid.UUID.get_clock_seq_low" />
		<KeyWord name="uuid.UUID.get_fields" />
		<KeyWord name="uuid.UUID.get_hex" />
		<KeyWord name="uuid.UUID.get_node" />
		<KeyWord name="uuid.UUID.get_time" />
		<KeyWord name="uuid.UUID.get_time_hi_version" />
		<KeyWord name="uuid.UUID.get_time_low" />
		<KeyWord name="uuid.UUID.get_time_mid" />
		<KeyWord name="uuid.UUID.get_urn" />
		<KeyWord name="uuid.UUID.get_variant" />
		<KeyWord name="uuid.UUID.get_version" />
		<KeyWord name="uuid.UUID.hex" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.node" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time_hi_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time_low" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time_mid" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.urn" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.variant" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.getnode" func="yes">
			<Overload retVal="" descr="Get the hardware address as a 48-bit positive integer.&#10;&#10;The first time this runs, it may launch a separate program, which could&#10;be quite slow.  If all attempts to obtain the hardware address fail, we&#10;choose a random 48-bit number with its eighth bit set to 1 as recommended&#10;in RFC 4122.">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.lib" func="yes">
			<Overload retVal="" descr="(WinDLL)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.libname" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid1" func="yes">
			<Overload retVal="" descr="Generate a UUID from a host ID, sequence number, and the current time.&#10;If 'node' is not given, getnode() is used to obtain the hardware&#10;address.  If 'clock_seq' is given, it is used as the sequence number;&#10;otherwise a random 14-bit sequence number is chosen.">
				<Param name="[node=None" />
				<Param name="[clock_seq=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid3" func="yes">
			<Overload retVal="" descr="Generate a UUID from the MD5 hash of a namespace UUID and a name.">
				<Param name="namespace" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid4" func="yes">
			<Overload retVal="" descr="Generate a random UUID.">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid5" func="yes">
			<Overload retVal="" descr="Generate a UUID from the SHA-1 hash of a namespace UUID and a name.">
				<Param name="namespace" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="uuid1" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid3" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid4" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid5" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="valid_boundary" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="vals_sorted_by_key" func="yes">
			<Overload retVal="" descr="Function of cookielib">
			</Overload>
		</KeyWord>
		<KeyWord name="value_decode" func="yes">
			<Overload retVal="" descr="Function of Cookie.SmartCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="value_encode" func="yes">
			<Overload retVal="" descr="Function of Cookie.BaseCookie">
			</Overload>
		</KeyWord>
		<KeyWord name="values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="vars" func="yes">
			<Overload retVal="" descr="vars([object]) -&gt; dictionary&#10;&#10;Without arguments, equivalent to locals().&#10;With an argument, equivalent to object.__dict__.">
			</Overload>
		</KeyWord>
		<KeyWord name="version" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="vformat" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="visiblename" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="visit" func="yes">
			<Overload retVal="" descr="Function of ast.NodeTransformer">
			</Overload>
		</KeyWord>
		<KeyWord name="vonmisesvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="wait" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="wait_variable" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="wait_visibility" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="wait_window" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="waitpid" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="waitvar" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="walk" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="walk_packages" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="walktree" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="warn" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="warn_explicit" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="warning" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings" func="yes">
			<Overload retVal="" descr="Python part of the warnings subsystem.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.WarningMessage" func="yes">
			<Overload retVal="" descr="Holds the result of a single showwarning() call.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.catch_warnings" func="yes">
			<Overload retVal="" descr="A context manager that copies and restores the warnings filter upon&#10;exiting the context.&#10;&#10;The 'record' argument specifies whether warnings should be captured by a&#10;custom implementation of warnings.showwarning() and be appended to a list&#10;returned by the context manager. Otherwise None is returned by the context&#10;manager. The objects appended to the list are arguments whose attributes&#10;mirror the arguments to showwarning().&#10;&#10;The 'module' argument is to specify an alternative module to the module&#10;named 'warnings' and imported under that name. This argument is only useful&#10;when testing the warnings module itself.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.default_action" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.defaultaction" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.filters" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.filterwarnings" func="yes">
			<Overload retVal="" descr="Insert an entry into the list of warnings filters (at the front).&#10;&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'message' -- a regex that the warning message must match&#10;'category' -- a class that the warning must be a subclass of&#10;'module' -- a regex that the module name must match&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[message" />
				<Param name="[category=<type 'exceptions.Warning'>" />
				<Param name="[module" />
				<Param name="[lineno=0" />
				<Param name="[append=0]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.formatwarning" func="yes">
			<Overload retVal="" descr="Function to format a warning the standard way.">
				<Param name="message" />
				<Param name="category" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[line=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.resetwarnings" func="yes">
			<Overload retVal="" descr="Clear the list of warning filters, so that no filters are active.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.showwarning" func="yes">
			<Overload retVal="" descr="Hook to write a warning to a file; replace if you like.">
				<Param name="message" />
				<Param name="category" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[file=None" />
				<Param name="[line=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.simplefilter" func="yes">
			<Overload retVal="" descr="Insert a simple entry into the list of warnings filters (at the front).&#10;&#10;A simple filter matches all modules and messages.&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'category' -- a class that the warning must be a subclass of&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[category=<type 'exceptions.Warning'>" />
				<Param name="[lineno=0" />
				<Param name="[append=0]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.warn_explicit" func="yes">
			<Overload retVal="" descr="Low-level inferface to warnings functionality.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.warnpy3k" func="yes">
			<Overload retVal="" descr="Issue a deprecation warning for Python 3.x related changes.&#10;&#10;Warnings are omitted unless Python is started with the -3 option.">
				<Param name="message" />
				<Param name="[category=None" />
				<Param name="[stacklevel=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnpy3k" func="yes">
			<Overload retVal="" descr="Function of rfc822">
			</Overload>
		</KeyWord>
		<KeyWord name="wasSuccessful" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="wave" func="yes">
			<Overload retVal="" descr="Stuff to parse WAVE files.&#10;&#10;Usage.&#10;&#10;Reading WAVE files:&#10;      f = wave.open(file, 'r')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods read(), seek(), and close().&#10;When the setpos() and rewind() methods are not used, the seek()&#10;method is not  necessary.&#10;&#10;This returns an instance of a class with the following public methods:&#10;      getnchannels()  -- returns number of audio channels (1 for&#10;                         mono, 2 for stereo)&#10;      getsampwidth()  -- returns sample width in bytes&#10;      getframerate()  -- returns sampling frequency&#10;      getnframes()    -- returns number of audio frames&#10;      getcomptype()   -- returns compression type ('NONE' for linear samples)&#10;      getcompname()   -- returns human-readable version of&#10;                         compression type ('not compressed' linear samples)&#10;      getparams()     -- returns a tuple consisting of all of the&#10;                         above in the above order&#10;      getmarkers()    -- returns None (for compatibility with the&#10;                         aifc module)&#10;      getmark(id)     -- raises an error since the mark does not&#10;                         exist (for compatibility with the aifc module)&#10;      readframes(n)   -- returns at most n frames of audio&#10;      rewind()        -- rewind to the beginning of the audio stream&#10;      setpos(pos)     -- seek to the specified position&#10;      tell()          -- return the current position&#10;      close()         -- close the instance (make it unusable)&#10;The position returned by tell() and the position given to setpos()&#10;are compatible and have nothing to do with the actual position in the&#10;file.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;Writing WAVE files:&#10;      f = wave.open(file, 'w')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods write(), tell(), seek(), and&#10;close().&#10;&#10;This returns an instance of a class with the following public methods:&#10;      setnchannels(n) -- set the number of channels&#10;      setsampwidth(n) -- set the sample width&#10;      setframerate(n) -- set the frame rate&#10;      setnframes(n)   -- set the number of frames&#10;      setcomptype(type, name)&#10;                      -- set the compression type and the&#10;                         human-readable compression type&#10;      setparams(tuple)&#10;                      -- set all parameters at once&#10;      tell()          -- return current position in output file&#10;      writeframesraw(data)&#10;                      -- write audio frames without pathing up the&#10;                         file header&#10;      writeframes(data)&#10;                      -- write audio frames and patch up the file header&#10;      close()         -- patch up the file header and close the&#10;                         output file&#10;You should set the parameters before the first writeframesraw or&#10;writeframes.  The total number of frames does not need to be set,&#10;but when it is set to the correct value, the header does not have to&#10;be patched up.&#10;It is best to first set all parameters, perhaps possibly the&#10;compression type, and then write audio frames using writeframesraw.&#10;When all frames have been written, either call writeframes('') or&#10;close() to patch up the sizes in the header.&#10;The close() method is called automatically when the class instance&#10;is destroyed.">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Error" />
		<KeyWord name="wave.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.WAVE_FORMAT_PCM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Wave_read" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Wave_write" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.openfp" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="weakref" func="yes">
			<Overload retVal="" descr="Weak reference support for Python.&#10;&#10;This module is an implementation of PEP 205:&#10;&#10;http://www.python.org/dev/peps/pep-0205/">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.CallableProxyType" />
		<KeyWord name="weakref.CallableProxyType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.KeyedRef" func="yes">
			<Overload retVal="" descr="Specialized reference that includes a key corresponding to the value.&#10;&#10;This is used in the WeakValueDictionary to avoid having to create&#10;a function object for each key stored in the mapping.  A shared&#10;callback object can use the 'key' attribute of a KeyedRef instead&#10;of getting a reference to the key from an enclosing scope.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.KeyedRef.key" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ProxyType" />
		<KeyWord name="weakref.ProxyType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ProxyTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ReferenceError" func="yes">
			<Overload retVal="" descr="Weak ref proxy used after referent went away.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ReferenceError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ReferenceError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ReferenceType" />
		<KeyWord name="weakref.WeakKeyDictionary" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.WeakSet" />
		<KeyWord name="weakref.WeakSet.add" />
		<KeyWord name="weakref.WeakSet.clear" />
		<KeyWord name="weakref.WeakSet.copy" />
		<KeyWord name="weakref.WeakSet.difference" />
		<KeyWord name="weakref.WeakSet.difference_update" />
		<KeyWord name="weakref.WeakSet.discard" />
		<KeyWord name="weakref.WeakSet.intersection" />
		<KeyWord name="weakref.WeakSet.intersection_update" />
		<KeyWord name="weakref.WeakSet.isdisjoint" />
		<KeyWord name="weakref.WeakSet.issubset" />
		<KeyWord name="weakref.WeakSet.issuperset" />
		<KeyWord name="weakref.WeakSet.pop" />
		<KeyWord name="weakref.WeakSet.remove" />
		<KeyWord name="weakref.WeakSet.symmetric_difference" />
		<KeyWord name="weakref.WeakSet.symmetric_difference_update" />
		<KeyWord name="weakref.WeakSet.union" />
		<KeyWord name="weakref.WeakSet.update" />
		<KeyWord name="weakref.WeakValueDictionary" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.getweakrefcount" func="yes">
			<Overload retVal="" descr="getweakrefcount(object) -- return the number of weak references&#10;to 'object'.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.getweakrefs" func="yes">
			<Overload retVal="" descr="getweakrefs(object) -- return a list of all weak reference objects&#10;that point to 'object'.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.proxy" func="yes">
			<Overload retVal="" descr="proxy(object[, callback]) -- create a proxy object that weakly&#10;references 'object'.  'callback', if given, is called with a&#10;reference to the proxy when 'object' is about to be finalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ref" />
		<KeyWord name="webbrowser" func="yes">
			<Overload retVal="" descr="Interfaces for launching and remotely controlling Web browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser" func="yes">
			<Overload retVal="" descr="Class for all browsers which are to be started in the&#10;background.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser.open_new" />
		<KeyWord name="webbrowser.BackgroundBrowser.open_new_tab" />
		<KeyWord name="webbrowser.BaseBrowser" func="yes">
			<Overload retVal="" descr="Parent class for all browsers. Do not use directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BaseBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BaseBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BaseBrowser.open_new" />
		<KeyWord name="webbrowser.BaseBrowser.open_new_tab" />
		<KeyWord name="webbrowser.Chrome" func="yes">
			<Overload retVal="" descr="Launcher class for Google Chrome browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.open_new" />
		<KeyWord name="webbrowser.Chrome.open_new_tab" />
		<KeyWord name="webbrowser.Chrome.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium" func="yes">
			<Overload retVal="" descr="Launcher class for Google Chrome browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.open_new" />
		<KeyWord name="webbrowser.Chromium.open_new_tab" />
		<KeyWord name="webbrowser.Chromium.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks" func="yes">
			<Overload retVal="" descr="Launcher class for Elinks browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.open_new" />
		<KeyWord name="webbrowser.Elinks.open_new_tab" />
		<KeyWord name="webbrowser.Elinks.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Error" />
		<KeyWord name="webbrowser.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon" func="yes">
			<Overload retVal="" descr="Launcher class for Galeon/Epiphany browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.open_new" />
		<KeyWord name="webbrowser.Galeon.open_new_tab" />
		<KeyWord name="webbrowser.Galeon.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.remote_action" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser" func="yes">
			<Overload retVal="" descr="Class for all browsers started with a command&#10;and without remote functionality.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser.open_new" />
		<KeyWord name="webbrowser.GenericBrowser.open_new_tab" />
		<KeyWord name="webbrowser.Grail" />
		<KeyWord name="webbrowser.Grail.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Grail.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Grail.open_new" />
		<KeyWord name="webbrowser.Grail.open_new_tab" />
		<KeyWord name="webbrowser.Konqueror" func="yes">
			<Overload retVal="" descr="Controller for the KDE File Manager (kfm, or Konqueror).&#10;&#10;See the output of ``kfmclient --commands``&#10;for more information on the Konqueror remote-control interface.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Konqueror.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Konqueror.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Konqueror.open_new" />
		<KeyWord name="webbrowser.Konqueror.open_new_tab" />
		<KeyWord name="webbrowser.Mozilla" func="yes">
			<Overload retVal="" descr="Launcher class for Mozilla/Netscape browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.open_new" />
		<KeyWord name="webbrowser.Mozilla.open_new_tab" />
		<KeyWord name="webbrowser.Mozilla.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape" func="yes">
			<Overload retVal="" descr="Launcher class for Mozilla/Netscape browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.open_new" />
		<KeyWord name="webbrowser.Netscape.open_new_tab" />
		<KeyWord name="webbrowser.Netscape.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera" func="yes">
			<Overload retVal="" descr="Launcher class for Opera browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.open_new" />
		<KeyWord name="webbrowser.Opera.open_new_tab" />
		<KeyWord name="webbrowser.Opera.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser" func="yes">
			<Overload retVal="" descr="Parent class for all Unix browsers with remote functionality.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.open_new" />
		<KeyWord name="webbrowser.UnixBrowser.open_new_tab" />
		<KeyWord name="webbrowser.UnixBrowser.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault" />
		<KeyWord name="webbrowser.WindowsDefault.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault.open_new" />
		<KeyWord name="webbrowser.WindowsDefault.open_new_tab" />
		<KeyWord name="webbrowser.browser" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.get" func="yes">
			<Overload retVal="" descr="Return a browser launcher instance appropriate for the environment.">
				<Param name="[using=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.iexplore" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.main" />
		<KeyWord name="webbrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.open_new" />
		<KeyWord name="webbrowser.open_new_tab" />
		<KeyWord name="webbrowser.register" func="yes">
			<Overload retVal="" descr="Register a browser connector and, optionally, connection.">
				<Param name="name" />
				<Param name="klass" />
				<Param name="[instance=None" />
				<Param name="[update_tryorder=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.register_X_browsers" />
		<KeyWord name="week" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="weekday" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="weekheader" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="weibullvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="what" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="whathdr" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="whichdb" func="yes">
			<Overload retVal="" descr="Guess which db package to use to open a db file.">
			</Overload>
		</KeyWord>
		<KeyWord name="whichdb.whichdb" func="yes">
			<Overload retVal="" descr="Guess which db package to use to open a db file.&#10;&#10;Return values:&#10;&#10;- None if the database file can't be read;&#10;- empty string if the file can be read but can't be recognized&#10;- the module name (e.g. &quot;dbm&quot; or &quot;gdbm&quot;) if recognized.&#10;&#10;Importing the given module may still fail, and opening the&#10;database using that module may still fail.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="whichmodule" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="while" />
		<KeyWord name="whseed" func="yes">
			<Overload retVal="" descr="Function of random.WichmannHill">
			</Overload>
		</KeyWord>
		<KeyWord name="width" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="win32_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="win_getpass" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="window_height" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="window_width" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_atom" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_atomname" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_cells" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_children" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_class" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_colormapfull" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_containing" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_depth" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_exists" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_fpixels" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_geometry" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_height" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_id" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_interps" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_ismapped" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_manager" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_name" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_parent" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_pathname" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_pixels" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_pointerx" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_pointerxy" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_pointery" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_reqheight" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_reqwidth" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_rgb" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_rootx" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_rooty" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screen" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screencells" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screendepth" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screenheight" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screenmmheight" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screenmmwidth" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screenvisual" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_screenwidth" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_server" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_toplevel" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_viewable" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_visual" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_visualid" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_visualsavailable" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_vrootheight" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_vrootwidth" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_vrootx" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_vrooty" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_width" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_x" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winfo_y" func="yes">
			<Overload retVal="" descr="Function of ttk.LabeledScale">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound" func="yes">
			<Overload retVal="" descr="PlaySound(sound, flags) - play a sound&#10;SND_FILENAME - sound is a wav file name&#10;SND_ALIAS - sound is a registry sound association name&#10;SND_LOOP - Play the sound repeatedly; must also specify SND_ASYNC&#10;SND_MEMORY - sound is a memory image of a wav file&#10;SND_PURGE - stop all instances of the specified sound&#10;SND_ASYNC - PlaySound returns immediately&#10;SND_NODEFAULT - Do not play a default beep if the sound can not be found&#10;SND_NOSTOP - Do not interrupt any sounds currently playing&#10;SND_NOWAIT - Return immediately if the sound driver is busy&#10;&#10;Beep(frequency, duration) - Make a beep through the PC speaker.">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.Beep" func="yes">
			<Overload retVal="" descr="Beep(frequency, duration) - a wrapper around the Windows Beep API&#10;&#10;The frequency argument specifies frequency, in hertz, of the sound.&#10;This parameter must be in the range 37 through 32,767.&#10;The duration argument specifies the number of milliseconds.">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONASTERISK" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONEXCLAMATION" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONHAND" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONQUESTION" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MessageBeep" func="yes">
			<Overload retVal="" descr="MessageBeep(x) - call Windows MessageBeep(x). x defaults to MB_OK.">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.PlaySound" func="yes">
			<Overload retVal="" descr="PlaySound(sound, flags) - a wrapper around the Windows PlaySound API&#10;&#10;The sound argument can be a filename, data, or None.&#10;For flag values, ored together, see module documentation.">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_ALIAS" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_APPLICATION" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_ASYNC" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_FILENAME" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_LOOP" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_MEMORY" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_NODEFAULT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_NOSTOP" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_NOWAIT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_PURGE" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="with" />
		<KeyWord name="wr_long" func="yes">
			<Overload retVal="" descr="Function of py_compile">
			</Overload>
		</KeyWord>
		<KeyWord name="wrap" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="wrap_socket" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="wraps" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="writable" func="yes">
			<Overload retVal="" descr="Function of io.TextIOWrapper">
			</Overload>
		</KeyWord>
		<KeyWord name="write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="write32u" func="yes">
			<Overload retVal="" descr="Function of gzip">
			</Overload>
		</KeyWord>
		<KeyWord name="writePlist" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="writePlistToResource" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="writePlistToString" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="write_docstringdict" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="writedoc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="writedocs" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="writepy" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="writer" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="writestr" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="wsgiref" func="yes">
			<Overload retVal="" descr="wsgiref -- a WSGI (PEP 333) Reference Library&#10;&#10;Current Contents:&#10;&#10;* util -- Miscellaneous useful functions and wrappers&#10;&#10;* headers -- Manage response headers&#10;&#10;* handlers -- base classes for server/gateway implementations&#10;&#10;* simple_server -- a simple BaseHTTPServer that supports WSGI&#10;&#10;* validate -- validation wrapper that sits between an app and a server&#10;  to detect errors in either&#10;&#10;To-Do:&#10;&#10;* cgi_gateway -- Run WSGI apps under CGI (pending a deployment standard)&#10;&#10;* cgi_wrapper -- Run CGI apps under WSGI&#10;&#10;* router -- a simple middleware component that handles URL traversal">
			</Overload>
		</KeyWord>
		<KeyWord name="wstring_at" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="xcor" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib" func="yes">
			<Overload retVal="" descr="Implements (a subset of) Sun XDR -- eXternal Data Representation.&#10;&#10;See: RFC 1014">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.ConversionError" />
		<KeyWord name="xdrlib.ConversionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.ConversionError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Error" func="yes">
			<Overload retVal="" descr="Exception class for this module. Use:&#10;&#10;except xdrlib.Error, var:&#10;    # var has the Error instance for the exception&#10;&#10;Public ivars:&#10;    msg -- contains the message">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Packer" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Unpacker" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.raise_conversion_error" func="yes">
			<Overload retVal="" descr="Wrap any raised struct.errors in a ConversionError.">
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.wraps" func="yes">
			<Overload retVal="" descr="Decorator factory to apply update_wrapper() to a wrapper function&#10;&#10;Returns a decorator that invokes update_wrapper() with the decorated&#10;function as the wrapper argument and the arguments to wraps() as the&#10;remaining arguments. Default arguments are as for update_wrapper().&#10;This is a convenience function to simplify applying partial() to&#10;update_wrapper().">
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__doc__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xml" func="yes">
			<Overload retVal="" descr="Core XML support for Python.&#10;&#10;This package contains four sub-packages:&#10;&#10;dom -- The W3C Document Object Model.  This supports DOM Level 1 +&#10;       Namespaces.&#10;&#10;parsers -- Python wrappers for XML parsers (currently only supports Expat).&#10;&#10;sax -- The Simple API for XML, developed by XML-Dev, led by David&#10;       Megginson and ported to Python by Lars Marius Garshol.  This&#10;       supports the SAX 2 API.&#10;&#10;etree -- The ElementTree XML library.  This is a subset of the full&#10;       ElementTree XML release.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlcharrefreplace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib" func="yes">
			<Overload retVal="" descr="A parser for XML, using the derived class as static DTD.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.Error" />
		<KeyWord name="xmllib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.TestXMLParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.XMLParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.amp" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.attrfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.attrtrans" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.cdataclose" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.cdataopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.charref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.commentclose" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.commentopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.doctype" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.doubledash" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.endbracket" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.endbracketfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.endtagopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.entityref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.illegal" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.interesting" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.ncname" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.newline" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.procclose" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.procopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.qname" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.ref" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.space" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.starttagend" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.starttagmatch" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.starttagopen" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.tagfind" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.xmldecl" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmllib.xmlns" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib" func="yes">
			<Overload retVal="" descr='An XML-RPC client interface for Python.&#10;&#10;The marshalling and response parser code can also be used to&#10;implement XML-RPC servers.&#10;&#10;Exported exceptions:&#10;&#10;  Error          Base class for client errors&#10;  ProtocolError  Indicates an HTTP protocol error&#10;  ResponseError  Indicates a broken response package&#10;  Fault          Indicates an XML-RPC fault package&#10;&#10;Exported classes:&#10;&#10;  ServerProxy    Represents a logical connection to an XML-RPC server&#10;&#10;  MultiCall      Executor of boxcared xmlrpc requests&#10;  Boolean        boolean wrapper to generate a "boolean" XML-RPC value&#10;  DateTime       dateTime wrapper for an ISO 8601 string or time tuple or&#10;                 localtime integer value to generate a "dateTime.iso8601"&#10;                 XML-RPC value&#10;  Binary         binary data wrapper&#10;&#10;  SlowParser     Slow but safe standard parser (based on xmllib)&#10;  Marshaller     Generate an XML-RPC params chunk from a Python data structure&#10;  Unmarshaller   Unmarshal an XML-RPC response from incoming XML event message&#10;  Transport      Handles an HTTP transaction to an XML-RPC server&#10;  SafeTransport  Handles an HTTPS transaction to an XML-RPC server&#10;&#10;Exported constants:&#10;&#10;  True&#10;  False&#10;&#10;Exported functions:&#10;&#10;  boolean        Convert any Python value to an XML-RPC boolean&#10;  getparser      Create instance of the fastest available parser &amp; attach&#10;                 to an unmarshalling object&#10;  dumps          Convert an argument tuple or a Fault instance to an XML-RPC&#10;                 request (or response, if the methodresponse option is used).&#10;  loads          Convert an XML-RPC packet to unmarshalled data plus a method&#10;                 name (None if not present).'>
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.APPLICATION_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Binary" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Boolean.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BooleanType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BufferType" func="yes">
			<Overload retVal="" descr="buffer(object [, offset[, size]])&#10;&#10;Create a new buffer object which references the given object.&#10;The buffer will reference a slice of the target object from the&#10;start of the object (or at the specified offset). The slice will&#10;extend to the end of the target object (or with the specified size).">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.BuiltinFunctionType" />
		<KeyWord name="xmlrpclib.BuiltinMethodType" />
		<KeyWord name="xmlrpclib.ClassType" func="yes">
			<Overload retVal="" descr="classobj(name, bases, dict)&#10;&#10;Create a class object.  The name must be a string; the second argument&#10;a tuple of classes, and the third a dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, nlocals, stacksize, flags, codestring, constants, names,&#10;      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ComplexType" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ComplexType.conjugate" func="yes">
			<Overload retVal="" descr="complex.conjugate() -&gt; complex&#10;&#10;Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ComplexType.imag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ComplexType.real" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DateTime" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType" />
		<KeyWord name="xmlrpclib.DictProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if D.has_key(k), else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.fromkeys" func="yes">
			<Overload retVal="" descr="dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#10;v defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.has_key" func="yes">
			<Overload retVal="" descr="D.has_key(k) -&gt; True if D has a key k, else False">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.iteritems" func="yes">
			<Overload retVal="" descr="D.iteritems() -&gt; an iterator over the (key, value) items of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.iterkeys" func="yes">
			<Overload retVal="" descr="D.iterkeys() -&gt; an iterator over the keys of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.itervalues" func="yes">
			<Overload retVal="" descr="D.itervalues() -&gt; an iterator over the values of D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E present and has a .keys() method, does:     for k in E: D[k] = E[k]&#10;If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v&#10;In either case, this is followed by: for k in F: D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.viewitems" func="yes">
			<Overload retVal="" descr="D.viewitems() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.viewkeys" func="yes">
			<Overload retVal="" descr="D.viewkeys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.DictionaryType.viewvalues" func="yes">
			<Overload retVal="" descr="D.viewvalues() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.EllipsisType" />
		<KeyWord name="xmlrpclib.Error" func="yes">
			<Overload retVal="" descr="Base class for client errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ExpatParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Fault" func="yes">
			<Overload retVal="" descr="Indicates an XML-RPC fault package.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Fault.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Fault.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType" func="yes">
			<Overload retVal="" descr="file(name[, mode[, buffering]]) -&gt; file object&#10;&#10;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#10;writing or appending.  The file will be created if it doesn't exist&#10;when opened for writing or appending; it will be truncated when&#10;opened for writing.  Add a 'b' to the mode for binary files.&#10;Add a '+' to the mode to allow simultaneous reading and writing.&#10;If the buffering argument is given, 0 means unbuffered, 1 means line&#10;buffered, and larger numbers specify the buffer size.  The preferred way&#10;to open a file is with the builtin open() function.&#10;Add a 'U' to mode to open the file for input with universal newline&#10;support.  Any line ending in the input file will be seen as a '\n'&#10;in Python.  Also, a file so opened gains the attribute 'newlines';&#10;the value for this attribute is one of None (no newline read yet),&#10;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#10;&#10;'U' cannot be combined with 'w' or '+' mode.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; None or (perhaps) an integer.  Close the file.&#10;&#10;Sets data attribute .closed to True.  A closed file cannot be used for&#10;further I/O operations.  close() may be called more than once without&#10;error.  Some kinds of file objects (for example, opened by popen())&#10;may return an exit status upon closing.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.errors" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.fileno" func="yes">
			<Overload retVal="" descr='fileno() -&gt; integer "file descriptor".&#10;&#10;This is needed for lower-level file interfaces, such os.read().'>
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.flush" func="yes">
			<Overload retVal="" descr="flush() -&gt; None.  Flush the internal I/O buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.isatty" func="yes">
			<Overload retVal="" descr="isatty() -&gt; true or false.  True if the file is connected to a tty device.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.read" func="yes">
			<Overload retVal="" descr="read([size]) -&gt; read at most size bytes, returned as a string.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Notice that when in non-blocking mode, less data than what was requested&#10;may be returned, even if no size parameter was given.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.readinto" func="yes">
			<Overload retVal="" descr="readinto() -&gt; Undocumented.  Don't use this; it may go away.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.readline" func="yes">
			<Overload retVal="" descr="readline([size]) -&gt; next line from the file, as a string.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty string at EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.readlines" func="yes">
			<Overload retVal="" descr="readlines([size]) -&gt; list of strings, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.seek" func="yes">
			<Overload retVal="" descr="seek(offset[, whence]) -&gt; None.  Move to new file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#10;(move relative to current position, positive or negative), and 2 (move&#10;relative to end of file, usually negative, although many platforms allow&#10;seeking beyond the end of a file).  If the file is opened in text mode,&#10;only offsets returned by tell() are legal.  Use of other offsets causes&#10;undefined behavior.&#10;Note that not all file objects are seekable.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.softspace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.tell" func="yes">
			<Overload retVal="" descr="tell() -&gt; current file position, an integer (may be a long integer).">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.truncate" func="yes">
			<Overload retVal="" descr="truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.write" func="yes">
			<Overload retVal="" descr="write(str) -&gt; None.  Write string str to file.&#10;&#10;Note that due to buffering, flush() or close() may be needed before&#10;the file on disk reflects the data written.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.writelines" func="yes">
			<Overload retVal="" descr="writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#10;&#10;Note that newlines are not added.  The sequence can be any iterable object&#10;producing strings. This is equivalent to calling write() for each string.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FileType.xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.conjugate" func="yes">
			<Overload retVal="" descr="Return self, the complex conjugate of any float.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-4.9406564584124654e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.hex" func="yes">
			<Overload retVal="" descr="float.hex() -&gt; string&#10;&#10;Return a hexadecimal representation of a floating-point number.&#10;&gt;&gt;&gt; (-0.1).hex()&#10;'-0x1.999999999999ap-4'&#10;&gt;&gt;&gt; 3.14159.hex()&#10;'0x1.921f9f01b866ep+1'">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FloatType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType" />
		<KeyWord name="xmlrpclib.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_exc_traceback" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_exc_type" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_exc_value" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_restricted" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.FunctionType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType" />
		<KeyWord name="xmlrpclib.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.GetSetDescriptorType" />
		<KeyWord name="xmlrpclib.GzipDecodedResponse" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.INTERNAL_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.INVALID_ENCODING_CHAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.INVALID_METHOD_PARAMS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.INVALID_XMLRPC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.InstanceType" func="yes">
			<Overload retVal="" descr="instance(class[, dict])&#10;&#10;Create an instance without calling its __init__() method.&#10;The class must be a classic class.&#10;If present, dict must be a dictionary or None.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.InstanceType.next" func="yes">
			<Overload retVal="" descr="x.next() -&gt; the next value, or raise StopIteration">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; int or long&#10;int(x, base=10) -&gt; int or long&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;If x is outside the integer range, the function returns a long instead.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.IntType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_closure" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_code" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_defaults" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_dict" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LambdaType.func_name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.append" func="yes">
			<Overload retVal="" descr="L.append(object) -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ListType.sort" func="yes">
			<Overload retVal="" descr="L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#10;cmp(x, y) -&gt; -1, 0, 1">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType" func="yes">
			<Overload retVal="" descr="long(x=0) -&gt; long&#10;long(x, base=10) -&gt; long&#10;&#10;Convert a number or string to a long integer, or return 0L if no arguments&#10;are given.  If x is floating point, the conversion truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string or&#10;Unicode object representing an integer literal in the given base.  The&#10;literal can be preceded by '+' or '-' and be surrounded by whitespace.&#10;The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to&#10;interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4L">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType.bit_length" func="yes">
			<Overload retVal="" descr="long.bit_length() -&gt; int or long&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37L)&#10;'0b100101'&#10;&gt;&gt;&gt; (37L).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any long.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.LongType.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MAXINT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.METHOD_NOT_FOUND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MININT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Marshaller" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MemberDescriptorType" />
		<KeyWord name="xmlrpclib.MethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MultiCall" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.MultiCallIterator" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.NOT_WELLFORMED_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.NoneType" />
		<KeyWord name="xmlrpclib.NotImplementedType" />
		<KeyWord name="xmlrpclib.ObjectType" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.PARSE_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ProtocolError" func="yes">
			<Overload retVal="" descr="Indicates an HTTP protocol error.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ProtocolError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ProtocolError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ResponseError" func="yes">
			<Overload retVal="" descr="Indicates a broken response package.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ResponseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ResponseError.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SERVER_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SYSTEM_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SafeTransport" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Server" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.ServerProxy" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SliceType" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SliceType.indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SliceType.start" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SliceType.step" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SliceType.stop" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.SlowParser" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; string&#10;&#10;Return a nice string representation of the object.&#10;If the argument is a string, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; string&#10;&#10;Return a copy of the string S with only its first character&#10;capitalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; string&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are interpreted&#10;as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; object&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; object&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that is able to handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; string&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; string&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. uppercase characters may only follow uncased&#10;characters and lowercase characters only cased ones. Return False&#10;otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; string&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; string&#10;&#10;Return S left-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; string&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; string&#10;&#10;Return a copy of string S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; string&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string, starting at the end of the string and working&#10;to the front.  If maxsplit is given, at most maxsplit splits are&#10;done. If sep is not specified or is None, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in the string S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are removed&#10;from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; string or unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is unicode, S will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; string&#10;&#10;Return a copy of the string S with uppercase characters&#10;converted to lowercase and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; string&#10;&#10;Return a titlecased version of S, i.e. words start with uppercase&#10;characters, all remaining cased characters have lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table [,deletechars]) -&gt; string&#10;&#10;Return a copy of the string S, where all characters occurring&#10;in the optional argument deletechars are removed, and the&#10;remaining characters have been mapped through the given&#10;translation table, which must be a string of length 256 or None.&#10;If the table argument is None, no translation is applied and&#10;the operation simply removes the characters in deletechars.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; string&#10;&#10;Return a copy of the string S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; string&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width.  The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.StringTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TRANSPORT_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TracebackType" />
		<KeyWord name="xmlrpclib.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Transport" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.True" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TupleType" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TupleType.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TupleType.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TypeType" func="yes">
			<Overload retVal="" descr="type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.TypeType.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UNSUPPORTED_ENCODING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnboundMethodType" func="yes">
			<Overload retVal="" descr="instancemethod(function, instance, class)&#10;&#10;Create an instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnboundMethodType.im_class" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnboundMethodType.im_func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnboundMethodType.im_self" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType" func="yes">
			<Overload retVal="" descr="unicode(object='') -&gt; unicode object&#10;unicode(string[, encoding[, errors]]) -&gt; unicode object&#10;&#10;Create a new Unicode object from the given encoded string.&#10;encoding defaults to the current default string encoding.&#10;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; unicode&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; unicode&#10;&#10;Return S centered in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;Unicode string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.decode" func="yes">
			<Overload retVal="" descr="S.decode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Decodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;as well as any other name registered with codecs.register_error that is&#10;able to handle UnicodeDecodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.encode" func="yes">
			<Overload retVal="" descr="S.encode([encoding[,errors]]) -&gt; string or unicode&#10;&#10;Encodes S using the codec registered for encoding. encoding defaults&#10;to the default encoding. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs([tabsize]) -&gt; unicode&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.find" func="yes">
			<Overload retVal="" descr="S.find(sub [,start [,end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; unicode&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.index" func="yes">
			<Overload retVal="" descr="S.index(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.find() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; unicode&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; int&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; unicode&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; unicode&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub [,start [,end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub [,start [,end]]) -&gt; int&#10;&#10;Like S.rfind() but raise ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; unicode&#10;&#10;Return S right-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.split" func="yes">
			<Overload retVal="" descr="S.split([sep [,maxsplit]]) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines(keepends=False) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; unicode&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.&#10;If chars is a str, it will be converted to unicode before stripping">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; unicode&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; unicode&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; unicode&#10;&#10;Return a copy of the string S, where all characters have been mapped&#10;through the given translation table, which must be a mapping of&#10;Unicode ordinals to Unicode ordinals, Unicode strings or None.&#10;Unmapped characters are left untouched. Characters mapped to None&#10;are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; unicode&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.UnicodeType.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; unicode&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.Unmarshaller" func="yes">
			<Overload retVal="" descr="(classobj)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.WRAPPERS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.XRangeType" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.boolean.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.dumps" func="yes">
			<Overload retVal="" descr="data [,options] -&gt; marshalled data&#10;&#10;Convert an argument tuple or a Fault instance to an XML-RPC&#10;request (or response, if the methodresponse option is used).&#10;&#10;In addition to the data object, the following options can be given&#10;as keyword arguments:&#10;&#10;    methodname: the method name for a methodCall packet&#10;&#10;    methodresponse: true to create a methodResponse packet.&#10;    If this option is used with a tuple, the tuple must be&#10;    a singleton (i.e. it can contain only one element).&#10;&#10;    encoding: the packet encoding (default is UTF-8)&#10;&#10;All 8-bit strings in the data structure are assumed to use the&#10;packet encoding.  Unicode strings are automatically converted,&#10;where necessary.">
				<Param name="params" />
				<Param name="[methodname=None" />
				<Param name="[methodresponse=None" />
				<Param name="[encoding=None" />
				<Param name="[allow_none=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.escape" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[replace=<function replace at 0x00000000028EBD68>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.getparser" func="yes">
			<Overload retVal="" descr="getparser() -&gt; parser, unmarshaller&#10;&#10;Create an instance of the fastest available parser, and attach it&#10;to an unmarshalling object.  Return both objects.">
				<Param name="[use_datetime=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.gzip_decode" func="yes">
			<Overload retVal="" descr="gzip encoded data -&gt; unencoded data&#10;&#10;Decode data using the gzip content encoding as described in RFC 1952">
				<Param name="data" />
				<Param name="[max_decode=20971520]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.gzip_encode" func="yes">
			<Overload retVal="" descr="data -&gt; gzip encoded data&#10;&#10;Encode data using the gzip content encoding as described in RFC 1952">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpclib.loads" func="yes">
			<Overload retVal="" descr="data -&gt; unmarshalled data, method name&#10;&#10;Convert an XML-RPC packet to unmarshalled data plus a method&#10;name (None if not present).&#10;&#10;If the XML-RPC packet represents a fault condition, this function&#10;raises a Fault exception.">
				<Param name="data" />
				<Param name="[use_datetime=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xrange" func="yes">
			<Overload retVal="" descr="xrange(stop) -&gt; xrange object&#10;xrange(start, stop[, step]) -&gt; xrange object&#10;&#10;Like range(), but instead of returning a list, returns an object that&#10;generates the numbers in the range on demand.  For looping, this is &#10;slightly faster than range() and more memory efficient.">
			</Overload>
		</KeyWord>
		<KeyWord name="xreadlines" func="yes">
			<Overload retVal="" descr="xreadlines() -&gt; returns self.&#10;&#10;For backward compatibility. File objects now include the performance&#10;optimizations previously implemented in the xreadlines module.">
			</Overload>
		</KeyWord>
		<KeyWord name="ycor" func="yes">
			<Overload retVal="" descr="Function of turtle">
			</Overload>
		</KeyWord>
		<KeyWord name="yeardatescalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="yeardays2calendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="yeardayscalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="yield" />
		<KeyWord name="yiq_to_rgb" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="zfill" func="yes">
			<Overload retVal="" descr="B.zfill(width) -&gt; copy of B&#10;&#10;Pad a numeric string B with zeros on the left, to fill a field&#10;of the specified width.  B is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="zip" func="yes">
			<Overload retVal="" descr="zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]&#10;&#10;Return a list of tuples, where each tuple contains the i-th element&#10;from each of the argument sequences.  The returned list is truncated&#10;in length to the length of the shortest argument sequence.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile" func="yes">
			<Overload retVal="" descr="Read and write ZIP files.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipfile" />
		<KeyWord name="zipfile.BadZipfile.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipfile.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LargeZipFile" func="yes">
			<Overload retVal="" descr="Raised when writing a zipfile, the zipfile requires ZIP64 extensions&#10;and those extensions are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LargeZipFile.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LargeZipFile.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile" func="yes">
			<Overload retVal="" descr="Class to create ZIP archives with Python library files and packages.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.close" func="yes">
			<Overload retVal="" descr='Close the file, and for mode "w" and "a" write the ending&#10;records.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.comment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a ZipInfo object. You can&#10;specify a different directory using `path'.">
				<Param name="self" />
				<Param name="member" />
				<Param name="[path=None" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory. `path' specifies a different directory to extract to.&#10;`members' is optional and must be a subset of the list returned&#10;by namelist().">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[members=None" />
				<Param name="[pwd=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.getinfo" func="yes">
			<Overload retVal="" descr="Return the instance of ZipInfo given 'name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.infolist" func="yes">
			<Overload retVal="" descr="Return a list of class ZipInfo instances for files in the&#10;archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.namelist" func="yes">
			<Overload retVal="" descr="Return a list of file names in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.open" func="yes">
			<Overload retVal="" descr="Return file-like object for 'name'.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.printdir" func="yes">
			<Overload retVal="" descr="Print a table of contents for the zip file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.read" func="yes">
			<Overload retVal="" descr="Return file bytes (as a string) for name.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[pwd=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.setpassword" func="yes">
			<Overload retVal="" descr="Set default password for encrypted files.">
				<Param name="self" />
				<Param name="pwd" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.testzip" func="yes">
			<Overload retVal="" descr="Read all the files and check the CRC.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.write" func="yes">
			<Overload retVal="" descr="Put the bytes from filename into the archive under the name&#10;arcname.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="[arcname=None" />
				<Param name="[compress_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.writepy" func="yes">
			<Overload retVal="" descr='Add all files from "pathname" to the ZIP archive.&#10;&#10;If pathname is a package directory, search the directory and&#10;all package subdirectories recursively for all *.py and enter&#10;the modules into the archive.  If pathname is a plain&#10;directory, listdir *.py and enter all modules.  Else, pathname&#10;must be a Python *.py file and the module will be put into the&#10;archive.  Added modules are always module.pyo or module.pyc.&#10;This method will compile the module.py into module.pyc if&#10;necessary.'>
				<Param name="self" />
				<Param name="pathname" />
				<Param name="[basename]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.writestr" func="yes">
			<Overload retVal="" descr="Write a file into the archive.  The contents is the string&#10;'bytes'.  'zinfo_or_arcname' is either a ZipInfo instance or&#10;the name of the file in the archive.">
				<Param name="self" />
				<Param name="zinfo_or_arcname" />
				<Param name="bytes" />
				<Param name="[compress_type=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP64_LIMIT" func="yes">
			<Overload retVal="" descr="(long)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_DEFLATED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_FILECOUNT_LIMIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_MAX_COMMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipExtFile" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile" func="yes">
			<Overload retVal="" descr='Class with methods to open, read, write, close, list zip files.&#10;&#10;z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=False)&#10;&#10;file: Either the path to the file, or a file-like object.&#10;      If it is a path, the file will be opened and closed by ZipFile.&#10;mode: The mode can be either read "r", write "w" or append "a".&#10;compression: ZIP_STORED (no compression) or ZIP_DEFLATED (requires zlib).&#10;allowZip64: if True ZipFile will create files with ZIP64 extensions when&#10;            needed, otherwise it will raise an exception when this would&#10;            be necessary.'>
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.close" func="yes">
			<Overload retVal="" descr='Close the file, and for mode "w" and "a" write the ending&#10;records.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.comment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a ZipInfo object. You can&#10;specify a different directory using `path'.">
				<Param name="self" />
				<Param name="member" />
				<Param name="[path=None" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory. `path' specifies a different directory to extract to.&#10;`members' is optional and must be a subset of the list returned&#10;by namelist().">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[members=None" />
				<Param name="[pwd=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.getinfo" func="yes">
			<Overload retVal="" descr="Return the instance of ZipInfo given 'name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.infolist" func="yes">
			<Overload retVal="" descr="Return a list of class ZipInfo instances for files in the&#10;archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.namelist" func="yes">
			<Overload retVal="" descr="Return a list of file names in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.open" func="yes">
			<Overload retVal="" descr="Return file-like object for 'name'.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.printdir" func="yes">
			<Overload retVal="" descr="Print a table of contents for the zip file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.read" func="yes">
			<Overload retVal="" descr="Return file bytes (as a string) for name.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[pwd=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.setpassword" func="yes">
			<Overload retVal="" descr="Set default password for encrypted files.">
				<Param name="self" />
				<Param name="pwd" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.testzip" func="yes">
			<Overload retVal="" descr="Read all the files and check the CRC.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.write" func="yes">
			<Overload retVal="" descr="Put the bytes from filename into the archive under the name&#10;arcname.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="[arcname=None" />
				<Param name="[compress_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.writestr" func="yes">
			<Overload retVal="" descr="Write a file into the archive.  The contents is the string&#10;'bytes'.  'zinfo_or_arcname' is either a ZipInfo instance or&#10;the name of the file in the archive.">
				<Param name="self" />
				<Param name="zinfo_or_arcname" />
				<Param name="bytes" />
				<Param name="[compress_type=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo" func="yes">
			<Overload retVal="" descr="Class with attributes describing each file in the ZIP archive.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.CRC" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.FileHeader" func="yes">
			<Overload retVal="" descr="Return the per-file header as a string.">
				<Param name="self" />
				<Param name="[zip64=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.comment" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.compress_size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.compress_type" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.create_system" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.create_version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.date_time" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.external_attr" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.extra" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.extract_version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.file_size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.flag_bits" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.header_offset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.internal_attr" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.orig_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.reserved" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.volume" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.compressor_names" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.crc32" func="yes">
			<Overload retVal="" descr="crc32(string[, start]) -- Compute a CRC-32 checksum of string.&#10;&#10;An optional starting value can be specified.  The returned checksum is&#10;a signed integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.error" />
		<KeyWord name="zipfile.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.error.message" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.is_zipfile" func="yes">
			<Overload retVal="" descr="Quickly see if a file is a ZIP file by checking the magic number.&#10;&#10;The filename argument may be a file or file-like object too.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.main" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeCentralDir" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeEndCentDir" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeEndCentDir64" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeEndCentDir64Locator" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeFileHeader" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringCentralDir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringEndArchive" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringEndArchive64" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringEndArchive64Locator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringFileHeader" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structCentralDir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structEndArchive" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structEndArchive64" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structEndArchive64Locator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structFileHeader" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipimporter" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
	</AutoComplete>
</NotepadPlus>
